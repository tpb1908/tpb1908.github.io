<!DOCTYPE html>
<html>

<head>
	<!-- Meta -->
	<meta charset="UTF-8"/>
	<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">
	<meta name="generator" content="Jekyll">

	<title>Test Post</title>
  <meta name="description" content="A minimal, responsive, ready to use blog template, built with Jekyll.">

	<!-- CSS & fonts -->
	<!--  <link rel="stylesheet" href="/css/main.css"> -->

	<style type="text/css">
    
    *{-webkit-box-sizing:border-box;-moz-box-sizing:border-box;box-sizing:border-box}html,body,h1,h2,h3,h4,h5,h6,p,ul,ol,li,img{margin:0;padding:0;border:0}html{background-color:#fff;font-size:16px;line-height:1.8;color:#333}@media (min-width: 940px){html{font-size:18px}}body{max-width:1000px;margin:0 auto;padding:0 10px}a{color:#333;text-decoration:none;font-weight:700}a:hover,a:focus{color:#262626}.f-right{float:right}.f-left{float:left}.clear{clear:both}.parent{display:flex}.inner{align-self:center}.justify-center{justify-content:center}.justify-spaceBetween{justify-content:space-between}.w100{width:100%}.h100{height:100%}.wh100{width:100%;height:100%}.absolute{position:absolute}.relative{position:relative}.top{top:0}.bottom{bottom:0}.right{right:0}.left{left:0}body{font-family:"Roboto", "Helvetica Neue", "Helvetica", "Arial", sans-serif;font-style:normal;font-weight:400;font-size:16px;color:#333}p,ul,ol{font-size:1em;line-height:1.8em;margin-bottom:1.5em}h1{font-size:2.25em;line-height:1.8em;padding:0.33335em 0}h2{font-size:1.5em;line-height:1.8em;padding:1em 0 0 0}h3,h4,h5,h6{font-size:1.125em;line-height:1.8em;padding:0.66667em 0}blockquote{font-style:italic;margin:1.5em;-webkit-border-radius:4px;-moz-border-radius:4px;-ms-border-radius:4px;border-radius:4px;background-color:#f2f2f2;padding:0 1.5em}blockquote p,blockquote ul,blockquote ol{padding:1.5em 0}@media (min-width: 940px){p,ul,ol{font-size:1em;line-height:1.8em;margin-bottom:1.3334em}h1{font-size:2.6667em;line-height:1.8em;padding:0.25em 0}h2{font-size:2em;line-height:1.8em;padding:0.66667em 0 0 0}h3,h4,h5,h6{font-size:1.3334em;line-height:1.8em;padding:0.5em 0}blockquote{font-style:italic;margin:1.3334em;-webkit-border-radius:4px;-moz-border-radius:4px;-ms-border-radius:4px;border-radius:4px;background-color:#f2f2f2;padding:0 1.33334em}blockquote p,blockquote ul,blockquote ol{padding:1.33334em 0}}#nav a,#nav-left a{display:block;color:#333;padding:0.33334em 0;font-size:1.5em;font-weight:400}@media (min-width: 940px){#nav a,#nav-left a{font-size:1em}}#nav a:hover,#nav-left a:hover{background-color:rgba(13,13,13,0.6)}#nav span,#nav-left span{font-weight:200}#nav{width:14rem;position:fixed;background-color:#fff;top:0;bottom:0;right:-14rem;color:#fff;opacity:0.95;-webkit-transition:all 0.3s ease-in;-moz-transition:all 0.3s ease-in;-ms-transition:all 0.3s ease-in;transition:all 0.3s ease-in;z-index:1;padding:72px 0;text-align:center}#nav-left{width:14rem;position:fixed;background-color:#fff;top:0;bottom:0;left:-14rem;color:#fff;opacity:0.95;-webkit-transition:all 0.3s ease-in;-moz-transition:all 0.3s ease-in;-ms-transition:all 0.3s ease-in;transition:all 0.3s ease-in;z-index:1;padding:72px 0;text-align:center}#nav.menu-open{-webkit-transform:translateX(-14rem);-moz-transform:translateX(-14rem);-ms-transform:translateX(-14rem);transform:translateX(-14rem);width:100%;z-index:100}@media (min-width: 940px){#nav.menu-open{width:30%}}#nav-left.menu-open-left{-webkit-transform:translateX(14rem);-moz-transform:translateX(14rem);-ms-transform:translateX(14rem);transform:translateX(14rem);width:100%;z-index:100}@media (min-width: 940px){#nav-left.menu-open-left{width:30%}}@media (max-width: 940px){#nav-links{display:none}}#nav-links a{padding-left:10px;color:#333;font-weight:300}#nav-list:after{display:block;content:'';width:5rem;height:1px;margin:23px auto;background-color:#333}#nav-menu{display:block;position:fixed;top:35px;right:25px;z-index:10;height:24px;z-index:500}@media (min-width: 940px){#nav-menu{display:none}}#nav-menu-left{display:block;position:fixed;top:35px;left:25px;z-index:10;height:24px;z-index:500}@media (min-width: 940px){#nav-menu-left{display:none}}#menu{height:4px;width:1.5em;background-color:#333;margin-top:8px}#menu:after,#menu:before{content:"";display:block;position:relative;height:4px;width:1.5em;background-color:#333;transition:all 0.3s ease-in}#menu:before{top:-8px}#menu:after{top:4px}#menu.btn-close{background:none}#menu.btn-close:before{top:0;-webkit-transform:rotate(-45deg);-moz-transform:rotate(-45deg);-ms-transform:rotate(-45deg);transform:rotate(-45deg);background-color:#333}#menu.btn-close:after{top:-4px;-webkit-transform:rotate(45deg);-moz-transform:rotate(45deg);-ms-transform:rotate(45deg);transform:rotate(45deg);background-color:#333}.fixed{position:fixed;width:100%}@media (min-width: 940px){.fixed{position:static}}#container{margin:0 auto}#header{border-bottom:1px solid rgba(0,0,0,0.14);text-align:center;margin-bottom:3em;height:5em;position:relative}#header a{text-decoration:none;display:inline-block}#header div{margin:0 auto}#header h1{font-size:2em;padding-bottom:0}#header h1 span{color:rgba(0,0,0,0.6);font-weight:300}#posts li{list-style-type:none}#post-page{margin-bottom:1.5em}@media (min-width: 940px){#post-page{margin-bottom:1.3334em}}.post+.post:before{display:block;content:'';width:5rem;height:1px;margin:23px auto;background-color:#e6e6e6}.by-line{display:block;color:#737373;line-height:1.8em;font-weight:200}@media (min-width: 940px){.by-line{display:block;color:#737373;line-height:1.8em;font-weight:200}}table,th,td{border:1px solid #dfe2e5;border-collapse:collapse;padding:6px 13px;padding-top:6px;padding-right:13px;padding-bottom:6px;padding-left:13px;margin-top:13px;margin-bottom:13px}.table-wrapper{overflow-x:auto;word-break:normal;word-break:keep-all}.MathJax_Display{overflow-x:auto;overflow-y:hidden}.post-info{margin-bottom:1.5em}.post-info>*{display:inline}img{max-width:100%;display:block;margin:0 auto;margin-bottom:24px;-webkit-border-radius:4px;-moz-border-radius:4px;-ms-border-radius:4px;border-radius:4px}img[title="Monochrome"]{box-shadow:0 2px 6px #ddd}code{color:#8c8c8c}.content ul,.content ol{line-height:1.8em;padding-left:1.5em}@media (min-width: 940px){.content ul,.content ol{line-height:1.8em}}#page ul,#page ol{padding-left:1.5em}.pagination{text-align:center;margin:2.666668em}.pagination span{background-color:#f2f2f2;color:#333}.pagination a:hover{background-color:#404040}.page-item{background-color:#4d4d4d;color:#fff;padding:4px 8px;font-weight:400;padding:0.5em 1em;-webkit-border-radius:4px;-moz-border-radius:4px;-ms-border-radius:4px;border-radius:4px}footer{background-color:#fff;color:#333;text-align:center;padding:0.6667em 0}pre{overflow:auto;word-wrap:normal;white-space:pre;margin-left:1em}.highlight .cm{color:#999988;font-style:italic}.highlight .cp{color:#999999;font-weight:bold}.highlight .c1{color:#999988;font-style:italic}.highlight .cs{color:#999999;font-weight:bold;font-style:italic}.highlight .c,.highlight .cd{color:#999988;font-style:italic}.highlight .err{color:#a61717;background-color:#e3d2d2}.highlight .gd{color:#000000;background-color:#ffdddd}.highlight .ge{color:#000000;font-style:italic}.highlight .gr{color:#aa0000}.highlight .gh{color:#999999}.highlight .gi{color:#000000;background-color:#ddffdd}.highlight .go{color:#888888}.highlight .gp{color:#555555}.highlight .gs{font-weight:bold}.highlight .gu{color:#aaaaaa}.highlight .gt{color:#aa0000}.highlight .kc{color:#000000;font-weight:bold}.highlight .kd{color:#000000;font-weight:bold}.highlight .kn{color:#000000;font-weight:bold}.highlight .kp{color:#000000;font-weight:bold}.highlight .kr{color:#d73a49}.highlight .kt{color:#005cc5}.highlight .k,.highlight .kv{color:#000000;font-weight:bold}.highlight .mf{color:#009999}.highlight .mh{color:#009999}.highlight .il{color:#009999}.highlight .mi{color:#005cc5}.highlight .mo{color:#009999}.highlight .m,.highlight .mb,.highlight .mx{color:#009999}.highlight .sb{color:#d14}.highlight .sc{color:#d14}.highlight .sd{color:#d14}.highlight .s2{color:#d14}.highlight .se{color:#d14}.highlight .sh{color:#d14}.highlight .si{color:#d14}.highlight .sx{color:#d14}.highlight .sr{color:#009926}.highlight .s1{color:#d14}.highlight .ss{color:#990073}.highlight .s{color:#032f62}.highlight .na{color:#008080}.highlight .bp{color:#999999}.highlight .nb{color:#0086B3}.highlight .nc{color:#445588;font-weight:bold}.highlight .no{color:#008080}.highlight .nd{color:#3c5d5d;font-weight:bold}.highlight .ni{color:#800080}.highlight .ne{color:#990000;font-weight:bold}.highlight .nf{color:#990000;font-weight:bold}.highlight .nl{color:#990000;font-weight:bold}.highlight .nn{color:#555555}.highlight .nt{color:#000080}.highlight .vc{color:#008080}.highlight .vg{color:#008080}.highlight .vi{color:#008080}.highlight .nv{color:#008080}.highlight .ow{color:#000000;font-weight:bold}.highlight .o{color:#d73a49}.highlight .w{color:#bbbbbb}.highlight{background-color:#f8f8f8}.dropdown{position:fixed;z-index:10;bottom:1%;right:5%}.dropdown .img{width:24px;height:24px}.dropdown-content{display:none;background-color:#f9f9f9;min-width:160px;box-shadow:0px 8px 16px 0px rgba(0,0,0,0.2);padding:12px 16px;z-index:1000;overflow:auto;max-height:80vh;overflow-x:hidden;overflow-y:auto}.dropdown-content ::-webkit-scrollbar{display:none}.dropdown-content ul>li>a{font-weight:700}.dropdown-content ul>li>ul>li>a{font-weight:500}#toc ul{list-style-type:none}#toc ul>li{margin-left:10px}#tipue_search_input,#tipue_search_foot_boxes{font:300 14px/1 Roboto, sans-serif}#tipue_search_results_count,#tipue_search_warning,.tipue_search_content_url,.tipue_search_content_debug,.tipue_search_related_text{font:300 14px/1.7 Roboto, sans-serif}.tipue_search_content_title{color:#000;font:100 26px/1.7 Roboto, sans-serif}.tipue_search_content_text,.tipue_search_related_title{font:300 15px/1.7 Roboto, sans-serif}.tipue_search_content_bold,.tipue_search_related_bold{font-weight:400}#tipue_search_input{color:#000;max-width:210px;padding:17px;border:1px solid rgba(0,0,0,0.6);border-radius:0;-moz-appearance:none;-webkit-appearance:none;box-shadow:none;outline:0;margin:0}.tipue_search_icon{width:24px;height:24px}.tipue_search_left{float:left;padding:15px 9px 0 0}.tipue_search_right{float:left}#tipue_search_content{max-width:750px;padding-top:15px;margin:0}#tipue_search_results_count{color:#000}#tipue_search_warning{color:#fff;margin:7px 0}#tipue_search_warning a{color:#5396ea;text-decoration:none}#tipue_search_warning a:hover{color:#555}.tipue_search_related_title{color:#fff;margin:26px 0 7px 0}.tipue_search_related_cols{-webkit-columns:230px 2;-moz-columns:230px 2;columns:230px 2}#tipue_search_foot{margin:51px 0 21px 0}#tipue_search_foot_boxes{padding:0;margin:0;cursor:pointer}#tipue_search_foot_boxes li{list-style:none;margin:0;padding:0;display:inline}#tipue_search_foot_boxes li a{padding:10px 17px 11px 17px;background-color:#fff;border:1px solid #e3e3e3;border-radius:1px;color:#333;margin-right:7px;text-decoration:none;text-align:center}#tipue_search_foot_boxes li.current{padding:10px 17px 11px 17px;background:#f6f6f6;border:1px solid #e3e3e3;border-radius:1px;color:#333;margin-right:7px;text-align:center}#tipue_search_foot_boxes li a:hover{background:#f6f6f6}

  </style>

	<!-- RSS -->
	<link href="/atom.xml" type="application/atom+xml" rel="alternate" title="ATOM Feed" />

  <!-- Favicon -->
  <link rel="shortcut icon" type="image/png" href="img/favicon.png">

</head>


<body>
	<div id="wrap">

	  	<!-- Navigation -->
	  	<nav id="nav">
	<div id="nav-list">
		<a href="/">Home</a>

		<!-- Nav pages -->
	  
	    
	  
	    
	      <a href="/about" title="About">About</a>
	    
	  
	    
	  
	    
	  
	    
	  
	    
	  
	    
	  
	    
	  
	    
	  
    
    <!-- Nav links -->
	  <a href="https://github.com/tpb1908/Notes">Project on Github</a>


	</div>
  
  <!-- Nav footer -->
	
	  <footer>
	
	<span>version 1.0.0</span>

</footer>
	

</nav>


    <!-- Icon menu -->
	  <a id="nav-menu">
	  	<div id="menu"></div>
	  </a>

      <!-- Header -->
      
        <header id="header" class="parent justify-spaceBetween">
  <div class="inner w100 relative">
    <span class="f-left">
      <a href="/">
        <h1>
          <span>Theo's</span> notes
        </h1>
      </a>
    </span>

    <span id="nav-links" class="absolute right bottom">
      <!-- Nav pages -->
	    
	      
	    
	      
	        <a href="/about" title="About">About</a>
	      
	    
	      
	    
	      
	    
	      
	    
	      
	    
	      
	    
	      
	    
	      
	    

      <!-- Nav links -->
	    <a href="https://github.com/tpb1908/Notes">Project on Github</a>


    </span>
  </div>

</header>

      

    <!-- Main content -->
	  <div id="container">

		<main>

			<article id="post-page">
	<h2>Test Post</h2>
	<div class="post-info">
		<time datetime="2017-08-12T00:00:00+01:00" class="by-line">12 Aug 2017</time>
		<span>&middot;</span>
		<p>
				<a href="tags#notes"> Notes </a>
			 
				<a href="tags#haskell"> Haskell </a>
			 
				<a href="tags#functional"> Functional </a>
			 
		</p>
	</div>

	<div class="content">

		<p>Not much here. A few lines of text.</p>

<h2 id="heading-level-2">Heading level 2</h2>

<p><strong>Bold</strong></p>

<div class="language-kotlin highlighter-rouge"><pre class="highlight"><code><span class="k">fun</span> <span class="nf">test</span><span class="p">():</span> <span class="n">Int</span> <span class="p">{</span>
  <span class="k">return</span> <span class="m">0</span>
<span class="p">}</span>
</code></pre>
</div>


	</div>

	<script type="text/javascript" async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
	</script>

	<div id="toc" class="dropdown">
		<img id="dropdown-button" src="/img/ic_toc.png"></img>
		<div id="toc-content" class="dropdown-content">
		</div>
	</div>

</article>


	  </main>

		  <!-- Pagination links -->
      

	  </div>

	    <!-- Footer -->
	    <footer>
  
<div class="search">
  <form action="/Test-Post" id="search_form">
    <div class="tipue_search_left"><img src="/js/tipuesearch/search.png" class="tipue_search_icon"></div>
    <div class="tipue_search_right "><input class="mdl-textfield__input"type="text" name="q" id="tipue_search_input" pattern=".{3,}" title="At least 3 characters" required></div>
    <div style="clear: both;"></div>
  </form>

  <div id="tipue_search_content"></div>
  
</div>

</footer>


	    <!-- Script -->
      <script>
    var normal = document.getElementById("nav-menu");
var reverse = document.getElementById("nav-menu-left");

var icon = normal !== null ? normal : reverse;

// Toggle the "menu-open" % "menu-opn-left" classes
function toggle() {
	  var navRight = document.getElementById("nav");
	  var navLeft = document.getElementById("nav-left");
	  var nav = navRight !== null ? navRight : navLeft;

	  var button = document.getElementById("menu");
	  var site = document.getElementById("wrap");
	  
	  if (nav.className == "menu-open" || nav.className == "menu-open-left") {
	  	  nav.className = "";
	  	  button.className = "";
	  	  site.className = "";
	  } else if (reverse !== null) {
	  	  nav.className += "menu-open-left";
	  	  button.className += "btn-close";
	  	  site.className += "fixed";
	  } else {
	  	  nav.className += "menu-open";
	  	  button.className += "btn-close";
	  	  site.className += "fixed";
	    }
	}

// Ensures backward compatibility with IE old versions
function menuClick() {
	if (document.addEventListener && icon !== null) {
		icon.addEventListener('click', toggle);
	} else if (document.attachEvent && icon !== null) {
		icon.attachEvent('onclick', toggle);
	} else {
		return;
	}
}

menuClick();
    /*! jQuery v3.2.1 | (c) JS Foundation and other contributors | jquery.org/license */
!function(a,b){"use strict";"object"==typeof module&&"object"==typeof module.exports?module.exports=a.document?b(a,!0):function(a){if(!a.document)throw new Error("jQuery requires a window with a document");return b(a)}:b(a)}("undefined"!=typeof window?window:this,function(a,b){"use strict";var c=[],d=a.document,e=Object.getPrototypeOf,f=c.slice,g=c.concat,h=c.push,i=c.indexOf,j={},k=j.toString,l=j.hasOwnProperty,m=l.toString,n=m.call(Object),o={};function p(a,b){b=b||d;var c=b.createElement("script");c.text=a,b.head.appendChild(c).parentNode.removeChild(c)}var q="3.2.1",r=function(a,b){return new r.fn.init(a,b)},s=/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g,t=/^-ms-/,u=/-([a-z])/g,v=function(a,b){return b.toUpperCase()};r.fn=r.prototype={jquery:q,constructor:r,length:0,toArray:function(){return f.call(this)},get:function(a){return null==a?f.call(this):a<0?this[a+this.length]:this[a]},pushStack:function(a){var b=r.merge(this.constructor(),a);return b.prevObject=this,b},each:function(a){return r.each(this,a)},map:function(a){return this.pushStack(r.map(this,function(b,c){return a.call(b,c,b)}))},slice:function(){return this.pushStack(f.apply(this,arguments))},first:function(){return this.eq(0)},last:function(){return this.eq(-1)},eq:function(a){var b=this.length,c=+a+(a<0?b:0);return this.pushStack(c>=0&&c<b?[this[c]]:[])},end:function(){return this.prevObject||this.constructor()},push:h,sort:c.sort,splice:c.splice},r.extend=r.fn.extend=function(){var a,b,c,d,e,f,g=arguments[0]||{},h=1,i=arguments.length,j=!1;for("boolean"==typeof g&&(j=g,g=arguments[h]||{},h++),"object"==typeof g||r.isFunction(g)||(g={}),h===i&&(g=this,h--);h<i;h++)if(null!=(a=arguments[h]))for(b in a)c=g[b],d=a[b],g!==d&&(j&&d&&(r.isPlainObject(d)||(e=Array.isArray(d)))?(e?(e=!1,f=c&&Array.isArray(c)?c:[]):f=c&&r.isPlainObject(c)?c:{},g[b]=r.extend(j,f,d)):void 0!==d&&(g[b]=d));return g},r.extend({expando:"jQuery"+(q+Math.random()).replace(/\D/g,""),isReady:!0,error:function(a){throw new Error(a)},noop:function(){},isFunction:function(a){return"function"===r.type(a)},isWindow:function(a){return null!=a&&a===a.window},isNumeric:function(a){var b=r.type(a);return("number"===b||"string"===b)&&!isNaN(a-parseFloat(a))},isPlainObject:function(a){var b,c;return!(!a||"[object Object]"!==k.call(a))&&(!(b=e(a))||(c=l.call(b,"constructor")&&b.constructor,"function"==typeof c&&m.call(c)===n))},isEmptyObject:function(a){var b;for(b in a)return!1;return!0},type:function(a){return null==a?a+"":"object"==typeof a||"function"==typeof a?j[k.call(a)]||"object":typeof a},globalEval:function(a){p(a)},camelCase:function(a){return a.replace(t,"ms-").replace(u,v)},each:function(a,b){var c,d=0;if(w(a)){for(c=a.length;d<c;d++)if(b.call(a[d],d,a[d])===!1)break}else for(d in a)if(b.call(a[d],d,a[d])===!1)break;return a},trim:function(a){return null==a?"":(a+"").replace(s,"")},makeArray:function(a,b){var c=b||[];return null!=a&&(w(Object(a))?r.merge(c,"string"==typeof a?[a]:a):h.call(c,a)),c},inArray:function(a,b,c){return null==b?-1:i.call(b,a,c)},merge:function(a,b){for(var c=+b.length,d=0,e=a.length;d<c;d++)a[e++]=b[d];return a.length=e,a},grep:function(a,b,c){for(var d,e=[],f=0,g=a.length,h=!c;f<g;f++)d=!b(a[f],f),d!==h&&e.push(a[f]);return e},map:function(a,b,c){var d,e,f=0,h=[];if(w(a))for(d=a.length;f<d;f++)e=b(a[f],f,c),null!=e&&h.push(e);else for(f in a)e=b(a[f],f,c),null!=e&&h.push(e);return g.apply([],h)},guid:1,proxy:function(a,b){var c,d,e;if("string"==typeof b&&(c=a[b],b=a,a=c),r.isFunction(a))return d=f.call(arguments,2),e=function(){return a.apply(b||this,d.concat(f.call(arguments)))},e.guid=a.guid=a.guid||r.guid++,e},now:Date.now,support:o}),"function"==typeof Symbol&&(r.fn[Symbol.iterator]=c[Symbol.iterator]),r.each("Boolean Number String Function Array Date RegExp Object Error Symbol".split(" "),function(a,b){j["[object "+b+"]"]=b.toLowerCase()});function w(a){var b=!!a&&"length"in a&&a.length,c=r.type(a);return"function"!==c&&!r.isWindow(a)&&("array"===c||0===b||"number"==typeof b&&b>0&&b-1 in a)}var x=function(a){var b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u="sizzle"+1*new Date,v=a.document,w=0,x=0,y=ha(),z=ha(),A=ha(),B=function(a,b){return a===b&&(l=!0),0},C={}.hasOwnProperty,D=[],E=D.pop,F=D.push,G=D.push,H=D.slice,I=function(a,b){for(var c=0,d=a.length;c<d;c++)if(a[c]===b)return c;return-1},J="checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|ismap|loop|multiple|open|readonly|required|scoped",K="[\\x20\\t\\r\\n\\f]",L="(?:\\\\.|[\\w-]|[^\0-\\xa0])+",M="\\["+K+"*("+L+")(?:"+K+"*([*^$|!~]?=)"+K+"*(?:'((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\"|("+L+"))|)"+K+"*\\]",N=":("+L+")(?:\\((('((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\")|((?:\\\\.|[^\\\\()[\\]]|"+M+")*)|.*)\\)|)",O=new RegExp(K+"+","g"),P=new RegExp("^"+K+"+|((?:^|[^\\\\])(?:\\\\.)*)"+K+"+$","g"),Q=new RegExp("^"+K+"*,"+K+"*"),R=new RegExp("^"+K+"*([>+~]|"+K+")"+K+"*"),S=new RegExp("="+K+"*([^\\]'\"]*?)"+K+"*\\]","g"),T=new RegExp(N),U=new RegExp("^"+L+"$"),V={ID:new RegExp("^#("+L+")"),CLASS:new RegExp("^\\.("+L+")"),TAG:new RegExp("^("+L+"|[*])"),ATTR:new RegExp("^"+M),PSEUDO:new RegExp("^"+N),CHILD:new RegExp("^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\("+K+"*(even|odd|(([+-]|)(\\d*)n|)"+K+"*(?:([+-]|)"+K+"*(\\d+)|))"+K+"*\\)|)","i"),bool:new RegExp("^(?:"+J+")$","i"),needsContext:new RegExp("^"+K+"*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\("+K+"*((?:-\\d)?\\d*)"+K+"*\\)|)(?=[^-]|$)","i")},W=/^(?:input|select|textarea|button)$/i,X=/^h\d$/i,Y=/^[^{]+\{\s*\[native \w/,Z=/^(?:#([\w-]+)|(\w+)|\.([\w-]+))$/,$=/[+~]/,_=new RegExp("\\\\([\\da-f]{1,6}"+K+"?|("+K+")|.)","ig"),aa=function(a,b,c){var d="0x"+b-65536;return d!==d||c?b:d<0?String.fromCharCode(d+65536):String.fromCharCode(d>>10|55296,1023&d|56320)},ba=/([\0-\x1f\x7f]|^-?\d)|^-$|[^\0-\x1f\x7f-\uFFFF\w-]/g,ca=function(a,b){return b?"\0"===a?"\ufffd":a.slice(0,-1)+"\\"+a.charCodeAt(a.length-1).toString(16)+" ":"\\"+a},da=function(){m()},ea=ta(function(a){return a.disabled===!0&&("form"in a||"label"in a)},{dir:"parentNode",next:"legend"});try{G.apply(D=H.call(v.childNodes),v.childNodes),D[v.childNodes.length].nodeType}catch(fa){G={apply:D.length?function(a,b){F.apply(a,H.call(b))}:function(a,b){var c=a.length,d=0;while(a[c++]=b[d++]);a.length=c-1}}}function ga(a,b,d,e){var f,h,j,k,l,o,r,s=b&&b.ownerDocument,w=b?b.nodeType:9;if(d=d||[],"string"!=typeof a||!a||1!==w&&9!==w&&11!==w)return d;if(!e&&((b?b.ownerDocument||b:v)!==n&&m(b),b=b||n,p)){if(11!==w&&(l=Z.exec(a)))if(f=l[1]){if(9===w){if(!(j=b.getElementById(f)))return d;if(j.id===f)return d.push(j),d}else if(s&&(j=s.getElementById(f))&&t(b,j)&&j.id===f)return d.push(j),d}else{if(l[2])return G.apply(d,b.getElementsByTagName(a)),d;if((f=l[3])&&c.getElementsByClassName&&b.getElementsByClassName)return G.apply(d,b.getElementsByClassName(f)),d}if(c.qsa&&!A[a+" "]&&(!q||!q.test(a))){if(1!==w)s=b,r=a;else if("object"!==b.nodeName.toLowerCase()){(k=b.getAttribute("id"))?k=k.replace(ba,ca):b.setAttribute("id",k=u),o=g(a),h=o.length;while(h--)o[h]="#"+k+" "+sa(o[h]);r=o.join(","),s=$.test(a)&&qa(b.parentNode)||b}if(r)try{return G.apply(d,s.querySelectorAll(r)),d}catch(x){}finally{k===u&&b.removeAttribute("id")}}}return i(a.replace(P,"$1"),b,d,e)}function ha(){var a=[];function b(c,e){return a.push(c+" ")>d.cacheLength&&delete b[a.shift()],b[c+" "]=e}return b}function ia(a){return a[u]=!0,a}function ja(a){var b=n.createElement("fieldset");try{return!!a(b)}catch(c){return!1}finally{b.parentNode&&b.parentNode.removeChild(b),b=null}}function ka(a,b){var c=a.split("|"),e=c.length;while(e--)d.attrHandle[c[e]]=b}function la(a,b){var c=b&&a,d=c&&1===a.nodeType&&1===b.nodeType&&a.sourceIndex-b.sourceIndex;if(d)return d;if(c)while(c=c.nextSibling)if(c===b)return-1;return a?1:-1}function ma(a){return function(b){var c=b.nodeName.toLowerCase();return"input"===c&&b.type===a}}function na(a){return function(b){var c=b.nodeName.toLowerCase();return("input"===c||"button"===c)&&b.type===a}}function oa(a){return function(b){return"form"in b?b.parentNode&&b.disabled===!1?"label"in b?"label"in b.parentNode?b.parentNode.disabled===a:b.disabled===a:b.isDisabled===a||b.isDisabled!==!a&&ea(b)===a:b.disabled===a:"label"in b&&b.disabled===a}}function pa(a){return ia(function(b){return b=+b,ia(function(c,d){var e,f=a([],c.length,b),g=f.length;while(g--)c[e=f[g]]&&(c[e]=!(d[e]=c[e]))})})}function qa(a){return a&&"undefined"!=typeof a.getElementsByTagName&&a}c=ga.support={},f=ga.isXML=function(a){var b=a&&(a.ownerDocument||a).documentElement;return!!b&&"HTML"!==b.nodeName},m=ga.setDocument=function(a){var b,e,g=a?a.ownerDocument||a:v;return g!==n&&9===g.nodeType&&g.documentElement?(n=g,o=n.documentElement,p=!f(n),v!==n&&(e=n.defaultView)&&e.top!==e&&(e.addEventListener?e.addEventListener("unload",da,!1):e.attachEvent&&e.attachEvent("onunload",da)),c.attributes=ja(function(a){return a.className="i",!a.getAttribute("className")}),c.getElementsByTagName=ja(function(a){return a.appendChild(n.createComment("")),!a.getElementsByTagName("*").length}),c.getElementsByClassName=Y.test(n.getElementsByClassName),c.getById=ja(function(a){return o.appendChild(a).id=u,!n.getElementsByName||!n.getElementsByName(u).length}),c.getById?(d.filter.ID=function(a){var b=a.replace(_,aa);return function(a){return a.getAttribute("id")===b}},d.find.ID=function(a,b){if("undefined"!=typeof b.getElementById&&p){var c=b.getElementById(a);return c?[c]:[]}}):(d.filter.ID=function(a){var b=a.replace(_,aa);return function(a){var c="undefined"!=typeof a.getAttributeNode&&a.getAttributeNode("id");return c&&c.value===b}},d.find.ID=function(a,b){if("undefined"!=typeof b.getElementById&&p){var c,d,e,f=b.getElementById(a);if(f){if(c=f.getAttributeNode("id"),c&&c.value===a)return[f];e=b.getElementsByName(a),d=0;while(f=e[d++])if(c=f.getAttributeNode("id"),c&&c.value===a)return[f]}return[]}}),d.find.TAG=c.getElementsByTagName?function(a,b){return"undefined"!=typeof b.getElementsByTagName?b.getElementsByTagName(a):c.qsa?b.querySelectorAll(a):void 0}:function(a,b){var c,d=[],e=0,f=b.getElementsByTagName(a);if("*"===a){while(c=f[e++])1===c.nodeType&&d.push(c);return d}return f},d.find.CLASS=c.getElementsByClassName&&function(a,b){if("undefined"!=typeof b.getElementsByClassName&&p)return b.getElementsByClassName(a)},r=[],q=[],(c.qsa=Y.test(n.querySelectorAll))&&(ja(function(a){o.appendChild(a).innerHTML="<a id='"+u+"'></a><select id='"+u+"-\r\\' msallowcapture=''><option selected=''></option></select>",a.querySelectorAll("[msallowcapture^='']").length&&q.push("[*^$]="+K+"*(?:''|\"\")"),a.querySelectorAll("[selected]").length||q.push("\\["+K+"*(?:value|"+J+")"),a.querySelectorAll("[id~="+u+"-]").length||q.push("~="),a.querySelectorAll(":checked").length||q.push(":checked"),a.querySelectorAll("a#"+u+"+*").length||q.push(".#.+[+~]")}),ja(function(a){a.innerHTML="<a href='' disabled='disabled'></a><select disabled='disabled'><option/></select>";var b=n.createElement("input");b.setAttribute("type","hidden"),a.appendChild(b).setAttribute("name","D"),a.querySelectorAll("[name=d]").length&&q.push("name"+K+"*[*^$|!~]?="),2!==a.querySelectorAll(":enabled").length&&q.push(":enabled",":disabled"),o.appendChild(a).disabled=!0,2!==a.querySelectorAll(":disabled").length&&q.push(":enabled",":disabled"),a.querySelectorAll("*,:x"),q.push(",.*:")})),(c.matchesSelector=Y.test(s=o.matches||o.webkitMatchesSelector||o.mozMatchesSelector||o.oMatchesSelector||o.msMatchesSelector))&&ja(function(a){c.disconnectedMatch=s.call(a,"*"),s.call(a,"[s!='']:x"),r.push("!=",N)}),q=q.length&&new RegExp(q.join("|")),r=r.length&&new RegExp(r.join("|")),b=Y.test(o.compareDocumentPosition),t=b||Y.test(o.contains)?function(a,b){var c=9===a.nodeType?a.documentElement:a,d=b&&b.parentNode;return a===d||!(!d||1!==d.nodeType||!(c.contains?c.contains(d):a.compareDocumentPosition&&16&a.compareDocumentPosition(d)))}:function(a,b){if(b)while(b=b.parentNode)if(b===a)return!0;return!1},B=b?function(a,b){if(a===b)return l=!0,0;var d=!a.compareDocumentPosition-!b.compareDocumentPosition;return d?d:(d=(a.ownerDocument||a)===(b.ownerDocument||b)?a.compareDocumentPosition(b):1,1&d||!c.sortDetached&&b.compareDocumentPosition(a)===d?a===n||a.ownerDocument===v&&t(v,a)?-1:b===n||b.ownerDocument===v&&t(v,b)?1:k?I(k,a)-I(k,b):0:4&d?-1:1)}:function(a,b){if(a===b)return l=!0,0;var c,d=0,e=a.parentNode,f=b.parentNode,g=[a],h=[b];if(!e||!f)return a===n?-1:b===n?1:e?-1:f?1:k?I(k,a)-I(k,b):0;if(e===f)return la(a,b);c=a;while(c=c.parentNode)g.unshift(c);c=b;while(c=c.parentNode)h.unshift(c);while(g[d]===h[d])d++;return d?la(g[d],h[d]):g[d]===v?-1:h[d]===v?1:0},n):n},ga.matches=function(a,b){return ga(a,null,null,b)},ga.matchesSelector=function(a,b){if((a.ownerDocument||a)!==n&&m(a),b=b.replace(S,"='$1']"),c.matchesSelector&&p&&!A[b+" "]&&(!r||!r.test(b))&&(!q||!q.test(b)))try{var d=s.call(a,b);if(d||c.disconnectedMatch||a.document&&11!==a.document.nodeType)return d}catch(e){}return ga(b,n,null,[a]).length>0},ga.contains=function(a,b){return(a.ownerDocument||a)!==n&&m(a),t(a,b)},ga.attr=function(a,b){(a.ownerDocument||a)!==n&&m(a);var e=d.attrHandle[b.toLowerCase()],f=e&&C.call(d.attrHandle,b.toLowerCase())?e(a,b,!p):void 0;return void 0!==f?f:c.attributes||!p?a.getAttribute(b):(f=a.getAttributeNode(b))&&f.specified?f.value:null},ga.escape=function(a){return(a+"").replace(ba,ca)},ga.error=function(a){throw new Error("Syntax error, unrecognized expression: "+a)},ga.uniqueSort=function(a){var b,d=[],e=0,f=0;if(l=!c.detectDuplicates,k=!c.sortStable&&a.slice(0),a.sort(B),l){while(b=a[f++])b===a[f]&&(e=d.push(f));while(e--)a.splice(d[e],1)}return k=null,a},e=ga.getText=function(a){var b,c="",d=0,f=a.nodeType;if(f){if(1===f||9===f||11===f){if("string"==typeof a.textContent)return a.textContent;for(a=a.firstChild;a;a=a.nextSibling)c+=e(a)}else if(3===f||4===f)return a.nodeValue}else while(b=a[d++])c+=e(b);return c},d=ga.selectors={cacheLength:50,createPseudo:ia,match:V,attrHandle:{},find:{},relative:{">":{dir:"parentNode",first:!0}," ":{dir:"parentNode"},"+":{dir:"previousSibling",first:!0},"~":{dir:"previousSibling"}},preFilter:{ATTR:function(a){return a[1]=a[1].replace(_,aa),a[3]=(a[3]||a[4]||a[5]||"").replace(_,aa),"~="===a[2]&&(a[3]=" "+a[3]+" "),a.slice(0,4)},CHILD:function(a){return a[1]=a[1].toLowerCase(),"nth"===a[1].slice(0,3)?(a[3]||ga.error(a[0]),a[4]=+(a[4]?a[5]+(a[6]||1):2*("even"===a[3]||"odd"===a[3])),a[5]=+(a[7]+a[8]||"odd"===a[3])):a[3]&&ga.error(a[0]),a},PSEUDO:function(a){var b,c=!a[6]&&a[2];return V.CHILD.test(a[0])?null:(a[3]?a[2]=a[4]||a[5]||"":c&&T.test(c)&&(b=g(c,!0))&&(b=c.indexOf(")",c.length-b)-c.length)&&(a[0]=a[0].slice(0,b),a[2]=c.slice(0,b)),a.slice(0,3))}},filter:{TAG:function(a){var b=a.replace(_,aa).toLowerCase();return"*"===a?function(){return!0}:function(a){return a.nodeName&&a.nodeName.toLowerCase()===b}},CLASS:function(a){var b=y[a+" "];return b||(b=new RegExp("(^|"+K+")"+a+"("+K+"|$)"))&&y(a,function(a){return b.test("string"==typeof a.className&&a.className||"undefined"!=typeof a.getAttribute&&a.getAttribute("class")||"")})},ATTR:function(a,b,c){return function(d){var e=ga.attr(d,a);return null==e?"!="===b:!b||(e+="","="===b?e===c:"!="===b?e!==c:"^="===b?c&&0===e.indexOf(c):"*="===b?c&&e.indexOf(c)>-1:"$="===b?c&&e.slice(-c.length)===c:"~="===b?(" "+e.replace(O," ")+" ").indexOf(c)>-1:"|="===b&&(e===c||e.slice(0,c.length+1)===c+"-"))}},CHILD:function(a,b,c,d,e){var f="nth"!==a.slice(0,3),g="last"!==a.slice(-4),h="of-type"===b;return 1===d&&0===e?function(a){return!!a.parentNode}:function(b,c,i){var j,k,l,m,n,o,p=f!==g?"nextSibling":"previousSibling",q=b.parentNode,r=h&&b.nodeName.toLowerCase(),s=!i&&!h,t=!1;if(q){if(f){while(p){m=b;while(m=m[p])if(h?m.nodeName.toLowerCase()===r:1===m.nodeType)return!1;o=p="only"===a&&!o&&"nextSibling"}return!0}if(o=[g?q.firstChild:q.lastChild],g&&s){m=q,l=m[u]||(m[u]={}),k=l[m.uniqueID]||(l[m.uniqueID]={}),j=k[a]||[],n=j[0]===w&&j[1],t=n&&j[2],m=n&&q.childNodes[n];while(m=++n&&m&&m[p]||(t=n=0)||o.pop())if(1===m.nodeType&&++t&&m===b){k[a]=[w,n,t];break}}else if(s&&(m=b,l=m[u]||(m[u]={}),k=l[m.uniqueID]||(l[m.uniqueID]={}),j=k[a]||[],n=j[0]===w&&j[1],t=n),t===!1)while(m=++n&&m&&m[p]||(t=n=0)||o.pop())if((h?m.nodeName.toLowerCase()===r:1===m.nodeType)&&++t&&(s&&(l=m[u]||(m[u]={}),k=l[m.uniqueID]||(l[m.uniqueID]={}),k[a]=[w,t]),m===b))break;return t-=e,t===d||t%d===0&&t/d>=0}}},PSEUDO:function(a,b){var c,e=d.pseudos[a]||d.setFilters[a.toLowerCase()]||ga.error("unsupported pseudo: "+a);return e[u]?e(b):e.length>1?(c=[a,a,"",b],d.setFilters.hasOwnProperty(a.toLowerCase())?ia(function(a,c){var d,f=e(a,b),g=f.length;while(g--)d=I(a,f[g]),a[d]=!(c[d]=f[g])}):function(a){return e(a,0,c)}):e}},pseudos:{not:ia(function(a){var b=[],c=[],d=h(a.replace(P,"$1"));return d[u]?ia(function(a,b,c,e){var f,g=d(a,null,e,[]),h=a.length;while(h--)(f=g[h])&&(a[h]=!(b[h]=f))}):function(a,e,f){return b[0]=a,d(b,null,f,c),b[0]=null,!c.pop()}}),has:ia(function(a){return function(b){return ga(a,b).length>0}}),contains:ia(function(a){return a=a.replace(_,aa),function(b){return(b.textContent||b.innerText||e(b)).indexOf(a)>-1}}),lang:ia(function(a){return U.test(a||"")||ga.error("unsupported lang: "+a),a=a.replace(_,aa).toLowerCase(),function(b){var c;do if(c=p?b.lang:b.getAttribute("xml:lang")||b.getAttribute("lang"))return c=c.toLowerCase(),c===a||0===c.indexOf(a+"-");while((b=b.parentNode)&&1===b.nodeType);return!1}}),target:function(b){var c=a.location&&a.location.hash;return c&&c.slice(1)===b.id},root:function(a){return a===o},focus:function(a){return a===n.activeElement&&(!n.hasFocus||n.hasFocus())&&!!(a.type||a.href||~a.tabIndex)},enabled:oa(!1),disabled:oa(!0),checked:function(a){var b=a.nodeName.toLowerCase();return"input"===b&&!!a.checked||"option"===b&&!!a.selected},selected:function(a){return a.parentNode&&a.parentNode.selectedIndex,a.selected===!0},empty:function(a){for(a=a.firstChild;a;a=a.nextSibling)if(a.nodeType<6)return!1;return!0},parent:function(a){return!d.pseudos.empty(a)},header:function(a){return X.test(a.nodeName)},input:function(a){return W.test(a.nodeName)},button:function(a){var b=a.nodeName.toLowerCase();return"input"===b&&"button"===a.type||"button"===b},text:function(a){var b;return"input"===a.nodeName.toLowerCase()&&"text"===a.type&&(null==(b=a.getAttribute("type"))||"text"===b.toLowerCase())},first:pa(function(){return[0]}),last:pa(function(a,b){return[b-1]}),eq:pa(function(a,b,c){return[c<0?c+b:c]}),even:pa(function(a,b){for(var c=0;c<b;c+=2)a.push(c);return a}),odd:pa(function(a,b){for(var c=1;c<b;c+=2)a.push(c);return a}),lt:pa(function(a,b,c){for(var d=c<0?c+b:c;--d>=0;)a.push(d);return a}),gt:pa(function(a,b,c){for(var d=c<0?c+b:c;++d<b;)a.push(d);return a})}},d.pseudos.nth=d.pseudos.eq;for(b in{radio:!0,checkbox:!0,file:!0,password:!0,image:!0})d.pseudos[b]=ma(b);for(b in{submit:!0,reset:!0})d.pseudos[b]=na(b);function ra(){}ra.prototype=d.filters=d.pseudos,d.setFilters=new ra,g=ga.tokenize=function(a,b){var c,e,f,g,h,i,j,k=z[a+" "];if(k)return b?0:k.slice(0);h=a,i=[],j=d.preFilter;while(h){c&&!(e=Q.exec(h))||(e&&(h=h.slice(e[0].length)||h),i.push(f=[])),c=!1,(e=R.exec(h))&&(c=e.shift(),f.push({value:c,type:e[0].replace(P," ")}),h=h.slice(c.length));for(g in d.filter)!(e=V[g].exec(h))||j[g]&&!(e=j[g](e))||(c=e.shift(),f.push({value:c,type:g,matches:e}),h=h.slice(c.length));if(!c)break}return b?h.length:h?ga.error(a):z(a,i).slice(0)};function sa(a){for(var b=0,c=a.length,d="";b<c;b++)d+=a[b].value;return d}function ta(a,b,c){var d=b.dir,e=b.next,f=e||d,g=c&&"parentNode"===f,h=x++;return b.first?function(b,c,e){while(b=b[d])if(1===b.nodeType||g)return a(b,c,e);return!1}:function(b,c,i){var j,k,l,m=[w,h];if(i){while(b=b[d])if((1===b.nodeType||g)&&a(b,c,i))return!0}else while(b=b[d])if(1===b.nodeType||g)if(l=b[u]||(b[u]={}),k=l[b.uniqueID]||(l[b.uniqueID]={}),e&&e===b.nodeName.toLowerCase())b=b[d]||b;else{if((j=k[f])&&j[0]===w&&j[1]===h)return m[2]=j[2];if(k[f]=m,m[2]=a(b,c,i))return!0}return!1}}function ua(a){return a.length>1?function(b,c,d){var e=a.length;while(e--)if(!a[e](b,c,d))return!1;return!0}:a[0]}function va(a,b,c){for(var d=0,e=b.length;d<e;d++)ga(a,b[d],c);return c}function wa(a,b,c,d,e){for(var f,g=[],h=0,i=a.length,j=null!=b;h<i;h++)(f=a[h])&&(c&&!c(f,d,e)||(g.push(f),j&&b.push(h)));return g}function xa(a,b,c,d,e,f){return d&&!d[u]&&(d=xa(d)),e&&!e[u]&&(e=xa(e,f)),ia(function(f,g,h,i){var j,k,l,m=[],n=[],o=g.length,p=f||va(b||"*",h.nodeType?[h]:h,[]),q=!a||!f&&b?p:wa(p,m,a,h,i),r=c?e||(f?a:o||d)?[]:g:q;if(c&&c(q,r,h,i),d){j=wa(r,n),d(j,[],h,i),k=j.length;while(k--)(l=j[k])&&(r[n[k]]=!(q[n[k]]=l))}if(f){if(e||a){if(e){j=[],k=r.length;while(k--)(l=r[k])&&j.push(q[k]=l);e(null,r=[],j,i)}k=r.length;while(k--)(l=r[k])&&(j=e?I(f,l):m[k])>-1&&(f[j]=!(g[j]=l))}}else r=wa(r===g?r.splice(o,r.length):r),e?e(null,g,r,i):G.apply(g,r)})}function ya(a){for(var b,c,e,f=a.length,g=d.relative[a[0].type],h=g||d.relative[" "],i=g?1:0,k=ta(function(a){return a===b},h,!0),l=ta(function(a){return I(b,a)>-1},h,!0),m=[function(a,c,d){var e=!g&&(d||c!==j)||((b=c).nodeType?k(a,c,d):l(a,c,d));return b=null,e}];i<f;i++)if(c=d.relative[a[i].type])m=[ta(ua(m),c)];else{if(c=d.filter[a[i].type].apply(null,a[i].matches),c[u]){for(e=++i;e<f;e++)if(d.relative[a[e].type])break;return xa(i>1&&ua(m),i>1&&sa(a.slice(0,i-1).concat({value:" "===a[i-2].type?"*":""})).replace(P,"$1"),c,i<e&&ya(a.slice(i,e)),e<f&&ya(a=a.slice(e)),e<f&&sa(a))}m.push(c)}return ua(m)}function za(a,b){var c=b.length>0,e=a.length>0,f=function(f,g,h,i,k){var l,o,q,r=0,s="0",t=f&&[],u=[],v=j,x=f||e&&d.find.TAG("*",k),y=w+=null==v?1:Math.random()||.1,z=x.length;for(k&&(j=g===n||g||k);s!==z&&null!=(l=x[s]);s++){if(e&&l){o=0,g||l.ownerDocument===n||(m(l),h=!p);while(q=a[o++])if(q(l,g||n,h)){i.push(l);break}k&&(w=y)}c&&((l=!q&&l)&&r--,f&&t.push(l))}if(r+=s,c&&s!==r){o=0;while(q=b[o++])q(t,u,g,h);if(f){if(r>0)while(s--)t[s]||u[s]||(u[s]=E.call(i));u=wa(u)}G.apply(i,u),k&&!f&&u.length>0&&r+b.length>1&&ga.uniqueSort(i)}return k&&(w=y,j=v),t};return c?ia(f):f}return h=ga.compile=function(a,b){var c,d=[],e=[],f=A[a+" "];if(!f){b||(b=g(a)),c=b.length;while(c--)f=ya(b[c]),f[u]?d.push(f):e.push(f);f=A(a,za(e,d)),f.selector=a}return f},i=ga.select=function(a,b,c,e){var f,i,j,k,l,m="function"==typeof a&&a,n=!e&&g(a=m.selector||a);if(c=c||[],1===n.length){if(i=n[0]=n[0].slice(0),i.length>2&&"ID"===(j=i[0]).type&&9===b.nodeType&&p&&d.relative[i[1].type]){if(b=(d.find.ID(j.matches[0].replace(_,aa),b)||[])[0],!b)return c;m&&(b=b.parentNode),a=a.slice(i.shift().value.length)}f=V.needsContext.test(a)?0:i.length;while(f--){if(j=i[f],d.relative[k=j.type])break;if((l=d.find[k])&&(e=l(j.matches[0].replace(_,aa),$.test(i[0].type)&&qa(b.parentNode)||b))){if(i.splice(f,1),a=e.length&&sa(i),!a)return G.apply(c,e),c;break}}}return(m||h(a,n))(e,b,!p,c,!b||$.test(a)&&qa(b.parentNode)||b),c},c.sortStable=u.split("").sort(B).join("")===u,c.detectDuplicates=!!l,m(),c.sortDetached=ja(function(a){return 1&a.compareDocumentPosition(n.createElement("fieldset"))}),ja(function(a){return a.innerHTML="<a href='#'></a>","#"===a.firstChild.getAttribute("href")})||ka("type|href|height|width",function(a,b,c){if(!c)return a.getAttribute(b,"type"===b.toLowerCase()?1:2)}),c.attributes&&ja(function(a){return a.innerHTML="<input/>",a.firstChild.setAttribute("value",""),""===a.firstChild.getAttribute("value")})||ka("value",function(a,b,c){if(!c&&"input"===a.nodeName.toLowerCase())return a.defaultValue}),ja(function(a){return null==a.getAttribute("disabled")})||ka(J,function(a,b,c){var d;if(!c)return a[b]===!0?b.toLowerCase():(d=a.getAttributeNode(b))&&d.specified?d.value:null}),ga}(a);r.find=x,r.expr=x.selectors,r.expr[":"]=r.expr.pseudos,r.uniqueSort=r.unique=x.uniqueSort,r.text=x.getText,r.isXMLDoc=x.isXML,r.contains=x.contains,r.escapeSelector=x.escape;var y=function(a,b,c){var d=[],e=void 0!==c;while((a=a[b])&&9!==a.nodeType)if(1===a.nodeType){if(e&&r(a).is(c))break;d.push(a)}return d},z=function(a,b){for(var c=[];a;a=a.nextSibling)1===a.nodeType&&a!==b&&c.push(a);return c},A=r.expr.match.needsContext;function B(a,b){return a.nodeName&&a.nodeName.toLowerCase()===b.toLowerCase()}var C=/^<([a-z][^\/\0>:\x20\t\r\n\f]*)[\x20\t\r\n\f]*\/?>(?:<\/\1>|)$/i,D=/^.[^:#\[\.,]*$/;function E(a,b,c){return r.isFunction(b)?r.grep(a,function(a,d){return!!b.call(a,d,a)!==c}):b.nodeType?r.grep(a,function(a){return a===b!==c}):"string"!=typeof b?r.grep(a,function(a){return i.call(b,a)>-1!==c}):D.test(b)?r.filter(b,a,c):(b=r.filter(b,a),r.grep(a,function(a){return i.call(b,a)>-1!==c&&1===a.nodeType}))}r.filter=function(a,b,c){var d=b[0];return c&&(a=":not("+a+")"),1===b.length&&1===d.nodeType?r.find.matchesSelector(d,a)?[d]:[]:r.find.matches(a,r.grep(b,function(a){return 1===a.nodeType}))},r.fn.extend({find:function(a){var b,c,d=this.length,e=this;if("string"!=typeof a)return this.pushStack(r(a).filter(function(){for(b=0;b<d;b++)if(r.contains(e[b],this))return!0}));for(c=this.pushStack([]),b=0;b<d;b++)r.find(a,e[b],c);return d>1?r.uniqueSort(c):c},filter:function(a){return this.pushStack(E(this,a||[],!1))},not:function(a){return this.pushStack(E(this,a||[],!0))},is:function(a){return!!E(this,"string"==typeof a&&A.test(a)?r(a):a||[],!1).length}});var F,G=/^(?:\s*(<[\w\W]+>)[^>]*|#([\w-]+))$/,H=r.fn.init=function(a,b,c){var e,f;if(!a)return this;if(c=c||F,"string"==typeof a){if(e="<"===a[0]&&">"===a[a.length-1]&&a.length>=3?[null,a,null]:G.exec(a),!e||!e[1]&&b)return!b||b.jquery?(b||c).find(a):this.constructor(b).find(a);if(e[1]){if(b=b instanceof r?b[0]:b,r.merge(this,r.parseHTML(e[1],b&&b.nodeType?b.ownerDocument||b:d,!0)),C.test(e[1])&&r.isPlainObject(b))for(e in b)r.isFunction(this[e])?this[e](b[e]):this.attr(e,b[e]);return this}return f=d.getElementById(e[2]),f&&(this[0]=f,this.length=1),this}return a.nodeType?(this[0]=a,this.length=1,this):r.isFunction(a)?void 0!==c.ready?c.ready(a):a(r):r.makeArray(a,this)};H.prototype=r.fn,F=r(d);var I=/^(?:parents|prev(?:Until|All))/,J={children:!0,contents:!0,next:!0,prev:!0};r.fn.extend({has:function(a){var b=r(a,this),c=b.length;return this.filter(function(){for(var a=0;a<c;a++)if(r.contains(this,b[a]))return!0})},closest:function(a,b){var c,d=0,e=this.length,f=[],g="string"!=typeof a&&r(a);if(!A.test(a))for(;d<e;d++)for(c=this[d];c&&c!==b;c=c.parentNode)if(c.nodeType<11&&(g?g.index(c)>-1:1===c.nodeType&&r.find.matchesSelector(c,a))){f.push(c);break}return this.pushStack(f.length>1?r.uniqueSort(f):f)},index:function(a){return a?"string"==typeof a?i.call(r(a),this[0]):i.call(this,a.jquery?a[0]:a):this[0]&&this[0].parentNode?this.first().prevAll().length:-1},add:function(a,b){return this.pushStack(r.uniqueSort(r.merge(this.get(),r(a,b))))},addBack:function(a){return this.add(null==a?this.prevObject:this.prevObject.filter(a))}});function K(a,b){while((a=a[b])&&1!==a.nodeType);return a}r.each({parent:function(a){var b=a.parentNode;return b&&11!==b.nodeType?b:null},parents:function(a){return y(a,"parentNode")},parentsUntil:function(a,b,c){return y(a,"parentNode",c)},next:function(a){return K(a,"nextSibling")},prev:function(a){return K(a,"previousSibling")},nextAll:function(a){return y(a,"nextSibling")},prevAll:function(a){return y(a,"previousSibling")},nextUntil:function(a,b,c){return y(a,"nextSibling",c)},prevUntil:function(a,b,c){return y(a,"previousSibling",c)},siblings:function(a){return z((a.parentNode||{}).firstChild,a)},children:function(a){return z(a.firstChild)},contents:function(a){return B(a,"iframe")?a.contentDocument:(B(a,"template")&&(a=a.content||a),r.merge([],a.childNodes))}},function(a,b){r.fn[a]=function(c,d){var e=r.map(this,b,c);return"Until"!==a.slice(-5)&&(d=c),d&&"string"==typeof d&&(e=r.filter(d,e)),this.length>1&&(J[a]||r.uniqueSort(e),I.test(a)&&e.reverse()),this.pushStack(e)}});var L=/[^\x20\t\r\n\f]+/g;function M(a){var b={};return r.each(a.match(L)||[],function(a,c){b[c]=!0}),b}r.Callbacks=function(a){a="string"==typeof a?M(a):r.extend({},a);var b,c,d,e,f=[],g=[],h=-1,i=function(){for(e=e||a.once,d=b=!0;g.length;h=-1){c=g.shift();while(++h<f.length)f[h].apply(c[0],c[1])===!1&&a.stopOnFalse&&(h=f.length,c=!1)}a.memory||(c=!1),b=!1,e&&(f=c?[]:"")},j={add:function(){return f&&(c&&!b&&(h=f.length-1,g.push(c)),function d(b){r.each(b,function(b,c){r.isFunction(c)?a.unique&&j.has(c)||f.push(c):c&&c.length&&"string"!==r.type(c)&&d(c)})}(arguments),c&&!b&&i()),this},remove:function(){return r.each(arguments,function(a,b){var c;while((c=r.inArray(b,f,c))>-1)f.splice(c,1),c<=h&&h--}),this},has:function(a){return a?r.inArray(a,f)>-1:f.length>0},empty:function(){return f&&(f=[]),this},disable:function(){return e=g=[],f=c="",this},disabled:function(){return!f},lock:function(){return e=g=[],c||b||(f=c=""),this},locked:function(){return!!e},fireWith:function(a,c){return e||(c=c||[],c=[a,c.slice?c.slice():c],g.push(c),b||i()),this},fire:function(){return j.fireWith(this,arguments),this},fired:function(){return!!d}};return j};function N(a){return a}function O(a){throw a}function P(a,b,c,d){var e;try{a&&r.isFunction(e=a.promise)?e.call(a).done(b).fail(c):a&&r.isFunction(e=a.then)?e.call(a,b,c):b.apply(void 0,[a].slice(d))}catch(a){c.apply(void 0,[a])}}r.extend({Deferred:function(b){var c=[["notify","progress",r.Callbacks("memory"),r.Callbacks("memory"),2],["resolve","done",r.Callbacks("once memory"),r.Callbacks("once memory"),0,"resolved"],["reject","fail",r.Callbacks("once memory"),r.Callbacks("once memory"),1,"rejected"]],d="pending",e={state:function(){return d},always:function(){return f.done(arguments).fail(arguments),this},"catch":function(a){return e.then(null,a)},pipe:function(){var a=arguments;return r.Deferred(function(b){r.each(c,function(c,d){var e=r.isFunction(a[d[4]])&&a[d[4]];f[d[1]](function(){var a=e&&e.apply(this,arguments);a&&r.isFunction(a.promise)?a.promise().progress(b.notify).done(b.resolve).fail(b.reject):b[d[0]+"With"](this,e?[a]:arguments)})}),a=null}).promise()},then:function(b,d,e){var f=0;function g(b,c,d,e){return function(){var h=this,i=arguments,j=function(){var a,j;if(!(b<f)){if(a=d.apply(h,i),a===c.promise())throw new TypeError("Thenable self-resolution");j=a&&("object"==typeof a||"function"==typeof a)&&a.then,r.isFunction(j)?e?j.call(a,g(f,c,N,e),g(f,c,O,e)):(f++,j.call(a,g(f,c,N,e),g(f,c,O,e),g(f,c,N,c.notifyWith))):(d!==N&&(h=void 0,i=[a]),(e||c.resolveWith)(h,i))}},k=e?j:function(){try{j()}catch(a){r.Deferred.exceptionHook&&r.Deferred.exceptionHook(a,k.stackTrace),b+1>=f&&(d!==O&&(h=void 0,i=[a]),c.rejectWith(h,i))}};b?k():(r.Deferred.getStackHook&&(k.stackTrace=r.Deferred.getStackHook()),a.setTimeout(k))}}return r.Deferred(function(a){c[0][3].add(g(0,a,r.isFunction(e)?e:N,a.notifyWith)),c[1][3].add(g(0,a,r.isFunction(b)?b:N)),c[2][3].add(g(0,a,r.isFunction(d)?d:O))}).promise()},promise:function(a){return null!=a?r.extend(a,e):e}},f={};return r.each(c,function(a,b){var g=b[2],h=b[5];e[b[1]]=g.add,h&&g.add(function(){d=h},c[3-a][2].disable,c[0][2].lock),g.add(b[3].fire),f[b[0]]=function(){return f[b[0]+"With"](this===f?void 0:this,arguments),this},f[b[0]+"With"]=g.fireWith}),e.promise(f),b&&b.call(f,f),f},when:function(a){var b=arguments.length,c=b,d=Array(c),e=f.call(arguments),g=r.Deferred(),h=function(a){return function(c){d[a]=this,e[a]=arguments.length>1?f.call(arguments):c,--b||g.resolveWith(d,e)}};if(b<=1&&(P(a,g.done(h(c)).resolve,g.reject,!b),"pending"===g.state()||r.isFunction(e[c]&&e[c].then)))return g.then();while(c--)P(e[c],h(c),g.reject);return g.promise()}});var Q=/^(Eval|Internal|Range|Reference|Syntax|Type|URI)Error$/;r.Deferred.exceptionHook=function(b,c){a.console&&a.console.warn&&b&&Q.test(b.name)&&a.console.warn("jQuery.Deferred exception: "+b.message,b.stack,c)},r.readyException=function(b){a.setTimeout(function(){throw b})};var R=r.Deferred();r.fn.ready=function(a){return R.then(a)["catch"](function(a){r.readyException(a)}),this},r.extend({isReady:!1,readyWait:1,ready:function(a){(a===!0?--r.readyWait:r.isReady)||(r.isReady=!0,a!==!0&&--r.readyWait>0||R.resolveWith(d,[r]))}}),r.ready.then=R.then;function S(){d.removeEventListener("DOMContentLoaded",S),
a.removeEventListener("load",S),r.ready()}"complete"===d.readyState||"loading"!==d.readyState&&!d.documentElement.doScroll?a.setTimeout(r.ready):(d.addEventListener("DOMContentLoaded",S),a.addEventListener("load",S));var T=function(a,b,c,d,e,f,g){var h=0,i=a.length,j=null==c;if("object"===r.type(c)){e=!0;for(h in c)T(a,b,h,c[h],!0,f,g)}else if(void 0!==d&&(e=!0,r.isFunction(d)||(g=!0),j&&(g?(b.call(a,d),b=null):(j=b,b=function(a,b,c){return j.call(r(a),c)})),b))for(;h<i;h++)b(a[h],c,g?d:d.call(a[h],h,b(a[h],c)));return e?a:j?b.call(a):i?b(a[0],c):f},U=function(a){return 1===a.nodeType||9===a.nodeType||!+a.nodeType};function V(){this.expando=r.expando+V.uid++}V.uid=1,V.prototype={cache:function(a){var b=a[this.expando];return b||(b={},U(a)&&(a.nodeType?a[this.expando]=b:Object.defineProperty(a,this.expando,{value:b,configurable:!0}))),b},set:function(a,b,c){var d,e=this.cache(a);if("string"==typeof b)e[r.camelCase(b)]=c;else for(d in b)e[r.camelCase(d)]=b[d];return e},get:function(a,b){return void 0===b?this.cache(a):a[this.expando]&&a[this.expando][r.camelCase(b)]},access:function(a,b,c){return void 0===b||b&&"string"==typeof b&&void 0===c?this.get(a,b):(this.set(a,b,c),void 0!==c?c:b)},remove:function(a,b){var c,d=a[this.expando];if(void 0!==d){if(void 0!==b){Array.isArray(b)?b=b.map(r.camelCase):(b=r.camelCase(b),b=b in d?[b]:b.match(L)||[]),c=b.length;while(c--)delete d[b[c]]}(void 0===b||r.isEmptyObject(d))&&(a.nodeType?a[this.expando]=void 0:delete a[this.expando])}},hasData:function(a){var b=a[this.expando];return void 0!==b&&!r.isEmptyObject(b)}};var W=new V,X=new V,Y=/^(?:\{[\w\W]*\}|\[[\w\W]*\])$/,Z=/[A-Z]/g;function $(a){return"true"===a||"false"!==a&&("null"===a?null:a===+a+""?+a:Y.test(a)?JSON.parse(a):a)}function _(a,b,c){var d;if(void 0===c&&1===a.nodeType)if(d="data-"+b.replace(Z,"-$&").toLowerCase(),c=a.getAttribute(d),"string"==typeof c){try{c=$(c)}catch(e){}X.set(a,b,c)}else c=void 0;return c}r.extend({hasData:function(a){return X.hasData(a)||W.hasData(a)},data:function(a,b,c){return X.access(a,b,c)},removeData:function(a,b){X.remove(a,b)},_data:function(a,b,c){return W.access(a,b,c)},_removeData:function(a,b){W.remove(a,b)}}),r.fn.extend({data:function(a,b){var c,d,e,f=this[0],g=f&&f.attributes;if(void 0===a){if(this.length&&(e=X.get(f),1===f.nodeType&&!W.get(f,"hasDataAttrs"))){c=g.length;while(c--)g[c]&&(d=g[c].name,0===d.indexOf("data-")&&(d=r.camelCase(d.slice(5)),_(f,d,e[d])));W.set(f,"hasDataAttrs",!0)}return e}return"object"==typeof a?this.each(function(){X.set(this,a)}):T(this,function(b){var c;if(f&&void 0===b){if(c=X.get(f,a),void 0!==c)return c;if(c=_(f,a),void 0!==c)return c}else this.each(function(){X.set(this,a,b)})},null,b,arguments.length>1,null,!0)},removeData:function(a){return this.each(function(){X.remove(this,a)})}}),r.extend({queue:function(a,b,c){var d;if(a)return b=(b||"fx")+"queue",d=W.get(a,b),c&&(!d||Array.isArray(c)?d=W.access(a,b,r.makeArray(c)):d.push(c)),d||[]},dequeue:function(a,b){b=b||"fx";var c=r.queue(a,b),d=c.length,e=c.shift(),f=r._queueHooks(a,b),g=function(){r.dequeue(a,b)};"inprogress"===e&&(e=c.shift(),d--),e&&("fx"===b&&c.unshift("inprogress"),delete f.stop,e.call(a,g,f)),!d&&f&&f.empty.fire()},_queueHooks:function(a,b){var c=b+"queueHooks";return W.get(a,c)||W.access(a,c,{empty:r.Callbacks("once memory").add(function(){W.remove(a,[b+"queue",c])})})}}),r.fn.extend({queue:function(a,b){var c=2;return"string"!=typeof a&&(b=a,a="fx",c--),arguments.length<c?r.queue(this[0],a):void 0===b?this:this.each(function(){var c=r.queue(this,a,b);r._queueHooks(this,a),"fx"===a&&"inprogress"!==c[0]&&r.dequeue(this,a)})},dequeue:function(a){return this.each(function(){r.dequeue(this,a)})},clearQueue:function(a){return this.queue(a||"fx",[])},promise:function(a,b){var c,d=1,e=r.Deferred(),f=this,g=this.length,h=function(){--d||e.resolveWith(f,[f])};"string"!=typeof a&&(b=a,a=void 0),a=a||"fx";while(g--)c=W.get(f[g],a+"queueHooks"),c&&c.empty&&(d++,c.empty.add(h));return h(),e.promise(b)}});var aa=/[+-]?(?:\d*\.|)\d+(?:[eE][+-]?\d+|)/.source,ba=new RegExp("^(?:([+-])=|)("+aa+")([a-z%]*)$","i"),ca=["Top","Right","Bottom","Left"],da=function(a,b){return a=b||a,"none"===a.style.display||""===a.style.display&&r.contains(a.ownerDocument,a)&&"none"===r.css(a,"display")},ea=function(a,b,c,d){var e,f,g={};for(f in b)g[f]=a.style[f],a.style[f]=b[f];e=c.apply(a,d||[]);for(f in b)a.style[f]=g[f];return e};function fa(a,b,c,d){var e,f=1,g=20,h=d?function(){return d.cur()}:function(){return r.css(a,b,"")},i=h(),j=c&&c[3]||(r.cssNumber[b]?"":"px"),k=(r.cssNumber[b]||"px"!==j&&+i)&&ba.exec(r.css(a,b));if(k&&k[3]!==j){j=j||k[3],c=c||[],k=+i||1;do f=f||".5",k/=f,r.style(a,b,k+j);while(f!==(f=h()/i)&&1!==f&&--g)}return c&&(k=+k||+i||0,e=c[1]?k+(c[1]+1)*c[2]:+c[2],d&&(d.unit=j,d.start=k,d.end=e)),e}var ga={};function ha(a){var b,c=a.ownerDocument,d=a.nodeName,e=ga[d];return e?e:(b=c.body.appendChild(c.createElement(d)),e=r.css(b,"display"),b.parentNode.removeChild(b),"none"===e&&(e="block"),ga[d]=e,e)}function ia(a,b){for(var c,d,e=[],f=0,g=a.length;f<g;f++)d=a[f],d.style&&(c=d.style.display,b?("none"===c&&(e[f]=W.get(d,"display")||null,e[f]||(d.style.display="")),""===d.style.display&&da(d)&&(e[f]=ha(d))):"none"!==c&&(e[f]="none",W.set(d,"display",c)));for(f=0;f<g;f++)null!=e[f]&&(a[f].style.display=e[f]);return a}r.fn.extend({show:function(){return ia(this,!0)},hide:function(){return ia(this)},toggle:function(a){return"boolean"==typeof a?a?this.show():this.hide():this.each(function(){da(this)?r(this).show():r(this).hide()})}});var ja=/^(?:checkbox|radio)$/i,ka=/<([a-z][^\/\0>\x20\t\r\n\f]+)/i,la=/^$|\/(?:java|ecma)script/i,ma={option:[1,"<select multiple='multiple'>","</select>"],thead:[1,"<table>","</table>"],col:[2,"<table><colgroup>","</colgroup></table>"],tr:[2,"<table><tbody>","</tbody></table>"],td:[3,"<table><tbody><tr>","</tr></tbody></table>"],_default:[0,"",""]};ma.optgroup=ma.option,ma.tbody=ma.tfoot=ma.colgroup=ma.caption=ma.thead,ma.th=ma.td;function na(a,b){var c;return c="undefined"!=typeof a.getElementsByTagName?a.getElementsByTagName(b||"*"):"undefined"!=typeof a.querySelectorAll?a.querySelectorAll(b||"*"):[],void 0===b||b&&B(a,b)?r.merge([a],c):c}function oa(a,b){for(var c=0,d=a.length;c<d;c++)W.set(a[c],"globalEval",!b||W.get(b[c],"globalEval"))}var pa=/<|&#?\w+;/;function qa(a,b,c,d,e){for(var f,g,h,i,j,k,l=b.createDocumentFragment(),m=[],n=0,o=a.length;n<o;n++)if(f=a[n],f||0===f)if("object"===r.type(f))r.merge(m,f.nodeType?[f]:f);else if(pa.test(f)){g=g||l.appendChild(b.createElement("div")),h=(ka.exec(f)||["",""])[1].toLowerCase(),i=ma[h]||ma._default,g.innerHTML=i[1]+r.htmlPrefilter(f)+i[2],k=i[0];while(k--)g=g.lastChild;r.merge(m,g.childNodes),g=l.firstChild,g.textContent=""}else m.push(b.createTextNode(f));l.textContent="",n=0;while(f=m[n++])if(d&&r.inArray(f,d)>-1)e&&e.push(f);else if(j=r.contains(f.ownerDocument,f),g=na(l.appendChild(f),"script"),j&&oa(g),c){k=0;while(f=g[k++])la.test(f.type||"")&&c.push(f)}return l}!function(){var a=d.createDocumentFragment(),b=a.appendChild(d.createElement("div")),c=d.createElement("input");c.setAttribute("type","radio"),c.setAttribute("checked","checked"),c.setAttribute("name","t"),b.appendChild(c),o.checkClone=b.cloneNode(!0).cloneNode(!0).lastChild.checked,b.innerHTML="<textarea>x</textarea>",o.noCloneChecked=!!b.cloneNode(!0).lastChild.defaultValue}();var ra=d.documentElement,sa=/^key/,ta=/^(?:mouse|pointer|contextmenu|drag|drop)|click/,ua=/^([^.]*)(?:\.(.+)|)/;function va(){return!0}function wa(){return!1}function xa(){try{return d.activeElement}catch(a){}}function ya(a,b,c,d,e,f){var g,h;if("object"==typeof b){"string"!=typeof c&&(d=d||c,c=void 0);for(h in b)ya(a,h,c,d,b[h],f);return a}if(null==d&&null==e?(e=c,d=c=void 0):null==e&&("string"==typeof c?(e=d,d=void 0):(e=d,d=c,c=void 0)),e===!1)e=wa;else if(!e)return a;return 1===f&&(g=e,e=function(a){return r().off(a),g.apply(this,arguments)},e.guid=g.guid||(g.guid=r.guid++)),a.each(function(){r.event.add(this,b,e,d,c)})}r.event={global:{},add:function(a,b,c,d,e){var f,g,h,i,j,k,l,m,n,o,p,q=W.get(a);if(q){c.handler&&(f=c,c=f.handler,e=f.selector),e&&r.find.matchesSelector(ra,e),c.guid||(c.guid=r.guid++),(i=q.events)||(i=q.events={}),(g=q.handle)||(g=q.handle=function(b){return"undefined"!=typeof r&&r.event.triggered!==b.type?r.event.dispatch.apply(a,arguments):void 0}),b=(b||"").match(L)||[""],j=b.length;while(j--)h=ua.exec(b[j])||[],n=p=h[1],o=(h[2]||"").split(".").sort(),n&&(l=r.event.special[n]||{},n=(e?l.delegateType:l.bindType)||n,l=r.event.special[n]||{},k=r.extend({type:n,origType:p,data:d,handler:c,guid:c.guid,selector:e,needsContext:e&&r.expr.match.needsContext.test(e),namespace:o.join(".")},f),(m=i[n])||(m=i[n]=[],m.delegateCount=0,l.setup&&l.setup.call(a,d,o,g)!==!1||a.addEventListener&&a.addEventListener(n,g)),l.add&&(l.add.call(a,k),k.handler.guid||(k.handler.guid=c.guid)),e?m.splice(m.delegateCount++,0,k):m.push(k),r.event.global[n]=!0)}},remove:function(a,b,c,d,e){var f,g,h,i,j,k,l,m,n,o,p,q=W.hasData(a)&&W.get(a);if(q&&(i=q.events)){b=(b||"").match(L)||[""],j=b.length;while(j--)if(h=ua.exec(b[j])||[],n=p=h[1],o=(h[2]||"").split(".").sort(),n){l=r.event.special[n]||{},n=(d?l.delegateType:l.bindType)||n,m=i[n]||[],h=h[2]&&new RegExp("(^|\\.)"+o.join("\\.(?:.*\\.|)")+"(\\.|$)"),g=f=m.length;while(f--)k=m[f],!e&&p!==k.origType||c&&c.guid!==k.guid||h&&!h.test(k.namespace)||d&&d!==k.selector&&("**"!==d||!k.selector)||(m.splice(f,1),k.selector&&m.delegateCount--,l.remove&&l.remove.call(a,k));g&&!m.length&&(l.teardown&&l.teardown.call(a,o,q.handle)!==!1||r.removeEvent(a,n,q.handle),delete i[n])}else for(n in i)r.event.remove(a,n+b[j],c,d,!0);r.isEmptyObject(i)&&W.remove(a,"handle events")}},dispatch:function(a){var b=r.event.fix(a),c,d,e,f,g,h,i=new Array(arguments.length),j=(W.get(this,"events")||{})[b.type]||[],k=r.event.special[b.type]||{};for(i[0]=b,c=1;c<arguments.length;c++)i[c]=arguments[c];if(b.delegateTarget=this,!k.preDispatch||k.preDispatch.call(this,b)!==!1){h=r.event.handlers.call(this,b,j),c=0;while((f=h[c++])&&!b.isPropagationStopped()){b.currentTarget=f.elem,d=0;while((g=f.handlers[d++])&&!b.isImmediatePropagationStopped())b.rnamespace&&!b.rnamespace.test(g.namespace)||(b.handleObj=g,b.data=g.data,e=((r.event.special[g.origType]||{}).handle||g.handler).apply(f.elem,i),void 0!==e&&(b.result=e)===!1&&(b.preventDefault(),b.stopPropagation()))}return k.postDispatch&&k.postDispatch.call(this,b),b.result}},handlers:function(a,b){var c,d,e,f,g,h=[],i=b.delegateCount,j=a.target;if(i&&j.nodeType&&!("click"===a.type&&a.button>=1))for(;j!==this;j=j.parentNode||this)if(1===j.nodeType&&("click"!==a.type||j.disabled!==!0)){for(f=[],g={},c=0;c<i;c++)d=b[c],e=d.selector+" ",void 0===g[e]&&(g[e]=d.needsContext?r(e,this).index(j)>-1:r.find(e,this,null,[j]).length),g[e]&&f.push(d);f.length&&h.push({elem:j,handlers:f})}return j=this,i<b.length&&h.push({elem:j,handlers:b.slice(i)}),h},addProp:function(a,b){Object.defineProperty(r.Event.prototype,a,{enumerable:!0,configurable:!0,get:r.isFunction(b)?function(){if(this.originalEvent)return b(this.originalEvent)}:function(){if(this.originalEvent)return this.originalEvent[a]},set:function(b){Object.defineProperty(this,a,{enumerable:!0,configurable:!0,writable:!0,value:b})}})},fix:function(a){return a[r.expando]?a:new r.Event(a)},special:{load:{noBubble:!0},focus:{trigger:function(){if(this!==xa()&&this.focus)return this.focus(),!1},delegateType:"focusin"},blur:{trigger:function(){if(this===xa()&&this.blur)return this.blur(),!1},delegateType:"focusout"},click:{trigger:function(){if("checkbox"===this.type&&this.click&&B(this,"input"))return this.click(),!1},_default:function(a){return B(a.target,"a")}},beforeunload:{postDispatch:function(a){void 0!==a.result&&a.originalEvent&&(a.originalEvent.returnValue=a.result)}}}},r.removeEvent=function(a,b,c){a.removeEventListener&&a.removeEventListener(b,c)},r.Event=function(a,b){return this instanceof r.Event?(a&&a.type?(this.originalEvent=a,this.type=a.type,this.isDefaultPrevented=a.defaultPrevented||void 0===a.defaultPrevented&&a.returnValue===!1?va:wa,this.target=a.target&&3===a.target.nodeType?a.target.parentNode:a.target,this.currentTarget=a.currentTarget,this.relatedTarget=a.relatedTarget):this.type=a,b&&r.extend(this,b),this.timeStamp=a&&a.timeStamp||r.now(),void(this[r.expando]=!0)):new r.Event(a,b)},r.Event.prototype={constructor:r.Event,isDefaultPrevented:wa,isPropagationStopped:wa,isImmediatePropagationStopped:wa,isSimulated:!1,preventDefault:function(){var a=this.originalEvent;this.isDefaultPrevented=va,a&&!this.isSimulated&&a.preventDefault()},stopPropagation:function(){var a=this.originalEvent;this.isPropagationStopped=va,a&&!this.isSimulated&&a.stopPropagation()},stopImmediatePropagation:function(){var a=this.originalEvent;this.isImmediatePropagationStopped=va,a&&!this.isSimulated&&a.stopImmediatePropagation(),this.stopPropagation()}},r.each({altKey:!0,bubbles:!0,cancelable:!0,changedTouches:!0,ctrlKey:!0,detail:!0,eventPhase:!0,metaKey:!0,pageX:!0,pageY:!0,shiftKey:!0,view:!0,"char":!0,charCode:!0,key:!0,keyCode:!0,button:!0,buttons:!0,clientX:!0,clientY:!0,offsetX:!0,offsetY:!0,pointerId:!0,pointerType:!0,screenX:!0,screenY:!0,targetTouches:!0,toElement:!0,touches:!0,which:function(a){var b=a.button;return null==a.which&&sa.test(a.type)?null!=a.charCode?a.charCode:a.keyCode:!a.which&&void 0!==b&&ta.test(a.type)?1&b?1:2&b?3:4&b?2:0:a.which}},r.event.addProp),r.each({mouseenter:"mouseover",mouseleave:"mouseout",pointerenter:"pointerover",pointerleave:"pointerout"},function(a,b){r.event.special[a]={delegateType:b,bindType:b,handle:function(a){var c,d=this,e=a.relatedTarget,f=a.handleObj;return e&&(e===d||r.contains(d,e))||(a.type=f.origType,c=f.handler.apply(this,arguments),a.type=b),c}}}),r.fn.extend({on:function(a,b,c,d){return ya(this,a,b,c,d)},one:function(a,b,c,d){return ya(this,a,b,c,d,1)},off:function(a,b,c){var d,e;if(a&&a.preventDefault&&a.handleObj)return d=a.handleObj,r(a.delegateTarget).off(d.namespace?d.origType+"."+d.namespace:d.origType,d.selector,d.handler),this;if("object"==typeof a){for(e in a)this.off(e,b,a[e]);return this}return b!==!1&&"function"!=typeof b||(c=b,b=void 0),c===!1&&(c=wa),this.each(function(){r.event.remove(this,a,c,b)})}});var za=/<(?!area|br|col|embed|hr|img|input|link|meta|param)(([a-z][^\/\0>\x20\t\r\n\f]*)[^>]*)\/>/gi,Aa=/<script|<style|<link/i,Ba=/checked\s*(?:[^=]|=\s*.checked.)/i,Ca=/^true\/(.*)/,Da=/^\s*<!(?:\[CDATA\[|--)|(?:\]\]|--)>\s*$/g;function Ea(a,b){return B(a,"table")&&B(11!==b.nodeType?b:b.firstChild,"tr")?r(">tbody",a)[0]||a:a}function Fa(a){return a.type=(null!==a.getAttribute("type"))+"/"+a.type,a}function Ga(a){var b=Ca.exec(a.type);return b?a.type=b[1]:a.removeAttribute("type"),a}function Ha(a,b){var c,d,e,f,g,h,i,j;if(1===b.nodeType){if(W.hasData(a)&&(f=W.access(a),g=W.set(b,f),j=f.events)){delete g.handle,g.events={};for(e in j)for(c=0,d=j[e].length;c<d;c++)r.event.add(b,e,j[e][c])}X.hasData(a)&&(h=X.access(a),i=r.extend({},h),X.set(b,i))}}function Ia(a,b){var c=b.nodeName.toLowerCase();"input"===c&&ja.test(a.type)?b.checked=a.checked:"input"!==c&&"textarea"!==c||(b.defaultValue=a.defaultValue)}function Ja(a,b,c,d){b=g.apply([],b);var e,f,h,i,j,k,l=0,m=a.length,n=m-1,q=b[0],s=r.isFunction(q);if(s||m>1&&"string"==typeof q&&!o.checkClone&&Ba.test(q))return a.each(function(e){var f=a.eq(e);s&&(b[0]=q.call(this,e,f.html())),Ja(f,b,c,d)});if(m&&(e=qa(b,a[0].ownerDocument,!1,a,d),f=e.firstChild,1===e.childNodes.length&&(e=f),f||d)){for(h=r.map(na(e,"script"),Fa),i=h.length;l<m;l++)j=e,l!==n&&(j=r.clone(j,!0,!0),i&&r.merge(h,na(j,"script"))),c.call(a[l],j,l);if(i)for(k=h[h.length-1].ownerDocument,r.map(h,Ga),l=0;l<i;l++)j=h[l],la.test(j.type||"")&&!W.access(j,"globalEval")&&r.contains(k,j)&&(j.src?r._evalUrl&&r._evalUrl(j.src):p(j.textContent.replace(Da,""),k))}return a}function Ka(a,b,c){for(var d,e=b?r.filter(b,a):a,f=0;null!=(d=e[f]);f++)c||1!==d.nodeType||r.cleanData(na(d)),d.parentNode&&(c&&r.contains(d.ownerDocument,d)&&oa(na(d,"script")),d.parentNode.removeChild(d));return a}r.extend({htmlPrefilter:function(a){return a.replace(za,"<$1></$2>")},clone:function(a,b,c){var d,e,f,g,h=a.cloneNode(!0),i=r.contains(a.ownerDocument,a);if(!(o.noCloneChecked||1!==a.nodeType&&11!==a.nodeType||r.isXMLDoc(a)))for(g=na(h),f=na(a),d=0,e=f.length;d<e;d++)Ia(f[d],g[d]);if(b)if(c)for(f=f||na(a),g=g||na(h),d=0,e=f.length;d<e;d++)Ha(f[d],g[d]);else Ha(a,h);return g=na(h,"script"),g.length>0&&oa(g,!i&&na(a,"script")),h},cleanData:function(a){for(var b,c,d,e=r.event.special,f=0;void 0!==(c=a[f]);f++)if(U(c)){if(b=c[W.expando]){if(b.events)for(d in b.events)e[d]?r.event.remove(c,d):r.removeEvent(c,d,b.handle);c[W.expando]=void 0}c[X.expando]&&(c[X.expando]=void 0)}}}),r.fn.extend({detach:function(a){return Ka(this,a,!0)},remove:function(a){return Ka(this,a)},text:function(a){return T(this,function(a){return void 0===a?r.text(this):this.empty().each(function(){1!==this.nodeType&&11!==this.nodeType&&9!==this.nodeType||(this.textContent=a)})},null,a,arguments.length)},append:function(){return Ja(this,arguments,function(a){if(1===this.nodeType||11===this.nodeType||9===this.nodeType){var b=Ea(this,a);b.appendChild(a)}})},prepend:function(){return Ja(this,arguments,function(a){if(1===this.nodeType||11===this.nodeType||9===this.nodeType){var b=Ea(this,a);b.insertBefore(a,b.firstChild)}})},before:function(){return Ja(this,arguments,function(a){this.parentNode&&this.parentNode.insertBefore(a,this)})},after:function(){return Ja(this,arguments,function(a){this.parentNode&&this.parentNode.insertBefore(a,this.nextSibling)})},empty:function(){for(var a,b=0;null!=(a=this[b]);b++)1===a.nodeType&&(r.cleanData(na(a,!1)),a.textContent="");return this},clone:function(a,b){return a=null!=a&&a,b=null==b?a:b,this.map(function(){return r.clone(this,a,b)})},html:function(a){return T(this,function(a){var b=this[0]||{},c=0,d=this.length;if(void 0===a&&1===b.nodeType)return b.innerHTML;if("string"==typeof a&&!Aa.test(a)&&!ma[(ka.exec(a)||["",""])[1].toLowerCase()]){a=r.htmlPrefilter(a);try{for(;c<d;c++)b=this[c]||{},1===b.nodeType&&(r.cleanData(na(b,!1)),b.innerHTML=a);b=0}catch(e){}}b&&this.empty().append(a)},null,a,arguments.length)},replaceWith:function(){var a=[];return Ja(this,arguments,function(b){var c=this.parentNode;r.inArray(this,a)<0&&(r.cleanData(na(this)),c&&c.replaceChild(b,this))},a)}}),r.each({appendTo:"append",prependTo:"prepend",insertBefore:"before",insertAfter:"after",replaceAll:"replaceWith"},function(a,b){r.fn[a]=function(a){for(var c,d=[],e=r(a),f=e.length-1,g=0;g<=f;g++)c=g===f?this:this.clone(!0),r(e[g])[b](c),h.apply(d,c.get());return this.pushStack(d)}});var La=/^margin/,Ma=new RegExp("^("+aa+")(?!px)[a-z%]+$","i"),Na=function(b){var c=b.ownerDocument.defaultView;return c&&c.opener||(c=a),c.getComputedStyle(b)};!function(){function b(){if(i){i.style.cssText="box-sizing:border-box;position:relative;display:block;margin:auto;border:1px;padding:1px;top:1%;width:50%",i.innerHTML="",ra.appendChild(h);var b=a.getComputedStyle(i);c="1%"!==b.top,g="2px"===b.marginLeft,e="4px"===b.width,i.style.marginRight="50%",f="4px"===b.marginRight,ra.removeChild(h),i=null}}var c,e,f,g,h=d.createElement("div"),i=d.createElement("div");i.style&&(i.style.backgroundClip="content-box",i.cloneNode(!0).style.backgroundClip="",o.clearCloneStyle="content-box"===i.style.backgroundClip,h.style.cssText="border:0;width:8px;height:0;top:0;left:-9999px;padding:0;margin-top:1px;position:absolute",h.appendChild(i),r.extend(o,{pixelPosition:function(){return b(),c},boxSizingReliable:function(){return b(),e},pixelMarginRight:function(){return b(),f},reliableMarginLeft:function(){return b(),g}}))}();function Oa(a,b,c){var d,e,f,g,h=a.style;return c=c||Na(a),c&&(g=c.getPropertyValue(b)||c[b],""!==g||r.contains(a.ownerDocument,a)||(g=r.style(a,b)),!o.pixelMarginRight()&&Ma.test(g)&&La.test(b)&&(d=h.width,e=h.minWidth,f=h.maxWidth,h.minWidth=h.maxWidth=h.width=g,g=c.width,h.width=d,h.minWidth=e,h.maxWidth=f)),void 0!==g?g+"":g}function Pa(a,b){return{get:function(){return a()?void delete this.get:(this.get=b).apply(this,arguments)}}}var Qa=/^(none|table(?!-c[ea]).+)/,Ra=/^--/,Sa={position:"absolute",visibility:"hidden",display:"block"},Ta={letterSpacing:"0",fontWeight:"400"},Ua=["Webkit","Moz","ms"],Va=d.createElement("div").style;function Wa(a){if(a in Va)return a;var b=a[0].toUpperCase()+a.slice(1),c=Ua.length;while(c--)if(a=Ua[c]+b,a in Va)return a}function Xa(a){var b=r.cssProps[a];return b||(b=r.cssProps[a]=Wa(a)||a),b}function Ya(a,b,c){var d=ba.exec(b);return d?Math.max(0,d[2]-(c||0))+(d[3]||"px"):b}function Za(a,b,c,d,e){var f,g=0;for(f=c===(d?"border":"content")?4:"width"===b?1:0;f<4;f+=2)"margin"===c&&(g+=r.css(a,c+ca[f],!0,e)),d?("content"===c&&(g-=r.css(a,"padding"+ca[f],!0,e)),"margin"!==c&&(g-=r.css(a,"border"+ca[f]+"Width",!0,e))):(g+=r.css(a,"padding"+ca[f],!0,e),"padding"!==c&&(g+=r.css(a,"border"+ca[f]+"Width",!0,e)));return g}function $a(a,b,c){var d,e=Na(a),f=Oa(a,b,e),g="border-box"===r.css(a,"boxSizing",!1,e);return Ma.test(f)?f:(d=g&&(o.boxSizingReliable()||f===a.style[b]),"auto"===f&&(f=a["offset"+b[0].toUpperCase()+b.slice(1)]),f=parseFloat(f)||0,f+Za(a,b,c||(g?"border":"content"),d,e)+"px")}r.extend({cssHooks:{opacity:{get:function(a,b){if(b){var c=Oa(a,"opacity");return""===c?"1":c}}}},cssNumber:{animationIterationCount:!0,columnCount:!0,fillOpacity:!0,flexGrow:!0,flexShrink:!0,fontWeight:!0,lineHeight:!0,opacity:!0,order:!0,orphans:!0,widows:!0,zIndex:!0,zoom:!0},cssProps:{"float":"cssFloat"},style:function(a,b,c,d){if(a&&3!==a.nodeType&&8!==a.nodeType&&a.style){var e,f,g,h=r.camelCase(b),i=Ra.test(b),j=a.style;return i||(b=Xa(h)),g=r.cssHooks[b]||r.cssHooks[h],void 0===c?g&&"get"in g&&void 0!==(e=g.get(a,!1,d))?e:j[b]:(f=typeof c,"string"===f&&(e=ba.exec(c))&&e[1]&&(c=fa(a,b,e),f="number"),null!=c&&c===c&&("number"===f&&(c+=e&&e[3]||(r.cssNumber[h]?"":"px")),o.clearCloneStyle||""!==c||0!==b.indexOf("background")||(j[b]="inherit"),g&&"set"in g&&void 0===(c=g.set(a,c,d))||(i?j.setProperty(b,c):j[b]=c)),void 0)}},css:function(a,b,c,d){var e,f,g,h=r.camelCase(b),i=Ra.test(b);return i||(b=Xa(h)),g=r.cssHooks[b]||r.cssHooks[h],g&&"get"in g&&(e=g.get(a,!0,c)),void 0===e&&(e=Oa(a,b,d)),"normal"===e&&b in Ta&&(e=Ta[b]),""===c||c?(f=parseFloat(e),c===!0||isFinite(f)?f||0:e):e}}),r.each(["height","width"],function(a,b){r.cssHooks[b]={get:function(a,c,d){if(c)return!Qa.test(r.css(a,"display"))||a.getClientRects().length&&a.getBoundingClientRect().width?$a(a,b,d):ea(a,Sa,function(){return $a(a,b,d)})},set:function(a,c,d){var e,f=d&&Na(a),g=d&&Za(a,b,d,"border-box"===r.css(a,"boxSizing",!1,f),f);return g&&(e=ba.exec(c))&&"px"!==(e[3]||"px")&&(a.style[b]=c,c=r.css(a,b)),Ya(a,c,g)}}}),r.cssHooks.marginLeft=Pa(o.reliableMarginLeft,function(a,b){if(b)return(parseFloat(Oa(a,"marginLeft"))||a.getBoundingClientRect().left-ea(a,{marginLeft:0},function(){return a.getBoundingClientRect().left}))+"px"}),r.each({margin:"",padding:"",border:"Width"},function(a,b){r.cssHooks[a+b]={expand:function(c){for(var d=0,e={},f="string"==typeof c?c.split(" "):[c];d<4;d++)e[a+ca[d]+b]=f[d]||f[d-2]||f[0];return e}},La.test(a)||(r.cssHooks[a+b].set=Ya)}),r.fn.extend({css:function(a,b){return T(this,function(a,b,c){var d,e,f={},g=0;if(Array.isArray(b)){for(d=Na(a),e=b.length;g<e;g++)f[b[g]]=r.css(a,b[g],!1,d);return f}return void 0!==c?r.style(a,b,c):r.css(a,b)},a,b,arguments.length>1)}});function _a(a,b,c,d,e){return new _a.prototype.init(a,b,c,d,e)}r.Tween=_a,_a.prototype={constructor:_a,init:function(a,b,c,d,e,f){this.elem=a,this.prop=c,this.easing=e||r.easing._default,this.options=b,this.start=this.now=this.cur(),this.end=d,this.unit=f||(r.cssNumber[c]?"":"px")},cur:function(){var a=_a.propHooks[this.prop];return a&&a.get?a.get(this):_a.propHooks._default.get(this)},run:function(a){var b,c=_a.propHooks[this.prop];return this.options.duration?this.pos=b=r.easing[this.easing](a,this.options.duration*a,0,1,this.options.duration):this.pos=b=a,this.now=(this.end-this.start)*b+this.start,this.options.step&&this.options.step.call(this.elem,this.now,this),c&&c.set?c.set(this):_a.propHooks._default.set(this),this}},_a.prototype.init.prototype=_a.prototype,_a.propHooks={_default:{get:function(a){var b;return 1!==a.elem.nodeType||null!=a.elem[a.prop]&&null==a.elem.style[a.prop]?a.elem[a.prop]:(b=r.css(a.elem,a.prop,""),b&&"auto"!==b?b:0)},set:function(a){r.fx.step[a.prop]?r.fx.step[a.prop](a):1!==a.elem.nodeType||null==a.elem.style[r.cssProps[a.prop]]&&!r.cssHooks[a.prop]?a.elem[a.prop]=a.now:r.style(a.elem,a.prop,a.now+a.unit)}}},_a.propHooks.scrollTop=_a.propHooks.scrollLeft={set:function(a){a.elem.nodeType&&a.elem.parentNode&&(a.elem[a.prop]=a.now)}},r.easing={linear:function(a){return a},swing:function(a){return.5-Math.cos(a*Math.PI)/2},_default:"swing"},r.fx=_a.prototype.init,r.fx.step={};var ab,bb,cb=/^(?:toggle|show|hide)$/,db=/queueHooks$/;function eb(){bb&&(d.hidden===!1&&a.requestAnimationFrame?a.requestAnimationFrame(eb):a.setTimeout(eb,r.fx.interval),r.fx.tick())}function fb(){return a.setTimeout(function(){ab=void 0}),ab=r.now()}function gb(a,b){var c,d=0,e={height:a};for(b=b?1:0;d<4;d+=2-b)c=ca[d],e["margin"+c]=e["padding"+c]=a;return b&&(e.opacity=e.width=a),e}function hb(a,b,c){for(var d,e=(kb.tweeners[b]||[]).concat(kb.tweeners["*"]),f=0,g=e.length;f<g;f++)if(d=e[f].call(c,b,a))return d}function ib(a,b,c){var d,e,f,g,h,i,j,k,l="width"in b||"height"in b,m=this,n={},o=a.style,p=a.nodeType&&da(a),q=W.get(a,"fxshow");c.queue||(g=r._queueHooks(a,"fx"),null==g.unqueued&&(g.unqueued=0,h=g.empty.fire,g.empty.fire=function(){g.unqueued||h()}),g.unqueued++,m.always(function(){m.always(function(){g.unqueued--,r.queue(a,"fx").length||g.empty.fire()})}));for(d in b)if(e=b[d],cb.test(e)){if(delete b[d],f=f||"toggle"===e,e===(p?"hide":"show")){if("show"!==e||!q||void 0===q[d])continue;p=!0}n[d]=q&&q[d]||r.style(a,d)}if(i=!r.isEmptyObject(b),i||!r.isEmptyObject(n)){l&&1===a.nodeType&&(c.overflow=[o.overflow,o.overflowX,o.overflowY],j=q&&q.display,null==j&&(j=W.get(a,"display")),k=r.css(a,"display"),"none"===k&&(j?k=j:(ia([a],!0),j=a.style.display||j,k=r.css(a,"display"),ia([a]))),("inline"===k||"inline-block"===k&&null!=j)&&"none"===r.css(a,"float")&&(i||(m.done(function(){o.display=j}),null==j&&(k=o.display,j="none"===k?"":k)),o.display="inline-block")),c.overflow&&(o.overflow="hidden",m.always(function(){o.overflow=c.overflow[0],o.overflowX=c.overflow[1],o.overflowY=c.overflow[2]})),i=!1;for(d in n)i||(q?"hidden"in q&&(p=q.hidden):q=W.access(a,"fxshow",{display:j}),f&&(q.hidden=!p),p&&ia([a],!0),m.done(function(){p||ia([a]),W.remove(a,"fxshow");for(d in n)r.style(a,d,n[d])})),i=hb(p?q[d]:0,d,m),d in q||(q[d]=i.start,p&&(i.end=i.start,i.start=0))}}function jb(a,b){var c,d,e,f,g;for(c in a)if(d=r.camelCase(c),e=b[d],f=a[c],Array.isArray(f)&&(e=f[1],f=a[c]=f[0]),c!==d&&(a[d]=f,delete a[c]),g=r.cssHooks[d],g&&"expand"in g){f=g.expand(f),delete a[d];for(c in f)c in a||(a[c]=f[c],b[c]=e)}else b[d]=e}function kb(a,b,c){var d,e,f=0,g=kb.prefilters.length,h=r.Deferred().always(function(){delete i.elem}),i=function(){if(e)return!1;for(var b=ab||fb(),c=Math.max(0,j.startTime+j.duration-b),d=c/j.duration||0,f=1-d,g=0,i=j.tweens.length;g<i;g++)j.tweens[g].run(f);return h.notifyWith(a,[j,f,c]),f<1&&i?c:(i||h.notifyWith(a,[j,1,0]),h.resolveWith(a,[j]),!1)},j=h.promise({elem:a,props:r.extend({},b),opts:r.extend(!0,{specialEasing:{},easing:r.easing._default},c),originalProperties:b,originalOptions:c,startTime:ab||fb(),duration:c.duration,tweens:[],createTween:function(b,c){var d=r.Tween(a,j.opts,b,c,j.opts.specialEasing[b]||j.opts.easing);return j.tweens.push(d),d},stop:function(b){var c=0,d=b?j.tweens.length:0;if(e)return this;for(e=!0;c<d;c++)j.tweens[c].run(1);return b?(h.notifyWith(a,[j,1,0]),h.resolveWith(a,[j,b])):h.rejectWith(a,[j,b]),this}}),k=j.props;for(jb(k,j.opts.specialEasing);f<g;f++)if(d=kb.prefilters[f].call(j,a,k,j.opts))return r.isFunction(d.stop)&&(r._queueHooks(j.elem,j.opts.queue).stop=r.proxy(d.stop,d)),d;return r.map(k,hb,j),r.isFunction(j.opts.start)&&j.opts.start.call(a,j),j.progress(j.opts.progress).done(j.opts.done,j.opts.complete).fail(j.opts.fail).always(j.opts.always),r.fx.timer(r.extend(i,{elem:a,anim:j,queue:j.opts.queue})),j}r.Animation=r.extend(kb,{tweeners:{"*":[function(a,b){var c=this.createTween(a,b);return fa(c.elem,a,ba.exec(b),c),c}]},tweener:function(a,b){r.isFunction(a)?(b=a,a=["*"]):a=a.match(L);for(var c,d=0,e=a.length;d<e;d++)c=a[d],kb.tweeners[c]=kb.tweeners[c]||[],kb.tweeners[c].unshift(b)},prefilters:[ib],prefilter:function(a,b){b?kb.prefilters.unshift(a):kb.prefilters.push(a)}}),r.speed=function(a,b,c){var d=a&&"object"==typeof a?r.extend({},a):{complete:c||!c&&b||r.isFunction(a)&&a,duration:a,easing:c&&b||b&&!r.isFunction(b)&&b};return r.fx.off?d.duration=0:"number"!=typeof d.duration&&(d.duration in r.fx.speeds?d.duration=r.fx.speeds[d.duration]:d.duration=r.fx.speeds._default),null!=d.queue&&d.queue!==!0||(d.queue="fx"),d.old=d.complete,d.complete=function(){r.isFunction(d.old)&&d.old.call(this),d.queue&&r.dequeue(this,d.queue)},d},r.fn.extend({fadeTo:function(a,b,c,d){return this.filter(da).css("opacity",0).show().end().animate({opacity:b},a,c,d)},animate:function(a,b,c,d){var e=r.isEmptyObject(a),f=r.speed(b,c,d),g=function(){var b=kb(this,r.extend({},a),f);(e||W.get(this,"finish"))&&b.stop(!0)};return g.finish=g,e||f.queue===!1?this.each(g):this.queue(f.queue,g)},stop:function(a,b,c){var d=function(a){var b=a.stop;delete a.stop,b(c)};return"string"!=typeof a&&(c=b,b=a,a=void 0),b&&a!==!1&&this.queue(a||"fx",[]),this.each(function(){var b=!0,e=null!=a&&a+"queueHooks",f=r.timers,g=W.get(this);if(e)g[e]&&g[e].stop&&d(g[e]);else for(e in g)g[e]&&g[e].stop&&db.test(e)&&d(g[e]);for(e=f.length;e--;)f[e].elem!==this||null!=a&&f[e].queue!==a||(f[e].anim.stop(c),b=!1,f.splice(e,1));!b&&c||r.dequeue(this,a)})},finish:function(a){return a!==!1&&(a=a||"fx"),this.each(function(){var b,c=W.get(this),d=c[a+"queue"],e=c[a+"queueHooks"],f=r.timers,g=d?d.length:0;for(c.finish=!0,r.queue(this,a,[]),e&&e.stop&&e.stop.call(this,!0),b=f.length;b--;)f[b].elem===this&&f[b].queue===a&&(f[b].anim.stop(!0),f.splice(b,1));for(b=0;b<g;b++)d[b]&&d[b].finish&&d[b].finish.call(this);delete c.finish})}}),r.each(["toggle","show","hide"],function(a,b){var c=r.fn[b];r.fn[b]=function(a,d,e){return null==a||"boolean"==typeof a?c.apply(this,arguments):this.animate(gb(b,!0),a,d,e)}}),r.each({slideDown:gb("show"),slideUp:gb("hide"),slideToggle:gb("toggle"),fadeIn:{opacity:"show"},fadeOut:{opacity:"hide"},fadeToggle:{opacity:"toggle"}},function(a,b){r.fn[a]=function(a,c,d){return this.animate(b,a,c,d)}}),r.timers=[],r.fx.tick=function(){var a,b=0,c=r.timers;for(ab=r.now();b<c.length;b++)a=c[b],a()||c[b]!==a||c.splice(b--,1);c.length||r.fx.stop(),ab=void 0},r.fx.timer=function(a){r.timers.push(a),r.fx.start()},r.fx.interval=13,r.fx.start=function(){bb||(bb=!0,eb())},r.fx.stop=function(){bb=null},r.fx.speeds={slow:600,fast:200,_default:400},r.fn.delay=function(b,c){return b=r.fx?r.fx.speeds[b]||b:b,c=c||"fx",this.queue(c,function(c,d){var e=a.setTimeout(c,b);d.stop=function(){a.clearTimeout(e)}})},function(){var a=d.createElement("input"),b=d.createElement("select"),c=b.appendChild(d.createElement("option"));a.type="checkbox",o.checkOn=""!==a.value,o.optSelected=c.selected,a=d.createElement("input"),a.value="t",a.type="radio",o.radioValue="t"===a.value}();var lb,mb=r.expr.attrHandle;r.fn.extend({attr:function(a,b){return T(this,r.attr,a,b,arguments.length>1)},removeAttr:function(a){return this.each(function(){r.removeAttr(this,a)})}}),r.extend({attr:function(a,b,c){var d,e,f=a.nodeType;if(3!==f&&8!==f&&2!==f)return"undefined"==typeof a.getAttribute?r.prop(a,b,c):(1===f&&r.isXMLDoc(a)||(e=r.attrHooks[b.toLowerCase()]||(r.expr.match.bool.test(b)?lb:void 0)),void 0!==c?null===c?void r.removeAttr(a,b):e&&"set"in e&&void 0!==(d=e.set(a,c,b))?d:(a.setAttribute(b,c+""),c):e&&"get"in e&&null!==(d=e.get(a,b))?d:(d=r.find.attr(a,b),
null==d?void 0:d))},attrHooks:{type:{set:function(a,b){if(!o.radioValue&&"radio"===b&&B(a,"input")){var c=a.value;return a.setAttribute("type",b),c&&(a.value=c),b}}}},removeAttr:function(a,b){var c,d=0,e=b&&b.match(L);if(e&&1===a.nodeType)while(c=e[d++])a.removeAttribute(c)}}),lb={set:function(a,b,c){return b===!1?r.removeAttr(a,c):a.setAttribute(c,c),c}},r.each(r.expr.match.bool.source.match(/\w+/g),function(a,b){var c=mb[b]||r.find.attr;mb[b]=function(a,b,d){var e,f,g=b.toLowerCase();return d||(f=mb[g],mb[g]=e,e=null!=c(a,b,d)?g:null,mb[g]=f),e}});var nb=/^(?:input|select|textarea|button)$/i,ob=/^(?:a|area)$/i;r.fn.extend({prop:function(a,b){return T(this,r.prop,a,b,arguments.length>1)},removeProp:function(a){return this.each(function(){delete this[r.propFix[a]||a]})}}),r.extend({prop:function(a,b,c){var d,e,f=a.nodeType;if(3!==f&&8!==f&&2!==f)return 1===f&&r.isXMLDoc(a)||(b=r.propFix[b]||b,e=r.propHooks[b]),void 0!==c?e&&"set"in e&&void 0!==(d=e.set(a,c,b))?d:a[b]=c:e&&"get"in e&&null!==(d=e.get(a,b))?d:a[b]},propHooks:{tabIndex:{get:function(a){var b=r.find.attr(a,"tabindex");return b?parseInt(b,10):nb.test(a.nodeName)||ob.test(a.nodeName)&&a.href?0:-1}}},propFix:{"for":"htmlFor","class":"className"}}),o.optSelected||(r.propHooks.selected={get:function(a){var b=a.parentNode;return b&&b.parentNode&&b.parentNode.selectedIndex,null},set:function(a){var b=a.parentNode;b&&(b.selectedIndex,b.parentNode&&b.parentNode.selectedIndex)}}),r.each(["tabIndex","readOnly","maxLength","cellSpacing","cellPadding","rowSpan","colSpan","useMap","frameBorder","contentEditable"],function(){r.propFix[this.toLowerCase()]=this});function pb(a){var b=a.match(L)||[];return b.join(" ")}function qb(a){return a.getAttribute&&a.getAttribute("class")||""}r.fn.extend({addClass:function(a){var b,c,d,e,f,g,h,i=0;if(r.isFunction(a))return this.each(function(b){r(this).addClass(a.call(this,b,qb(this)))});if("string"==typeof a&&a){b=a.match(L)||[];while(c=this[i++])if(e=qb(c),d=1===c.nodeType&&" "+pb(e)+" "){g=0;while(f=b[g++])d.indexOf(" "+f+" ")<0&&(d+=f+" ");h=pb(d),e!==h&&c.setAttribute("class",h)}}return this},removeClass:function(a){var b,c,d,e,f,g,h,i=0;if(r.isFunction(a))return this.each(function(b){r(this).removeClass(a.call(this,b,qb(this)))});if(!arguments.length)return this.attr("class","");if("string"==typeof a&&a){b=a.match(L)||[];while(c=this[i++])if(e=qb(c),d=1===c.nodeType&&" "+pb(e)+" "){g=0;while(f=b[g++])while(d.indexOf(" "+f+" ")>-1)d=d.replace(" "+f+" "," ");h=pb(d),e!==h&&c.setAttribute("class",h)}}return this},toggleClass:function(a,b){var c=typeof a;return"boolean"==typeof b&&"string"===c?b?this.addClass(a):this.removeClass(a):r.isFunction(a)?this.each(function(c){r(this).toggleClass(a.call(this,c,qb(this),b),b)}):this.each(function(){var b,d,e,f;if("string"===c){d=0,e=r(this),f=a.match(L)||[];while(b=f[d++])e.hasClass(b)?e.removeClass(b):e.addClass(b)}else void 0!==a&&"boolean"!==c||(b=qb(this),b&&W.set(this,"__className__",b),this.setAttribute&&this.setAttribute("class",b||a===!1?"":W.get(this,"__className__")||""))})},hasClass:function(a){var b,c,d=0;b=" "+a+" ";while(c=this[d++])if(1===c.nodeType&&(" "+pb(qb(c))+" ").indexOf(b)>-1)return!0;return!1}});var rb=/\r/g;r.fn.extend({val:function(a){var b,c,d,e=this[0];{if(arguments.length)return d=r.isFunction(a),this.each(function(c){var e;1===this.nodeType&&(e=d?a.call(this,c,r(this).val()):a,null==e?e="":"number"==typeof e?e+="":Array.isArray(e)&&(e=r.map(e,function(a){return null==a?"":a+""})),b=r.valHooks[this.type]||r.valHooks[this.nodeName.toLowerCase()],b&&"set"in b&&void 0!==b.set(this,e,"value")||(this.value=e))});if(e)return b=r.valHooks[e.type]||r.valHooks[e.nodeName.toLowerCase()],b&&"get"in b&&void 0!==(c=b.get(e,"value"))?c:(c=e.value,"string"==typeof c?c.replace(rb,""):null==c?"":c)}}}),r.extend({valHooks:{option:{get:function(a){var b=r.find.attr(a,"value");return null!=b?b:pb(r.text(a))}},select:{get:function(a){var b,c,d,e=a.options,f=a.selectedIndex,g="select-one"===a.type,h=g?null:[],i=g?f+1:e.length;for(d=f<0?i:g?f:0;d<i;d++)if(c=e[d],(c.selected||d===f)&&!c.disabled&&(!c.parentNode.disabled||!B(c.parentNode,"optgroup"))){if(b=r(c).val(),g)return b;h.push(b)}return h},set:function(a,b){var c,d,e=a.options,f=r.makeArray(b),g=e.length;while(g--)d=e[g],(d.selected=r.inArray(r.valHooks.option.get(d),f)>-1)&&(c=!0);return c||(a.selectedIndex=-1),f}}}}),r.each(["radio","checkbox"],function(){r.valHooks[this]={set:function(a,b){if(Array.isArray(b))return a.checked=r.inArray(r(a).val(),b)>-1}},o.checkOn||(r.valHooks[this].get=function(a){return null===a.getAttribute("value")?"on":a.value})});var sb=/^(?:focusinfocus|focusoutblur)$/;r.extend(r.event,{trigger:function(b,c,e,f){var g,h,i,j,k,m,n,o=[e||d],p=l.call(b,"type")?b.type:b,q=l.call(b,"namespace")?b.namespace.split("."):[];if(h=i=e=e||d,3!==e.nodeType&&8!==e.nodeType&&!sb.test(p+r.event.triggered)&&(p.indexOf(".")>-1&&(q=p.split("."),p=q.shift(),q.sort()),k=p.indexOf(":")<0&&"on"+p,b=b[r.expando]?b:new r.Event(p,"object"==typeof b&&b),b.isTrigger=f?2:3,b.namespace=q.join("."),b.rnamespace=b.namespace?new RegExp("(^|\\.)"+q.join("\\.(?:.*\\.|)")+"(\\.|$)"):null,b.result=void 0,b.target||(b.target=e),c=null==c?[b]:r.makeArray(c,[b]),n=r.event.special[p]||{},f||!n.trigger||n.trigger.apply(e,c)!==!1)){if(!f&&!n.noBubble&&!r.isWindow(e)){for(j=n.delegateType||p,sb.test(j+p)||(h=h.parentNode);h;h=h.parentNode)o.push(h),i=h;i===(e.ownerDocument||d)&&o.push(i.defaultView||i.parentWindow||a)}g=0;while((h=o[g++])&&!b.isPropagationStopped())b.type=g>1?j:n.bindType||p,m=(W.get(h,"events")||{})[b.type]&&W.get(h,"handle"),m&&m.apply(h,c),m=k&&h[k],m&&m.apply&&U(h)&&(b.result=m.apply(h,c),b.result===!1&&b.preventDefault());return b.type=p,f||b.isDefaultPrevented()||n._default&&n._default.apply(o.pop(),c)!==!1||!U(e)||k&&r.isFunction(e[p])&&!r.isWindow(e)&&(i=e[k],i&&(e[k]=null),r.event.triggered=p,e[p](),r.event.triggered=void 0,i&&(e[k]=i)),b.result}},simulate:function(a,b,c){var d=r.extend(new r.Event,c,{type:a,isSimulated:!0});r.event.trigger(d,null,b)}}),r.fn.extend({trigger:function(a,b){return this.each(function(){r.event.trigger(a,b,this)})},triggerHandler:function(a,b){var c=this[0];if(c)return r.event.trigger(a,b,c,!0)}}),r.each("blur focus focusin focusout resize scroll click dblclick mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave change select submit keydown keypress keyup contextmenu".split(" "),function(a,b){r.fn[b]=function(a,c){return arguments.length>0?this.on(b,null,a,c):this.trigger(b)}}),r.fn.extend({hover:function(a,b){return this.mouseenter(a).mouseleave(b||a)}}),o.focusin="onfocusin"in a,o.focusin||r.each({focus:"focusin",blur:"focusout"},function(a,b){var c=function(a){r.event.simulate(b,a.target,r.event.fix(a))};r.event.special[b]={setup:function(){var d=this.ownerDocument||this,e=W.access(d,b);e||d.addEventListener(a,c,!0),W.access(d,b,(e||0)+1)},teardown:function(){var d=this.ownerDocument||this,e=W.access(d,b)-1;e?W.access(d,b,e):(d.removeEventListener(a,c,!0),W.remove(d,b))}}});var tb=a.location,ub=r.now(),vb=/\?/;r.parseXML=function(b){var c;if(!b||"string"!=typeof b)return null;try{c=(new a.DOMParser).parseFromString(b,"text/xml")}catch(d){c=void 0}return c&&!c.getElementsByTagName("parsererror").length||r.error("Invalid XML: "+b),c};var wb=/\[\]$/,xb=/\r?\n/g,yb=/^(?:submit|button|image|reset|file)$/i,zb=/^(?:input|select|textarea|keygen)/i;function Ab(a,b,c,d){var e;if(Array.isArray(b))r.each(b,function(b,e){c||wb.test(a)?d(a,e):Ab(a+"["+("object"==typeof e&&null!=e?b:"")+"]",e,c,d)});else if(c||"object"!==r.type(b))d(a,b);else for(e in b)Ab(a+"["+e+"]",b[e],c,d)}r.param=function(a,b){var c,d=[],e=function(a,b){var c=r.isFunction(b)?b():b;d[d.length]=encodeURIComponent(a)+"="+encodeURIComponent(null==c?"":c)};if(Array.isArray(a)||a.jquery&&!r.isPlainObject(a))r.each(a,function(){e(this.name,this.value)});else for(c in a)Ab(c,a[c],b,e);return d.join("&")},r.fn.extend({serialize:function(){return r.param(this.serializeArray())},serializeArray:function(){return this.map(function(){var a=r.prop(this,"elements");return a?r.makeArray(a):this}).filter(function(){var a=this.type;return this.name&&!r(this).is(":disabled")&&zb.test(this.nodeName)&&!yb.test(a)&&(this.checked||!ja.test(a))}).map(function(a,b){var c=r(this).val();return null==c?null:Array.isArray(c)?r.map(c,function(a){return{name:b.name,value:a.replace(xb,"\r\n")}}):{name:b.name,value:c.replace(xb,"\r\n")}}).get()}});var Bb=/%20/g,Cb=/#.*$/,Db=/([?&])_=[^&]*/,Eb=/^(.*?):[ \t]*([^\r\n]*)$/gm,Fb=/^(?:about|app|app-storage|.+-extension|file|res|widget):$/,Gb=/^(?:GET|HEAD)$/,Hb=/^\/\//,Ib={},Jb={},Kb="*/".concat("*"),Lb=d.createElement("a");Lb.href=tb.href;function Mb(a){return function(b,c){"string"!=typeof b&&(c=b,b="*");var d,e=0,f=b.toLowerCase().match(L)||[];if(r.isFunction(c))while(d=f[e++])"+"===d[0]?(d=d.slice(1)||"*",(a[d]=a[d]||[]).unshift(c)):(a[d]=a[d]||[]).push(c)}}function Nb(a,b,c,d){var e={},f=a===Jb;function g(h){var i;return e[h]=!0,r.each(a[h]||[],function(a,h){var j=h(b,c,d);return"string"!=typeof j||f||e[j]?f?!(i=j):void 0:(b.dataTypes.unshift(j),g(j),!1)}),i}return g(b.dataTypes[0])||!e["*"]&&g("*")}function Ob(a,b){var c,d,e=r.ajaxSettings.flatOptions||{};for(c in b)void 0!==b[c]&&((e[c]?a:d||(d={}))[c]=b[c]);return d&&r.extend(!0,a,d),a}function Pb(a,b,c){var d,e,f,g,h=a.contents,i=a.dataTypes;while("*"===i[0])i.shift(),void 0===d&&(d=a.mimeType||b.getResponseHeader("Content-Type"));if(d)for(e in h)if(h[e]&&h[e].test(d)){i.unshift(e);break}if(i[0]in c)f=i[0];else{for(e in c){if(!i[0]||a.converters[e+" "+i[0]]){f=e;break}g||(g=e)}f=f||g}if(f)return f!==i[0]&&i.unshift(f),c[f]}function Qb(a,b,c,d){var e,f,g,h,i,j={},k=a.dataTypes.slice();if(k[1])for(g in a.converters)j[g.toLowerCase()]=a.converters[g];f=k.shift();while(f)if(a.responseFields[f]&&(c[a.responseFields[f]]=b),!i&&d&&a.dataFilter&&(b=a.dataFilter(b,a.dataType)),i=f,f=k.shift())if("*"===f)f=i;else if("*"!==i&&i!==f){if(g=j[i+" "+f]||j["* "+f],!g)for(e in j)if(h=e.split(" "),h[1]===f&&(g=j[i+" "+h[0]]||j["* "+h[0]])){g===!0?g=j[e]:j[e]!==!0&&(f=h[0],k.unshift(h[1]));break}if(g!==!0)if(g&&a["throws"])b=g(b);else try{b=g(b)}catch(l){return{state:"parsererror",error:g?l:"No conversion from "+i+" to "+f}}}return{state:"success",data:b}}r.extend({active:0,lastModified:{},etag:{},ajaxSettings:{url:tb.href,type:"GET",isLocal:Fb.test(tb.protocol),global:!0,processData:!0,async:!0,contentType:"application/x-www-form-urlencoded; charset=UTF-8",accepts:{"*":Kb,text:"text/plain",html:"text/html",xml:"application/xml, text/xml",json:"application/json, text/javascript"},contents:{xml:/\bxml\b/,html:/\bhtml/,json:/\bjson\b/},responseFields:{xml:"responseXML",text:"responseText",json:"responseJSON"},converters:{"* text":String,"text html":!0,"text json":JSON.parse,"text xml":r.parseXML},flatOptions:{url:!0,context:!0}},ajaxSetup:function(a,b){return b?Ob(Ob(a,r.ajaxSettings),b):Ob(r.ajaxSettings,a)},ajaxPrefilter:Mb(Ib),ajaxTransport:Mb(Jb),ajax:function(b,c){"object"==typeof b&&(c=b,b=void 0),c=c||{};var e,f,g,h,i,j,k,l,m,n,o=r.ajaxSetup({},c),p=o.context||o,q=o.context&&(p.nodeType||p.jquery)?r(p):r.event,s=r.Deferred(),t=r.Callbacks("once memory"),u=o.statusCode||{},v={},w={},x="canceled",y={readyState:0,getResponseHeader:function(a){var b;if(k){if(!h){h={};while(b=Eb.exec(g))h[b[1].toLowerCase()]=b[2]}b=h[a.toLowerCase()]}return null==b?null:b},getAllResponseHeaders:function(){return k?g:null},setRequestHeader:function(a,b){return null==k&&(a=w[a.toLowerCase()]=w[a.toLowerCase()]||a,v[a]=b),this},overrideMimeType:function(a){return null==k&&(o.mimeType=a),this},statusCode:function(a){var b;if(a)if(k)y.always(a[y.status]);else for(b in a)u[b]=[u[b],a[b]];return this},abort:function(a){var b=a||x;return e&&e.abort(b),A(0,b),this}};if(s.promise(y),o.url=((b||o.url||tb.href)+"").replace(Hb,tb.protocol+"//"),o.type=c.method||c.type||o.method||o.type,o.dataTypes=(o.dataType||"*").toLowerCase().match(L)||[""],null==o.crossDomain){j=d.createElement("a");try{j.href=o.url,j.href=j.href,o.crossDomain=Lb.protocol+"//"+Lb.host!=j.protocol+"//"+j.host}catch(z){o.crossDomain=!0}}if(o.data&&o.processData&&"string"!=typeof o.data&&(o.data=r.param(o.data,o.traditional)),Nb(Ib,o,c,y),k)return y;l=r.event&&o.global,l&&0===r.active++&&r.event.trigger("ajaxStart"),o.type=o.type.toUpperCase(),o.hasContent=!Gb.test(o.type),f=o.url.replace(Cb,""),o.hasContent?o.data&&o.processData&&0===(o.contentType||"").indexOf("application/x-www-form-urlencoded")&&(o.data=o.data.replace(Bb,"+")):(n=o.url.slice(f.length),o.data&&(f+=(vb.test(f)?"&":"?")+o.data,delete o.data),o.cache===!1&&(f=f.replace(Db,"$1"),n=(vb.test(f)?"&":"?")+"_="+ub++ +n),o.url=f+n),o.ifModified&&(r.lastModified[f]&&y.setRequestHeader("If-Modified-Since",r.lastModified[f]),r.etag[f]&&y.setRequestHeader("If-None-Match",r.etag[f])),(o.data&&o.hasContent&&o.contentType!==!1||c.contentType)&&y.setRequestHeader("Content-Type",o.contentType),y.setRequestHeader("Accept",o.dataTypes[0]&&o.accepts[o.dataTypes[0]]?o.accepts[o.dataTypes[0]]+("*"!==o.dataTypes[0]?", "+Kb+"; q=0.01":""):o.accepts["*"]);for(m in o.headers)y.setRequestHeader(m,o.headers[m]);if(o.beforeSend&&(o.beforeSend.call(p,y,o)===!1||k))return y.abort();if(x="abort",t.add(o.complete),y.done(o.success),y.fail(o.error),e=Nb(Jb,o,c,y)){if(y.readyState=1,l&&q.trigger("ajaxSend",[y,o]),k)return y;o.async&&o.timeout>0&&(i=a.setTimeout(function(){y.abort("timeout")},o.timeout));try{k=!1,e.send(v,A)}catch(z){if(k)throw z;A(-1,z)}}else A(-1,"No Transport");function A(b,c,d,h){var j,m,n,v,w,x=c;k||(k=!0,i&&a.clearTimeout(i),e=void 0,g=h||"",y.readyState=b>0?4:0,j=b>=200&&b<300||304===b,d&&(v=Pb(o,y,d)),v=Qb(o,v,y,j),j?(o.ifModified&&(w=y.getResponseHeader("Last-Modified"),w&&(r.lastModified[f]=w),w=y.getResponseHeader("etag"),w&&(r.etag[f]=w)),204===b||"HEAD"===o.type?x="nocontent":304===b?x="notmodified":(x=v.state,m=v.data,n=v.error,j=!n)):(n=x,!b&&x||(x="error",b<0&&(b=0))),y.status=b,y.statusText=(c||x)+"",j?s.resolveWith(p,[m,x,y]):s.rejectWith(p,[y,x,n]),y.statusCode(u),u=void 0,l&&q.trigger(j?"ajaxSuccess":"ajaxError",[y,o,j?m:n]),t.fireWith(p,[y,x]),l&&(q.trigger("ajaxComplete",[y,o]),--r.active||r.event.trigger("ajaxStop")))}return y},getJSON:function(a,b,c){return r.get(a,b,c,"json")},getScript:function(a,b){return r.get(a,void 0,b,"script")}}),r.each(["get","post"],function(a,b){r[b]=function(a,c,d,e){return r.isFunction(c)&&(e=e||d,d=c,c=void 0),r.ajax(r.extend({url:a,type:b,dataType:e,data:c,success:d},r.isPlainObject(a)&&a))}}),r._evalUrl=function(a){return r.ajax({url:a,type:"GET",dataType:"script",cache:!0,async:!1,global:!1,"throws":!0})},r.fn.extend({wrapAll:function(a){var b;return this[0]&&(r.isFunction(a)&&(a=a.call(this[0])),b=r(a,this[0].ownerDocument).eq(0).clone(!0),this[0].parentNode&&b.insertBefore(this[0]),b.map(function(){var a=this;while(a.firstElementChild)a=a.firstElementChild;return a}).append(this)),this},wrapInner:function(a){return r.isFunction(a)?this.each(function(b){r(this).wrapInner(a.call(this,b))}):this.each(function(){var b=r(this),c=b.contents();c.length?c.wrapAll(a):b.append(a)})},wrap:function(a){var b=r.isFunction(a);return this.each(function(c){r(this).wrapAll(b?a.call(this,c):a)})},unwrap:function(a){return this.parent(a).not("body").each(function(){r(this).replaceWith(this.childNodes)}),this}}),r.expr.pseudos.hidden=function(a){return!r.expr.pseudos.visible(a)},r.expr.pseudos.visible=function(a){return!!(a.offsetWidth||a.offsetHeight||a.getClientRects().length)},r.ajaxSettings.xhr=function(){try{return new a.XMLHttpRequest}catch(b){}};var Rb={0:200,1223:204},Sb=r.ajaxSettings.xhr();o.cors=!!Sb&&"withCredentials"in Sb,o.ajax=Sb=!!Sb,r.ajaxTransport(function(b){var c,d;if(o.cors||Sb&&!b.crossDomain)return{send:function(e,f){var g,h=b.xhr();if(h.open(b.type,b.url,b.async,b.username,b.password),b.xhrFields)for(g in b.xhrFields)h[g]=b.xhrFields[g];b.mimeType&&h.overrideMimeType&&h.overrideMimeType(b.mimeType),b.crossDomain||e["X-Requested-With"]||(e["X-Requested-With"]="XMLHttpRequest");for(g in e)h.setRequestHeader(g,e[g]);c=function(a){return function(){c&&(c=d=h.onload=h.onerror=h.onabort=h.onreadystatechange=null,"abort"===a?h.abort():"error"===a?"number"!=typeof h.status?f(0,"error"):f(h.status,h.statusText):f(Rb[h.status]||h.status,h.statusText,"text"!==(h.responseType||"text")||"string"!=typeof h.responseText?{binary:h.response}:{text:h.responseText},h.getAllResponseHeaders()))}},h.onload=c(),d=h.onerror=c("error"),void 0!==h.onabort?h.onabort=d:h.onreadystatechange=function(){4===h.readyState&&a.setTimeout(function(){c&&d()})},c=c("abort");try{h.send(b.hasContent&&b.data||null)}catch(i){if(c)throw i}},abort:function(){c&&c()}}}),r.ajaxPrefilter(function(a){a.crossDomain&&(a.contents.script=!1)}),r.ajaxSetup({accepts:{script:"text/javascript, application/javascript, application/ecmascript, application/x-ecmascript"},contents:{script:/\b(?:java|ecma)script\b/},converters:{"text script":function(a){return r.globalEval(a),a}}}),r.ajaxPrefilter("script",function(a){void 0===a.cache&&(a.cache=!1),a.crossDomain&&(a.type="GET")}),r.ajaxTransport("script",function(a){if(a.crossDomain){var b,c;return{send:function(e,f){b=r("<script>").prop({charset:a.scriptCharset,src:a.url}).on("load error",c=function(a){b.remove(),c=null,a&&f("error"===a.type?404:200,a.type)}),d.head.appendChild(b[0])},abort:function(){c&&c()}}}});var Tb=[],Ub=/(=)\?(?=&|$)|\?\?/;r.ajaxSetup({jsonp:"callback",jsonpCallback:function(){var a=Tb.pop()||r.expando+"_"+ub++;return this[a]=!0,a}}),r.ajaxPrefilter("json jsonp",function(b,c,d){var e,f,g,h=b.jsonp!==!1&&(Ub.test(b.url)?"url":"string"==typeof b.data&&0===(b.contentType||"").indexOf("application/x-www-form-urlencoded")&&Ub.test(b.data)&&"data");if(h||"jsonp"===b.dataTypes[0])return e=b.jsonpCallback=r.isFunction(b.jsonpCallback)?b.jsonpCallback():b.jsonpCallback,h?b[h]=b[h].replace(Ub,"$1"+e):b.jsonp!==!1&&(b.url+=(vb.test(b.url)?"&":"?")+b.jsonp+"="+e),b.converters["script json"]=function(){return g||r.error(e+" was not called"),g[0]},b.dataTypes[0]="json",f=a[e],a[e]=function(){g=arguments},d.always(function(){void 0===f?r(a).removeProp(e):a[e]=f,b[e]&&(b.jsonpCallback=c.jsonpCallback,Tb.push(e)),g&&r.isFunction(f)&&f(g[0]),g=f=void 0}),"script"}),o.createHTMLDocument=function(){var a=d.implementation.createHTMLDocument("").body;return a.innerHTML="<form></form><form></form>",2===a.childNodes.length}(),r.parseHTML=function(a,b,c){if("string"!=typeof a)return[];"boolean"==typeof b&&(c=b,b=!1);var e,f,g;return b||(o.createHTMLDocument?(b=d.implementation.createHTMLDocument(""),e=b.createElement("base"),e.href=d.location.href,b.head.appendChild(e)):b=d),f=C.exec(a),g=!c&&[],f?[b.createElement(f[1])]:(f=qa([a],b,g),g&&g.length&&r(g).remove(),r.merge([],f.childNodes))},r.fn.load=function(a,b,c){var d,e,f,g=this,h=a.indexOf(" ");return h>-1&&(d=pb(a.slice(h)),a=a.slice(0,h)),r.isFunction(b)?(c=b,b=void 0):b&&"object"==typeof b&&(e="POST"),g.length>0&&r.ajax({url:a,type:e||"GET",dataType:"html",data:b}).done(function(a){f=arguments,g.html(d?r("<div>").append(r.parseHTML(a)).find(d):a)}).always(c&&function(a,b){g.each(function(){c.apply(this,f||[a.responseText,b,a])})}),this},r.each(["ajaxStart","ajaxStop","ajaxComplete","ajaxError","ajaxSuccess","ajaxSend"],function(a,b){r.fn[b]=function(a){return this.on(b,a)}}),r.expr.pseudos.animated=function(a){return r.grep(r.timers,function(b){return a===b.elem}).length},r.offset={setOffset:function(a,b,c){var d,e,f,g,h,i,j,k=r.css(a,"position"),l=r(a),m={};"static"===k&&(a.style.position="relative"),h=l.offset(),f=r.css(a,"top"),i=r.css(a,"left"),j=("absolute"===k||"fixed"===k)&&(f+i).indexOf("auto")>-1,j?(d=l.position(),g=d.top,e=d.left):(g=parseFloat(f)||0,e=parseFloat(i)||0),r.isFunction(b)&&(b=b.call(a,c,r.extend({},h))),null!=b.top&&(m.top=b.top-h.top+g),null!=b.left&&(m.left=b.left-h.left+e),"using"in b?b.using.call(a,m):l.css(m)}},r.fn.extend({offset:function(a){if(arguments.length)return void 0===a?this:this.each(function(b){r.offset.setOffset(this,a,b)});var b,c,d,e,f=this[0];if(f)return f.getClientRects().length?(d=f.getBoundingClientRect(),b=f.ownerDocument,c=b.documentElement,e=b.defaultView,{top:d.top+e.pageYOffset-c.clientTop,left:d.left+e.pageXOffset-c.clientLeft}):{top:0,left:0}},position:function(){if(this[0]){var a,b,c=this[0],d={top:0,left:0};return"fixed"===r.css(c,"position")?b=c.getBoundingClientRect():(a=this.offsetParent(),b=this.offset(),B(a[0],"html")||(d=a.offset()),d={top:d.top+r.css(a[0],"borderTopWidth",!0),left:d.left+r.css(a[0],"borderLeftWidth",!0)}),{top:b.top-d.top-r.css(c,"marginTop",!0),left:b.left-d.left-r.css(c,"marginLeft",!0)}}},offsetParent:function(){return this.map(function(){var a=this.offsetParent;while(a&&"static"===r.css(a,"position"))a=a.offsetParent;return a||ra})}}),r.each({scrollLeft:"pageXOffset",scrollTop:"pageYOffset"},function(a,b){var c="pageYOffset"===b;r.fn[a]=function(d){return T(this,function(a,d,e){var f;return r.isWindow(a)?f=a:9===a.nodeType&&(f=a.defaultView),void 0===e?f?f[b]:a[d]:void(f?f.scrollTo(c?f.pageXOffset:e,c?e:f.pageYOffset):a[d]=e)},a,d,arguments.length)}}),r.each(["top","left"],function(a,b){r.cssHooks[b]=Pa(o.pixelPosition,function(a,c){if(c)return c=Oa(a,b),Ma.test(c)?r(a).position()[b]+"px":c})}),r.each({Height:"height",Width:"width"},function(a,b){r.each({padding:"inner"+a,content:b,"":"outer"+a},function(c,d){r.fn[d]=function(e,f){var g=arguments.length&&(c||"boolean"!=typeof e),h=c||(e===!0||f===!0?"margin":"border");return T(this,function(b,c,e){var f;return r.isWindow(b)?0===d.indexOf("outer")?b["inner"+a]:b.document.documentElement["client"+a]:9===b.nodeType?(f=b.documentElement,Math.max(b.body["scroll"+a],f["scroll"+a],b.body["offset"+a],f["offset"+a],f["client"+a])):void 0===e?r.css(b,c,h):r.style(b,c,e,h)},b,g?e:void 0,g)}})}),r.fn.extend({bind:function(a,b,c){return this.on(a,null,b,c)},unbind:function(a,b){return this.off(a,null,b)},delegate:function(a,b,c,d){return this.on(b,a,c,d)},undelegate:function(a,b,c){return 1===arguments.length?this.off(a,"**"):this.off(b,a||"**",c)}}),r.holdReady=function(a){a?r.readyWait++:r.ready(!0)},r.isArray=Array.isArray,r.parseJSON=JSON.parse,r.nodeName=B,"function"==typeof define&&define.amd&&define("jquery",[],function(){return r});var Vb=a.jQuery,Wb=a.$;return r.noConflict=function(b){return a.$===r&&(a.$=Wb),b&&a.jQuery===r&&(a.jQuery=Vb),r},b||(a.jQuery=a.$=r),r});


</script>


			<!-- If the date exists we are on a post -->
			
				<script>
  function defer(t){window.jQuery?t():setTimeout(function(){defer(t)},5)}"function"!=typeof Object.create&&(Object.create=function(t){function n(){}return n.prototype=t,new n}),defer(function(){!function(t,n,a,e){"use strict"
var i={init:function(n,a){var e=this
e.elem=a,e.$elem=t(a),e.opt=t.extend({},this.opt,n),e.headers=e.$elem.find(e.opt.headers),e.previous=0,0!==e.headers.length&&(e.first=parseInt(e.headers.prop("nodeName").substring(1),null)),e.build()},opt:{navigation:".anchorific",headers:"h1, h2, h3, h4, h5, h6",speed:200,anchorClass:"anchor",anchorText:"#",top:".top",spy:!0,position:"append",spyOffset:!0},build:function(){var n,a=this,e=function(){}
a.opt.navigation&&(t(a.opt.navigation).append("<ul />"),a.previous=t(a.opt.navigation).find("ul").last(),e=function(t){return a.navigations(t)})
for(var i=0;i<a.headers.length;i++)n=a.headers.eq(i),e(n),a.anchor(n)
a.opt.spy&&a.spy(),a.opt.top&&a.back()},navigations:function(n){var a,i,o,r=this,s=r.name(n)
n.attr("id")!==e&&(s=n.attr("id")),a=t("<a />").attr("href","#"+s).text(n.text()),i=t("<li />").append(a),o=parseInt(n.prop("nodeName").substring(1),null),i.attr("data-tag",o),r.subheadings(o,i),r.first=o},subheadings:function(n,a){var e=this,i=(t(e.opt.navigation).find("ul"),t(e.opt.navigation).find("li"))
n===e.first?e.previous.append(a):n>e.first?(i.last().append("<ul />"),t(e.opt.navigation).find("ul").last().append(a),e.previous=a.parent()):(t("li[data-tag="+n+"]").last().parent().append(a),e.previous=a.parent())},name:function(t){var n=t.text().replace(/[^\w\s]/gi,"").replace(/\s+/g,"-").toLowerCase()
return n},anchor:function(t){var n,a=this,i=a.name(t)
a.opt.anchorText,a.opt.anchorClass
t.attr("id")===e&&t.attr("id",i),n=t.attr("id"),t.html('<a class="anchor" href=#'+n+">"+t.html()+"</a>")},back:function(){var n=this,a=t("body, html"),e=t(n.opt.top)
e.on("click",function(t){t.preventDefault(),a.animate({scrollTop:0},n.opt.speed)})},top:function(n){var a,e=this,i=e.opt.top
i!==!1&&(a=t(n).scrollTop()>200?t(i).fadeIn():t(i).fadeOut())},spy:function(){var a,i,o,r=this
t(n).scroll(function(s){r.top(this),a=r.headers.map(function(a){return t(this).offset().top-t(n).scrollTop()<r.opt.spyOffset?this:e}),a=t(a).eq(a.length-1),a&&a.length&&(i=t('li:has(a[href="#'+a.attr("id")+'"])'),o!==e&&o.removeClass("active"),i.addClass("active"),o=i)})}}
t.fn.anchorific=function(n){return this.each(function(){if(!t.data(this,"anchorific")){var a=Object.create(i)
a.init(n,this),t.data(this,"anchorific",a)}})}}(jQuery,window,document)})


  
  
    












var tipuesearch = {"pages": [

  
  
  
  {
    "title": "Test Post",
    "text": "Not much here. A few lines of text. Heading level 2 Bold fun test(): Int { return 0 }",
    "tags": "Notes Haskell Functional",
    "url": "/Test-Post"
  },

  
  
  
  {
    "title": "Haskell Notes",
    "text": "This is a collection of notes on Haskell, primarily condensed from learnyouahaskell Purely functional languages In a purely functional language, functions can have no side effects. This means that if a function is called twice with the same parameters, it is guaranteed to return the same result. This is called referential transparency and allows the compiler to reason about program behaviour, as well as proof that a function is correct. Lazy evaluation Functions will not be called and calculations will not be performed until a result is required. Programs can be thought of as a series of transformations on data. This allows structures such as infinite lists, which are only evaluated when required. Example: An infinite list of natural numbers can be generated as follows &gt; let naturals = 1 : map (+1) naturals When we want to use these values we can write &gt; take 10 naturals &gt; [1,2,3,4,5,6,7,8,9,10] We could more succinctly use the notation for a range &gt; let naturals = [1..] This gives the same infinite range as before. Static typing Haskell is a statically typed language, meaning that when it is compiled the compiler knows the type of every value. Type inference Haskell, along with many other languages, use a system of type inference. This means that when writing a = 2 + 3 it is not necessary to inform the compiler that a is a numeric value. If a function takes two parameters and adds them together, their types do not need to be stated explicitly. The function will can be executed with any two parameters that act like numbers. Basic syntax Examples: Arithmetic &gt; 3 + 16 &gt; 19 &gt; 27 * 53 &gt; 1431 &gt; 1314 - 133 &gt; 1181 &gt; 7 / 2 &gt; 3.5 When multiple operators are used on the same line, operator precedence and parentheses are respected. Negation When value are negated, they must be surrounded by parentheses. &gt; 5 * -3 The expression above will give a Precedence parsing error. Instead 5 * (-3) should be written Examples: Boolean algebra Operator Symbol And &amp;&amp; Or || Not not Equality == Inequality /= &gt; True &amp;&amp; False &gt; False &gt; True &amp;&amp; not False &gt; True &gt; False || True &gt; True &gt; not (True &amp;&amp; True) &gt; False &gt; True == False &gt; False &gt; 5 == 5 &gt; True &gt; 1 == 0 &gt; False &gt; 5 /= 5 &gt; False &gt; 5 /= 4 &gt; \"string\" == \"string\" &gt; True Functions All of the operations performed so far have been functions, specifically infix functions. Functions are usually prefix functions, which take their arguments after the function name. Infix functions are different in that the arguments surround the function name. Example: The successor function &gt; succ 9 &gt; 10 The successor function takes anything which has a defined successor, and returns that successor. The min and max functions both take two parameters &gt; min 10 11 &gt; 10 &gt; max 100 1000 &gt; 1000 &gt; min 1.5 1.4 &gt; 1.4 Function application as seen above has the highest precedence This means that the following statements are equivalent &gt; succ 9 + max 5 4 + 1 &gt; (succ 9) + (max 5 4) + 1 Suppose we want the successor to the product of two numbers, a, and b. As succ has the highest precedence writing succ a * b would first evaluate succ a and then evaluate its product with b. Instead we must right succ (a * b). Writing functions as infix If a function takes two parameters, it can be called as an infix function by surrounding it with backticks. div takes two integers and performs integral division. &gt; 92 `div` 9 &gt; 10 Function call syntax Many other languages require parentheses to denote function application. In Haskell, spaces are used instead. Function definition doubleValue x = x + x The function above consists of a function name, followed by parameters separated by spaces. After the = the function body is defined. This function will work on any numeric type. &gt; doubleValue 2 &gt; 4 &gt; doubleValue 2.5 &gt; 5 doubleSum x y = x * 2 + y * 2 This function takes two numeric parameters, doubles each of them, and returns the sum of the two doubled values. &gt; doubleSum 2 3 &gt; 10 &gt; doubleSum 5.5 7 &gt; 25.0 The function can take two numeric types, one of which is floating point and the other an integer. This will result in the integer type being converted to a floating point value. The function could also be defined in terms of the first function, doubleValue. doubleSum x y = doubleValue x + doubleValue y Function definitions do not have to be in any particular order, doubleSum could be defined before doubleValue. Conditional expressions doubleSmallNumber x = if x &gt; 100 then x else x * 2 The function doubleSmallNumber doubles the parameter x if x&lt;=100, otherwise it returns the original value of x. An if statement in Haskell is an expression, a piece of code which returns a value. Because the else is mandatory, an if statement will always return some value. If we wanted to add one to the return value in doubleSmallNumber we could write doubleSmallNumber' x = (if x &gt; 100 then x else x * 2) + 1 Function naming The function above doubleSmallNumber' has a ' character as its last character. This is a valid character in Haskell function names and is often used to denote a stricter, non-lazy version of a function, or a slightly modified version. Haskell functions cannot begin with uppercase characters. When a function does not take any parameters, it is called a definition or a name. Lists Lists are defined as comma separated lists of values within a set of square brackets []. A string is just syntax for a list of characters. As strings are backed by lists of characters, we can apply list functions to them. String and list concatenation Strings are concatenated with the ++ operator. &gt; \"hello\" ++ \" \" ++ \"world\" &gt; \"hello world\" This operator is used more widely for list concatenation. &gt; [1,2,3] ++ [4,5,6] &gt; [1,2,3,4,5,6] When two lists are added together, even when a singleton is added to the end of a list, Haskell has to walk through the whole list on the left side of the ++ operator which can be slow when dealing with large lists. Prepending to a list is effectively instantaneous. It is done with the : operator. &gt; 'A' : \"BC\" &gt; \"ABC\" &gt; 5 : [4,3,2,1] &gt; [5,4,3,2,1] Note that ++ takes two lists. This means that any singleton value being appended to a list must be a list containing one item, such as [5], rather than just 5. A list definition such as [1,2,3] is actually just syntactic sugar for 1:2:3:[], where [] is an empty list. List indexing As with any sensible language, Haskell lists are indexed from 0. The !! operator is used to read an element from a list at a given index. &gt; [1,2,3,4,5] !! 2 &gt; 3 &gt; \"hello\" !! 1 &gt; 'e' Attempting to access an index which does not exist will raise an error. Nested lists Lists can be infinitely nested within memory constraints. &gt; let b = [[1,2,3,4],[5,3,3,3],[1,2,2,3,4],[1,2,3]] &gt; b &gt; [[1,2,3,4],[5,3,3,3],[1,2,2,3,4],[1,2,3]] &gt; b ++ [[1,1,1,1]] &gt; [[1,2,3,4],[5,3,3,3],[1,2,2,3,4],[1,2,3],[1,1,1,1]] &gt; [6,6,6]:b &gt; [[6,6,6],[1,2,3,4],[5,3,3,3],[1,2,2,3,4],[1,2,3]] &gt; b !! 2 &gt; [1,2,2,3,4] The nested lists can be of different dimensions, but they must be of the same type. List comparisons Lists can be compared if there is a method for comparing their contents. When using &lt;, &lt;=, &gt;, &gt;= to compare lists, their elements are compared in lexicographical order. First the head elements are compared, if they are equal the next elements are compared and so forth, until two elements are not equal, or one of the lists ends. &gt; [3,4,2] == [3,4,2] &gt; True &gt; [3,2,1] &gt; [2,10,100] &gt; True &gt; [3,4,2] &gt; [3,4] &gt; True List operations head takes a list as a parameter and returns its head, the first element &gt; head [10,9,8] &gt; 10 tail takes a list as a parameter and returns its tail, the elements past the first &gt; tail [10,9,8] &gt; [9,8] last takes a list as a parameter and returns its last element &gt; last [10,9,8] &gt; 8 init takes a list as a parameter and returns the elements before the last &gt; init [10,9,8] &gt; [10,9] The functions above will raise an exception if applied to an empty list. length takes a list as a parameter and returns its length, the number of elements &gt; length [1,2,3,4,5] &gt; 5 null takes a list as a parameter and returns True if the list is empty, and False otherwise &gt; null [] &gt; True &gt; null [1,2,3] &gt; False reverse takes a list as a parameter returns the reversed list &gt; reverse [5,4,3,2,1] &gt; [1,2,3,4,5] take takes an integer and a list as parameters and extracts that many elements from the list, returning them If we try to take more elements than there are in the list, it just returns the list without raising an exception. &gt; take 3 [5,4,3,2,1] &gt; [5,4,3] &gt; take 1 [3,9,3] &gt; [3] &gt; take 5 [1,2] &gt; [1,2] &gt; take 0 [6,5,4] &gt; [] drop takes an integer and list as parameters, and drops that many elements from the start of the list &gt; drop 3 [8,4,2,1,5,6] &gt; [1,5,6] &gt; drop 0 [4,3,2,1] &gt; [4,3,2,1] &gt; drop 100 [1,2,3,4] &gt; [] maximum takes an orderable list as a parameter and returns the largest element minimum takes an orderable list as a parameter and returns the smallest element &gt; minimum [8,4,2,1,5,6] &gt; 1 &gt; maximum [1,9,2,3,4] &gt; 9 sum takes a list of numbers as a parameter and returns their sum &gt; sum [1,2,3,4,5] &gt; 15 product takes a list of numbers as a parameter and returns their product &gt; product [1,2,3,4] &gt; 24 elem takes an instance of type T and a list of type T as parameters and returns true if the instance is contained within the list elem is usually called as an infix function because it is easier to read. &gt; 4 `elem` [3,4,5,6] &gt; True &gt; 10 `elem` [1,2,3] &gt; False Ranges Ranges are a method for making lists that are arithmetic sequences of elements that can be enumerated, such as numbers and characters. &gt; [1..20] &gt; [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20] &gt; ['a'..'z'] &gt; ['a','b','c','d','e','g','h','j','k','l','m','n','o','p','q','r','s','t','u','v','w','x','y','z'] The step for a range can also be specified. &gt; [2,4..20] &gt; [2,4,6,8,10,12,14,16,18,20] To make a list of numbers in descending order from m to n you have to write &gt; [m,m-1..n] Production of infinite lists Infinite lists can be produced by neglecting to specify an upper bound for a range. cycle takes a list as a parameter and cycles it into an infinite list. &gt; take 10 (cycle [3,2,1]) &gt; [3,2,1,3,2,1,3,2,1,3] repeat takes an element as a parameter and produces an infinite list of just that element &gt; take 10 (repeat 6) &gt; [6,6,6,6,6,6,6,6,6,6] If you want some number of the same element in a list it is simpler to use replicate replicate takes a number and an element a returns a list containing that many of the element &gt; replicate 5 6 &gt; [5,5,5,5,5,5] List comprehension Set comprehensions are often used for building specific sets from general sets. The part before the pipe is called the output function, is the variable, is the input set and is the the predicate. The set contains the doubles of all the values that satisfy the predicate. In Haskell we could write take 10 [2,4,..] but this would produce doubles of the first 10 natural numbers. A list comprehension should be used instead. &gt; [x*2 | x &lt;- [1..10]] &gt; [2,4,6,8,10,12,14,16,18,20] We can also add a predicate to the comprehension &gt; [x*2 | x &lt;- [1..10], x*2 &gt;= 12] &gt; [12,14,16,18,20] Suppose we want to all the numbers from 50 to 100 whose remainder when divided by the number 7 is 3. &gt; [x | x &lt;- [50,100], x `mod` 7 ==3] &gt; [52,59,66,73,80,87,94] This process is called filtering. We took a list and filtered it by the predicate. Now suppose we want to replace each odd number greater than 10 the string \"BANG!\" and each odd number less than 10 with \"BOOM!\". If a number isn’t odd, we throw it out of our list. For convenience we can place out comprehension inside a function so that we can reuse it. &gt; let boomBang xs = [if x &lt; 10 then \"BOOM!\" else \"BANG!\" | x &lt;- xs, odd x] &gt; boomBang [7..13] &gt; [\"BOOM!\", \"BOOM!\", \"BANG!\", \"BANG!\"] We can include several predicates. A comprehension for numbers from 10 to 20 that are not 13, 15, or 19 can be written as. &gt; [x | x &lt;- [10..20], x /= 13, x /= 15, x /= 19] &gt; [10,11,12,14,16,17,18,20] Not only can we have multiple predicates in list comprehensions, we can also draw from multiple lists. A list produced by a comprehension that draws from two lists of lengths n and m respectively will have a length of n*m. If we have two lists, [2,5,10] and [8,10,11] and we wish to find the products of all the possible combinations between numbers in those lists, we can write &gt; [x*y | x &lt;- [2,5,10], y &lt;- [8,10,10]] &gt; [16,20,22,40,50,55,80,100,110] Now suppose that we want all possible products which are greater than 50 &gt; [x*y | x &lt;- [2,5,10], y &lt;- [8,10,10], x * y &gt; 50] &gt; [55,80,100,110] &gt; let nouns = [\"hobo\",\"frog\",\"pope\"] &gt; let adjectives = [\"lazy\",\"grouchy\",\"scheming\"] &gt; [adjective ++ \" \" ++ noun | adjective &lt;- adjectives, noun &lt;- nouns] &gt; [\"lazy hobo\",\"lazy frog\",\"lazy pope\",\"grouchy hobo\",\"grouchy frog\", \"grouchy pope\",\"scheming hobo\",\"scheming frog\",\"scheming pope\"] We could use list comprehension to write a bad version of the length function. &gt; length` xs = sum [1 | _ &lt;- xs] This function replaces every element of the list with 1s and finds their sum. The underscore character, _, is used to denote a variable which is not used. Nested list comprehensions &gt; let xxs = [[1,3,5,2,3,1,2,4,5],[1,2,3,4,5,6,7,8,9].[1,2,4,2,1,6,3,1,3,2,3,6]] &gt; [[x | x &lt;- xs, even x] | xs &lt;- xxs] &gt; [[2,2,4],[2,4,6,8], [2,4,2,6,2,6]] The comprehension shown above applies a comprehension to each of the lists, within the outer list, filtering them to only even values. Tuples Tuples are similar to lists, providing a way to store several values in a single value. Tuples are used when the number of values you want to combine is known, and its type depends on how many components it has along with the type of the components. They are denoted with parentheses around a comma separated list of values. Unlike lists, tuples do not have to be homogeneous, meaning that they can contain several types. &gt; --List of tuples of the same type &gt; [(1,2),(3,4),(5,6)] &gt; --List of tuples of varying types -&gt; Error &gt; [(1,2),(3,\"4\"),('5',6)] Tuples can contain lists. Tuples are much more rigid. A general function cannot be written to append an element to a tuple. There is no singleton tuple. This is because a singleton tuple would just be the value it contains and therefore provide no use. Tuple operations fst takes a pair and returns its first component &gt; fst (8,11) &gt; 8 snd takes a pair and returns its second component These functions only work on pairs. They will not work on triples, 4-tuples, 5-tuples etc. zip takes two lists and produces a list of pairs &gt; zip [1,2,3,4,5] [5,4,3,2,1] &gt; [(1,5),(2,4),(3,3),(4,2),(5,1)] &gt; zip [1..5] [\"five\", \"four\", \"three\", \"two\", \"one\"] &gt; [(1, \"five\"), (2, \"four\"), (3, \"three\"), (4, \"two\"), (5, \"one\")] If the lengths of the lists do not match the longer list is cut off and ignored past the length of the shorter list. We can apply zip to pairings of finite and infinite lists, or two infinite lists &gt; take 10 (zip [1..] [1,0..]) &gt; [(1,1),(2,0),(3,-1),(4,-2),(5,-3),(6,-4),(7,-5),(8,-6),(9,-7),(10,-8)] Types and typeclasses The :t command can be used to determine the type of an expression. &gt; :t 'a' &gt; 'a' :: Char &gt; :t True &gt; True :: Bool &gt; :t (True, 'a') &gt; (True, 'a') :: (Bool, Char) &gt; :t 4 == 5 &gt; 4 == 5 :: Bool :: should be read as ‘has type of’. Explicit types are always denoted with the first letter in capital case. Functions also have types. When writing functions, we can give an explicit type declaration. removeNonUpercase :: [Char] -&gt; [Char] removeNonUpercase st = [ c | c &lt;- st, c `elem` ['A'..'Z']] removeNonUpercase has a type of [Char] -&gt; [Char] as it maps a string to a string. We don’t have to give this function a type decleration because the compiler can infer it, however it is still good practice to do so. addThree :: Int -&gt; Int -&gt; Int -&gt; Int addThree x y z = x + y + z The function above takes three parameters. The return type is the last item in the declaration and the parameters are the first three. Common types Int A 32 or 64 bit signed integer Integer A non-bounded integer Float A real floating point value with single precision Double A real floating point value with double precision Bool A boolean type, True or False Char Represents a single character Type variables head takes a list of any type and returns the first element &gt; :t head &gt; head :: [a] -&gt; a a is a type variable, meaning that it can be of any type. The type decleration of head means that it takes a list of some type a and returns a single instance of type a. This is much like generics in other languages. Functions that have type variables are called polymorphic functions. &gt; :t fst &gt; fst :: (a, b) -&gt; a fst takes a tuple which conatins two types, and returns an element which is of the same type as the first item in the pair. Note that despite the differing names of a and b they can be the same type. Typeclasses A typeclass behaves similarly to an interface. If a type is part of a typeclass, it supports and implements the behaviour that the typeclass describes. &gt; :t (==) &gt; (==) :: (Eq a) =&gt; a -&gt; a -&gt; -&gt; Bool The =&gt; symbol is called a class constraint. The euqality function takes any two values that are of the same type and returns a Bool. The class constraint is that the type of those two values must be a member of the Eq class. The Eq typeclass provides an interface for testing for equality. Any type where it makes sense to test for equality between two values of that type should be a member of the Eq class. All standard Haskell types except for IO and functions are part of the Eq typeclass. Consider the elem function which has a type of (Eq a) =&gt; a -&gt; [a] -&gt; Bool because it uses == over a list to check whether some value is contained. Common Typeclasses Eq Used for types that support equality testing. Members must implement == and /= Ord Used for types which have ordering. Ord covers &gt;, &lt;, &gt;=, and &lt;= The compare function takes two Ord members of the same type and returns an ordering. Ordering is a type that can be GT, LT, or EQ. To be a member of Ord, a type must first be a member of Eq Show Used for types that can be presented as strings. The most used function that deals with Show is show/ It takes a value whose type is a member of Show and presents it as a string. Read The read function takes a string and returns a type which is a member of Read &gt; read \"True\" || False &gt; True &gt; read \"8.2\" + 3.8 &gt; 12.0 &gt; read \"[1,2,3,4]\" ++ [3] &gt; [1,2,3,4,3] If we try read \"4\" an exception will be raised. &lt;interactive&gt;:1:0: Ambiguous type variable `a' in the constraint: `Read a' arising from a use of `read' at &lt;interactive&gt;:1:0-7 Probable fix: add a type signature that fixes these type variable(s) The return type cannot be determined. Previously our use of the return value could be used to determine its type. &gt; :t read &gt; read :: (Read a) =&gt; String -&gt; a read returns a type that is part of Read, but if we do not use the value the type cannot be determined. We can use explicit type annotations to overcome this problem. &gt; read \"5\" :: Int &gt; 5 &gt; read \"5\" :: Float &gt; 5.0 &gt; read \"(3, 'a')\" :: (Int, Char) &gt; (3, 'a') Most expressions provide sufficient detail that the compiler can infer what their type is by itself. Enum Enum members are sequentially ordered types. The Enum typeclass can be used in list ranges. They also have defined successors and predecessors. (), Bool, Char, Ordering, Int, Integer, Float, and Double are in this class. &gt; ['a'..'e'] &gt; \"abcde\" &gt; [LT..GT] &gt; [LT, EQ, GT] &gt; succ 'B' &gt; 'C' Bounded Members of this typeclass have an upper and lower bound. Both minBound and maxBound have a type of (Bounded a) =&gt; a. Tuples are part of Bounded if all of their components are. &gt; minBound :: Int &gt; -2147483648 &gt; maxBound :: Bool &gt; True &gt; maxBound :: (Bool, Int, Char) &gt; (True, 2147483647, '\\1114111') Num Is a numeric typeclass. Its members have the property of being able to act like numbers. Whole numbers are polymorphic constants. They can act like any type that’s a member of the Num typeclass. If we examine the type of * we can see that it accepts all numbers. &gt; :t (*) &gt; (*) :: (Num a) =&gt; a -&gt; a -&gt; a As * takes two numbers of the same type, (5 :: Int) * (6 :: Integer) will result in an error. To be part of Num, a type must also be part of Show and Eq. Integral Is a numeric typeclass containing Int and Integer Floating Is a numeric typeclass containing Float and Double The fromIntegral function has a type declaration of fromInegral :: (Num b, Integral a) =&gt; a -&gt; b. It takes an integral number and turns it into a more general number. Syntax in functions Pattern matching Pattern matching is the process of specifying patterns to which data should conform and then checking to see if it does, deconstructing the data according to those patterns. When defining functions, separate bodies can be defined for different patterns. factorial :: (Integral a) =&gt; a -&gt; a factorial 0 = 1 factorial n = n * factorial(n - 1) Pattern matching can fail. charName :: Char -&gt; String charName 'a' = \"Albert\" charName 'b' = \"Bert\" charName 'c' = \"Cecil\" When called with an unexpected input, and exception will be raised Non-exhaustive patterns in function charName Pattern matching can also be used on tuples. addVectors :: (Num a) =&gt; (a, a) -&gt; (a, a) -&gt; (a, a) addVectors a b = (fst a + fst b, snd a + snd b) Using pattern matching we can instead write the function as addVectors (x1, y1) (x2, y2) = (x1 + x2, y1 + y2) There are no provided functions to extract the components of triples, but they can be easily written. first :: (a, c, c) -&gt; a first (x, _, _) = x second :: (a, b, c) -&gt; b second (_, y, _) = y third :: (a, b, c) -&gt; c third (_, _, z) = z It is also possible to pattern match in list comprehensions. &gt; let xs = [(1, 3), (4, 3), (2, 4), (5, 3), (5, 6), (3, 1)] &gt; [a+b | (a, b) &lt;- xs] &gt; [4,7,6,8,11,4] If a pattern match fails, it will move to the next element. We can pattern match against a list to make our own implementation of head head' :: [a] -&gt; a head' [] = error \"Empty list has no head\" head' (x:_) = x tell :: (Show a) =&gt; [a] -&gt; String tell [] = \"The list is empty\" tell (x:[]) = \"The list has one element: \" ++ show x tell (x:y:[]) = \"The list has two elements: \" ++ show x ++ \" and \" ++ show y tell (x:y:_) = \"The list is long. The first two elements are \" ++ show x ++ \" and \" ++ show y The tell function is safe because it handles the empty list, singleton list, two element list, and lists with more than two elements. We could rewrite (x:[]) and (x:y:[]) as [x] and [x,y] respectively. We cannot however rewrite (x:y:_) with square brackets because it matches any list of length 2 or more. We can implement a recursive length function using list comprehension length' :: (Num b) =&gt; [a] -&gt; b length' [] = 0 length' (_:xs) = 1 + length` xs We first define the result of a known input, the empty list. This is known as the edge condition. In the second pattern we split the list into a head and a tail, and then state that the length is 1 plus the length of the tail. sum' :: (Num a) =&gt; [a] -&gt; a sum' [] = 0 sum' (x:xs) = x + sum` xs Patterns Patterns are a method of breaking something up according to a pattern and binding it to names whilst still keeping a refernce to the whole thing. xs@(x:y:ys) will match exactly the same thing as x:y:ys but the whole list can be accessed via xs instead of repeatedly typing x:y:ys within the function body. capital :: String -&gt; String capital \"\" = \"Empty string\" capital all@(x:xs) = \"The first letter of \" ++ all ++ \" is \" + [x] Patterns can be used to avoid needless repetition. Note that ++ cannot be used in pattern matching. Guards While patterns make sure a value conforms to some form and allow destructuring it, guards are a way of testing whether some property or properties of a value are true or false. Guards are much more readable that a statement when there are several conditions. bmi :: (RealFloat a) =&gt; a -&gt; String bmi i | i &lt;= 18.5 = \"Underweight\" | i &lt;= 25 = \"Normal\" | i &lt;= 30 \"Fat\" | i &lt;= \"Land whale\" Guards are indicated by pipes that follow a function’s name and its parameters. They are usually indented. A guard is basically a boolean expression. If it evaluates to True, the corresponding body is used. Otherwise, the next guard is evaluated. The last guard will often be otherwise. otherwise is simply an alias for True, and catches everything. If all the guards of a function evaluate to False and there is no otherwise guard, evaluation falls through to the next pattern. If no suitable guards or patterns are found, an error is thrown. Guards can also be written inline, although it is less readable. max' :: (Ord a) =&gt; a -&gt; a -&gt; a max' a b | a &gt; b = a | otherwise = b compare' :: (Ord a) =&gt; a -&gt; a -&gt; Ordering a `compare` b | a &gt; b = GT | a == b = EQ | otherwise = LT where Take note of the repetition in the function below bmi :: (RealFloat a) =&gt; a -&gt; a -&gt; String bmi weight height | weight / height ^2 &lt;= 18.5 = \"Underweight\" | weight / height ^2 &lt;= 25 = \"Normal\" | weight / height ^2 &lt;= 30 = \"Overweight\" | otherwise = \"Land whale\" Rather than repeating the bmi calculation, we can use the where keyword. bmi weight height | i &lt;= 18.5 = \"Underweight\" | i &lt;= 25 = \"Normal\" | i &lt;= 30 = \"Overweight\" | otherwise = \"Land whale\" where i = weight / height ^2 The value defined in where is visible across the guards. where bindings are not shared across function bodies of different patterns. If you want several patterns of one function to access a shared name, the name must be defined globally. We could also write a pattern match. where bmi = weight / height ^2 (underweight, normal, overweight) = (18.5, 25, 30) Another trivial function might five someone their initials initials :: String -&gt; String -&gt; String initials firstname lastname = [f] ++ \". \" ++ [l] ++ \".\" where (f:_) = firstname (l:_) = lastname In the same way that we have defined constants in where blocks, we can also define functions. calcBmis :: (RealFloat a) =&gt; [(a, a)] -&gt; [a] calcBmis xs = [bmi w h | (w, h) &lt;- xs] where bmi weight height = weight / height ^2 Let it be let bindings are very similar to where bindings. let bindings allow you to bind variables anywhere and are themselves expressions. They do not span across guards. cyclinder :: (RealFloat a) =&gt; a -&gt; a -&gt; a cylinder r h = let sideArea = 2 * pi * r * h topArea = pi * r^2 in sideArea + 2 * topArea A let binding is of the form let &lt;bindings&gt; in &lt;expression&gt;. The names defined in the binding are accessible in the expression. This is similar to splitting up a calculation in another language. fun cylinder(r: Int, h: Int): Float { val sideArea = 2 * Math.PI * r * h val topArea = Math.PI * r * r return sideArea + 2 * topArea } The difference between where and let bindings is that while where bindings are just syntactic constructs, let bindings are actually expressions. let bindings can be used almost anywhere, in the same way as if statements. &gt; 4 * (let a = 9 in a + 1) + 2 &gt; 42 &gt; [let square x = x * x in (square 5, square 3, square 2)] &gt; [(25, 9, 4)] If we want to bind several variables in line, we can separate them with semicolons. &gt; (let a = 100; b = 200; c = 300 in a*b*c, let foo=\"Hey\"; bar = \"there!\" in foo ++ bar) &gt; (6000000, \"Hey there!\") let bindings are very useful for quickly dismantling a tuple into components and binding them to names. &gt; (let (a,b,c) = (1,2,3) in a+b+c)*100 &gt; 600 let bindings can also be used inside list comprehensions. calcBmis :: (RealFloat a) =&gt; [(a, a)] -&gt; [a] calcBmis xs = [bmi | (w, h) &lt;- xs, let bmi = w /h^2] We use let in a similar way to a predicate, the difference being that we do not filter the list. The names defined in a let are visible to the output function and all predicates and secitons that come after the binding. listOverweight :: (RealFloat a) =&gt; [(a, a)] -&gt; [a] listOverweight xs :: [bmi | (w, h) &lt;- xs, let bmi = w / h^2, bmi &gt;= 25] We ommited the in part of the binding because the scope of the names is already predefined. If we used let in, the names would only be visible to that predicate. Case expressions The syntax for a case expression is simple case expression of pattern -&gt; result pattern -&gt; result pattern -&gt; result ... expression is matched against the patterns. The first pattern that matches the expression is used. If it falls through the whole case an exception occurs. Whereas pattern matching on function parameters can only be done when defining functions, case expressions can be used pretty much anywhere. They are useful for pattern matching against something in the middle of an expression. Recursion The maximum function takes a list of instances of the Ord typeclass, and returns the largest of them. In an imperative language you might define this function as so fun maximum(items: Array&lt;Int&gt;): Int { var max = Integer.MIN_VALUE items.forEach { if (it &gt; max) { max = it } } return max } In Haskell we might instead write our maximum function as follows maximum' :: (Ord a) =&gt; [a] -&gt; a maximum' [] = error \"Empty list\" maximum' [x] = x maximum' (x:xs) | x &gt; maxTail = x | otherwise = maxTail where maxTail = maximum' xs We split the list into a head and a tail, and then compare the head to the maximum of the tail. Consider [2, 5, 1]. We reach the (x:xs) branch with a head of 2 and a tail of [5, 1]. maximum' is called on [5, 1], reaching the same branch with a head of 5 and a tail of [1]. maximum' is called once more on [1] which returns 1. We now cascade back up the call stack, comparing the head 5 to 1, giving 5 and then comparing 5 (maxTail) to 2 and returning 5. The function could be written more elegantly using max. maximum' :: (Ord a) =&gt; [a] -&gt; a maximum' [] = error \"Empty list\" maximum' [x] = x maximum' (x:xs) - max x (maximum' xs) Recursive function Examples Repliate replicate' :: (Num i, Ord i) =&gt; i -&gt; a -&gt; [a] replicate' n x | n &lt;= 0 = [] | otherwise x:replicate` (n-1) x As we are testing boolean expressions we used guards. As Num is not a subclass of Ord we have to specify both class constraints. Take take' :: (Num i, Ord i) =&gt; i -&gt; [a] -&gt; [a] take` n _ | n &lt;= 0 = [] take` _ [] = [] take` n (x:xs) = x:take` (n-1) xs The first pattern deals with negative values, the second with empty lists, and the third with lists containing some number of items. As our guard has no otherwise, the the matching will fall through when n &gt; 0. Reverse reverse' :: [a] -&gt; [a] reverse' [] = [] reverse' (x:xs) = reverse' xs ++ [x] Repeat repeat takes an element and returns an infinite list of that element. repeat' :: a -&gt; [a] repeat' x = x:repeat x Repeat zip takes two lists and zips them together to a list of pairs. zip' :: [a] -&gt; [b] -&gt; [(a, b)] zip' _ [] = [] zip' [] _ = [] zip' (x:xs) (y:ys) = (x,y):zip xs ys Elem elem' :: a -&gt; [a] -&gt; Bool elem' a [] = False elem' a (x:xs) | a == x = True | otherwise = a `elem` xs Quick sort Implementing QuickSort is much easier in Haskell than in imperative languages. quicksort :: (Ord a) =&gt; [a] -&gt; [a] quicksort [] = [] quicksort (x:xs) = let smallerSorted = quicksort [a | a &lt;- xs, a &lt;= x] biggerSorted = quicksort [a | a &lt;- xs, a &lt;= x] in smallerSorted ++ [x] ++ biggerSorted This Quicksort implementation uses the head as a pivot for the sorting. Higher order functions Functions in Haskell can take functions as parameters and return functions. A function that does either of those is called a higher order function. Curried functions Every function in Haskell only takes one parameter. All the functions which take several parameters are curried functions. The following two calls are equivalent &gt; max 4 5 &gt; (max 4) 5 Calling max 4 5 first creates a function which takes a single parameter and returns either 4 or that parameter, whichever is larger. It then applies that function to 5. Putting a space between two pieces of code is simply function application. The space is like an operator with the highest precedence. Again considering max max :: (Ord a) =&gt; a -&gt; a-&gt; a max :: (Ord a) =&gt; a -&gt; (a -&gt; a) The second line could be read as max takes an a and returns a function that takes another a and returns an a. The return type of each functions are separated with the arrows. Consider the following function multThree :: (Num a) =&gt; a -&gt; a -&gt; a -&gt; a multThree x y z = x * y * z When we call multThree 3 5 9 we are actually calling ((multThree 3) 5) 9. This means that 3 is applied to multThree to create a function that takes one parameter and returns a function. Next, 5 is applied to that function, and returns a function which takes a single parameter and multiplies it by 15. Finally, 9 is applied to that function and the result is 135. By calling functions without some of their parameters, we can create new functions. &gt; let multTwoWithNine = multThree 9 &gt; multTwoWithNine 2 3 &gt; 54 &gt; let multWithEighteen = multTwoWithNine 2 &gt; multWithEighteen 10 &gt; 180 Infix functions can also be partially applied by using sections. To section an infix function, surround it with parentheses and only supply a parameter on one side. divTen :: (Floating a) =&gt; a -&gt; a divTen = (/10) isUpperAlphanum :: Char -&gt; Bool isUpperAlphanum = ('elem' ['A'..'Z']) Note that when using sections, - cannot be used directly. (-4) means -4. To make a function which takes a value and subtracts 4 from it you must replace the - with subtract, (subtract 4). Higher order functions applyTwice :: (a -&gt; a) -&gt; a -&gt; a applyTwice f x = f (f x) Notice that the type declaration contains parentheses. They are mandatory when one of the parameters is a function. &gt; applyTwice (+4) 10 &gt; 18 We can now re-implement another standard library function, zipWith. zipWith takes a function and two lists as parameters and then joins the two lists by applying the function between corresponding elements. zipWith' (a -&gt; b -&gt; c) -&gt; [a] -&gt; b -&gt; [c] zipWith' _ [] _ = [] zipWith' _ _ [] = [] zipWith' f (x:xs) (y:ys) = f x y : zipWith' f xs ys In the type decleration the first parameter is a function that takes two things and produces a third. The second and third parameters are lists, and the return value is a list, with each list matching the respective types of the arguments of the first function. &gt; zipWith' (+) [4,2,5,6] [2,6,2,3] &gt; [6,8,7,9] Another standard library function is flip. It takes a function and returns a function which is like the original function, but with the first two arguments flipped. flip' :: (a -&gt; b -&gt; c) -&gt; (b -&gt; a -&gt; c) flip' f = g where g x y = f y x Reading the type declaration we say that flip' takes a function that takes an a and a b, and returns a function that takes a b and an a. Because functions are curried by default, the second pair of parentheses is really unnecessary, because -&gt; is right associative by default. (a -&gt; b -&gt; c) -&gt; (b -&gt; a -&gt; c) is the same as (a -&gt; b -&gt; c) -&gt; (b -&gt; (a -&gt; c)) which is the same as (a -&gt; b -&gt; c) -&gt; b -&gt; a -&gt; c. We can further simplify the function by writing it as flip' :: (a -&gt; b -&gt; c) -&gt; b -&gt; a -&gt; c flip' f y x = f x y Maps and filters map Takes a function and a list and applies that function to every element in the list, producing a new list. The definition of map is map :: (a -&gt; b) -&gt; [a] -&gt; [b] map _ [] = [] map f (x:xs) = f x : map f xs &gt; map (+2) [1,2,3,4] &gt; [3,4,5,6] This is much more readable than the equivalent list comprehension [x+2 | x &lt;- [1,2,3,4]]. filter is a function that takes a predicate and a list and returns the elements of the list that satisfy the predicate filter :: (a -&gt; Bool) -&gt; [a] -&gt; [a] filter _ [] = [] filter p (x:xs) | p x = x : filter p xs | otherwise = filter p xs &gt; filter (&gt;3) [1,2,3,4,5,6,7,8,9] &gt; [4,5,6,7,8,9] &gt; let notNull x = not (null x) in filter notNull [[1,2,3],[],[3,4,5],[2,2],[],[]] &gt; [[1,2,3],[3,4,5],[2,2]] Recalling the earlier implementation of QuickSort, we can replace the list comprehensions with calls to filter. quicksort :: (Ord a) =&gt; [a] -&gt; [a] quicksort [] = [] quicksort (x:xs) = let smallerSorted = quicksort (filter (&lt;=x) xs) biggerSorted = quicksort (filter (&gt;x) xs) in smallerSorted ++ [x] ++ biggerSorted takeWhile is a function that takes a list and a predicate and returns all of the elements from the start of the list while the predicate returns true Suppose we wish to find the sum of all odd square that are less than 10000 &gt; sum (takeWhile (&lt;10000) (filter odd (map (^2) [1..]))) &gt; 166650 In the Collatz sequence, we start with a natural number. If the number is even we divide it by 2. If the number is odd we multiply it by 3 and add 1. We take the resulting value and apply the same process to it, stopping when we reach one. chain :: (Integral a) =&gt; a -&gt; [a] chain 1 = [1] chain n | even n = n:chain (n / 2) | odd n = n:chain (n*3 + 2) &gt; chain 10 &gt; [10, 5, 16, 8, 4, 2, 1] Lambdas Lambdas are anonymous functions that are used because we need some functions only once, and do not want to pollute the namespace. We write a lambda with a \\newline and then write the parameters, followed by a -&gt; and then the function body. Filtering for long chains we might write numLongChains :: Int numLongChains = length (filter (\\xs -&gt; length xs &gt; 15) (map chain [1..100])) Lambdas can take any number of parameters in the same way as normal functions &gt; zipWith (\\a b -&gt; (a * 30 + 3) / b) [5,4,3,2,1] [1,2,3,4,5] &gt; [153.0, 61.5, 31.0, 15.75, 6.6] As with normal functions, we can pattern match in lambdas. &gt; map (\\newline(a,b) -&gt; a + b) [(1,2),(3,5),(6,3),(2,6),(2,5)] &gt; [3,8,9,8,7] Due to the way we curry functions, the following two are equivalent addThree :: (Num a) =&gt; a -&gt; a -&gt; a -&gt; a addThree x y z = x + y + z addThree :: (Num a) =&gt; a -&gt; a -&gt; a -&gt; a addThree = \\x -&gt; \\y -&gt; \\z -&gt; x + y + z While the example above decreases readability, it can aid with the understanding of some functions, such as flip flip' :: (a -&gt; b -&gt; c) -&gt; b -&gt; a -&gt; c flip' f = \\x y -&gt; f y x Folding foldl The left fold the folds a list up form the left side sum' :: (Num a) =&gt; [a] -&gt; a sum' xs = foldl (\\acc x -&gt; acc + x) 0 xs In the example above \\acc x -&gt; acc + x is the binary function. 0 is the starting value and xs is the list to be folded up. &gt; sum' [3,5,2,1] &gt; 11 At each step we have | 0 + 3 | [3,5,2,1] | | 3 + 5 | [5,2,1] | | 8 + 2 | [2,1] | | 10 + 1| [1] | | 11 | | We could implement elem using foldl elem' :: (Eq a) =&gt; a -&gt; [a] -&gt; Bool elem' y ys = foldl (\\acc x -&gt; if x == y then True else acc) False ys The starting value and accumulator above are both boolean values. foldr Works in a similar way to foldl, except that it consumes values from the right foldr takes the accumulator as the second function. We can implement map with a foldr. map' :: (a -&gt; b) -&gt; [a] -&gt; [b] map' f xs = foldr (\\x acc -&gt; f x : acc) [] xs If we map (+3) to [1,2,3], we approach the list from the right side. We take the first element 3 and apply the function to it, giving 6. We prepend 6 to the accumulator. We then apply (+3) to 2, giving 5, and prepend it to the accumulator. Continuing in the same manner we reach [4,5,6]. One notable difference is that folr works on infinite lists, while foldl does not. Folds can be used to implement any function were you traverse a list once. There are also the functions foldl1 and foldr1 which do not require a starting value, instead assuming that the first value in their traversal order is the starting value. This would allow an implementation of sum as sum = foldl1 (+), although it would cause an error on an empty list. Fold implementations of standard library functions maximum' :: (Ord a) =&gt; [a] -&gt; a maximum' = foldr1 (\\x acc -&gt; if x &gt; acc then x else acc) reverse' :: [a] -&gt; [a] reverse' = foldl (\\acc x -&gt; x : acc) [] product' :: (Num a) =&gt; [a] -&gt; a product' = foldr1 (*) filter' :: (a -&gt; Bool) -&gt; [a] -&gt; [a] filter' p = foldr (\\x acc -&gt; if p x then x : acc else acc) [] head' :: [a] -&gt; a head' = foldr1 (\\x _ -&gt; x) last' :: [a] -&gt; a last' = foldl1 (\\_ x -&gt; x) The head function would be better implemented by pattern matching, as the fold traverses the entire list. In reverse we take a starting value of an empty list and append each value from the left to our list. scanl and scanr scanl and scanr are like foldl and foldr, with the difference being that they report all the intermediate accumulator states in the form of a list. There are also scanl1 and scanr1 &gt; scanl (+) 0 [3,5,2,1] &gt; [0,3,8,10,11] &gt; scanr (+) 0 [3,5,2,1] &gt; [11,8,3,1,0] &gt; scanl1 (\\acc x -&gt; if x &gt; acc then x else acc) [3,4,5,3,,7,9,2,1] &gt; [3,4,5,5,7,9,9,9] &gt; scanl (flip (:)) [] [3,2,1] &gt; [[],[3],[2,3],[1,2,3]] Scans are used to monitor the progression of a function that can be implemented as a fold. Function application with $ The $ function is also called function application. ($) :: (a -&gt; b) -&gt; a -&gt; b f $ x = f x Whereas normal function application has the highest precedence, $ has the lowest precedence. Function application with a space is left-associative so f a b c is the same as ((f a) b) c. Function application with $ is right associative. Consider the expression sum (map sqrt [1..130]). We can instead write sum $ map sqrt [1..130]. When a $ is encountered the expression on its right is applied as the parameter to the function on its left. Consider sqrt (3 + 4 + 9). We could instead write this as sqrt $ 3 + 4 + 9. In sum (filter (&gt; 10) (map (*2) [2..10])) we can write sum $ filter (&gt; 10) $ map (*2) [2..10] because f (g (z x)) is equal to f $ g $ z x. Function composition In Haskell, function composition is performed with the . function, which is defined as follows (.) :: (b -&gt; c) -&gt; (a -&gt; b) -&gt; a -&gt; c f . g = \\x -&gt; f (g x) f must take as its parameter a value that has the same type as g’s return value. One of the uses for function composition is making functions on the fly to pass to other functions, which is often cleaner and more concise than lambdas. &gt; map (\\x -&gt; negate (abs x)) [5,-3,-6,7,-3,2,-19,24] &gt; [-5,-3,-6,-7,-3,-2,-19,-24] &gt; map (negate . abs) [5,-3,-6,7,-3,2,-19,24] &gt; [-5,-3,-6,-7,-3,-2,-19,-24] Function composition is right associative, so multiple functions can be composed together. Function composition with multiple parameters If we want to use a function with multiple parameters in a function composition, we usually have to partially apply them so that each function takes just one parameter. sum (replicate 5 (max 6.7 8.9)) can be rewritten as (sum . replicate 5. max 6.7) 8.9 or as sum . replicate 5 . max 6.7 $ 8.9. What is happening is the creation of a function that takes what max 6.7 takes and applies replicate 5 to it. Then a function that takes the result of that and does a sum of it is create. Finally, that unction is called with 8.9. However it is more easily read as taking the value of max 6.7 8.9, replicating it 5 times, and taking the sum of that replication. If you want to rewrite a function with lots of parentheses you can start by putting the last parameter of the innermost function after a $, and replacing each pair of parentheses with a .. replicate 100 (product (map (*3) (zipWith max [1,2,3,4,5] [4,5,6,7,8]))) can be rewritten as replicate 100 . product . map (*3) . zipWith max [1,2,3,4,5] $ [4,5,6,7,8]. The free point style allows functions to be written more cleanly fn x = ceiling (negate (tan (cos (max 50 x)))) can instead be written fn = ceiling . negate . tan . cos . max 50 Modules A Haskell module is a collection of related functions, types, and typeclasses. A program is a collection of modules in which the main module loads up the other modules and then uses their functions to perform some process. Modules provide many advantages. If a module is generic enough, the functions it exports can be used in many different programs. If code is separated into self-contained modules which aren’t too reliant on each other, they can be reused later on and changed more easily without having to rewrite other code. The standard library is split into modules, each of which contains related functions and types. Modules are imported before the definition of any function with the syntax import module_name. The Data.List module has useful functions for working with lists. One of thest functions is numUniques numUniques:: (Eq a) =&gt; [a] -&gt; Int numUniques = length . nub When Data.List is imported, all of its exports become available in the global namespace. nub is another function in Data.List that removes duplicate elements from a list. In the terminal, functions can be added to the global namespace with :m &gt; :m + Data.List Data.Map Data.Set Individual functions can also be imported import Data.List (nub, sort) We can also import all of the functions in a module except some which are explicitly excluded. This is useful if different modules export functions with the same name. import Data.List hiding (nub) Another method for dealing with name clashes is qualified imports. The Data.Map module contains functions with the same names as some of those in Prelude, such as filter or null import qualified Data.Map This means that when we wish to reference the filter function in Data.Map we must write Data.Map.Filter. As this can make code very verbose, there is the option to name the import import qualified Data.Map as M We can now access Data.Map.Filter as M.filter Data.List intersperse takes an element and a list and puts that element in between each pair of elements in the list &gt; intersperse 0 [1,2,3,4,5] &gt; [1,0,2,0,3,0,4,0,5] intercalate takes a list of lists and a list, and inserts the list between each of the lists within the list of lists, before flattening the result &gt; intercalate [0,0,0] [[1,2,3],[4,5,6],[7,8,9]] &gt; [1,2,3,0,0,0,4,5,6,0,0,0,7,8,9] transpose transposes a list of lists. Considering the list of lists as a 2d matrix, rows become columns and vice versa &gt; transpose [[1,2,3],[4,5,6],[7,8,9]] &gt; [[1,4,7],[2,5,8],[3,6,9]] fold’ and foldl1’ are stricter version of their respective lazy incarnations. When using lazy folds on very large lists, stack overflow errors may occur. Due to the lazy nature of folds, the accumulator is not actually updated as the folding happens. The strict fold functions actually compute the intermediate values rather than filling up the stack with thunks. concat flattens a list of lists into a list of elements &gt; concat [[1,2,3],[4,5,6],[7,8,9]] &gt; [1,2,3,4,5,6,7,8,9] concatMap is the same as first mapping a function to a list, and then concatenating the list with concat and takes a list of values and returns True only if all the values in the list are True or takes a list and returns True if any of the values in the list are True &gt; and $ map (&gt;4) [5,6,7,8] &gt; True &gt; or $ map (==4) [1,2,3,4,5,6,7,8] &gt; True any and all take a predicate and then check if any or all of the elements in the list satisfy the predicate, respectively. These functions are usually used rather than mapping over a list and then using or or and iterate takes a function and a starting value. It applies the function to the starting value, then applies that function to the result, and repeats, returning in the form of an infinite list &gt; take 10 $ iterate (*2) 1 &gt; [1,2,4,8,15,32,64,128,256,512] splitAt takes a number and a list. It then splits the list at that many elements, returning the two lists in a tuple &gt; splitAt 3 [1,2,3,4,5,6] &gt; ([1,2,3], [4,5,6]) takeWhile takes elements from a list while the predicate holds &gt; takeWhile (/=' ') \"This is a sentence\" &gt; \"This\" dropWhile takes a list and drops all the elements from the list while the predicate holds &gt; dropWhile (&lt;3) [1,2,2,2,2,2,2,8,6,8] &gt; [8,6,8] span returns a pair of lists, the first list containing the result of takeWhile on the list, and the second list containing the remaining elements break break p is the equivalent of span (not . p) sort sorts a list of the Ord typeclass group takes a list and groups the adjacent elements into sublists if they are equal &gt; group [1,1,1,2,2,2,2,3,3,3,3,3,4,4,4,4,4,4] &gt; [[1,1,1],[2,2,2,2],[3,3,3,3,3],[4,4,4,4,4,4]] inits and tails are like init and tail except that they recursively apply to the list until there is nothing left &gt; inits \"text\" &gt; [\"\", \"t\", \"te\", \"tex\", \"text\"] isInfixOf returns true if a sublist is contained within a list isPrefixOf and isSuffixOf search for a sublist at the beginning and end of a list respectively elem and notElem check if an element is or is not inside a list partition takes a list and a predicate and returns a pair of lists, the first containing all the elements that satisfy the predicate, and the second containing those that do not find takes a list and a predicate and returns the first element that satisfies the predicate The type of find is Maybe a as it can contain Just a or Nothing. elemIndex returns the index of an element in a list, or Nothing if the element is not contained within the list elemIndices returns a list of the indices of an element within a list findIndex maybe returns the index of the first element that satisfies the predicate zip3, zip4, zipWith3, and zipWith4 zip 3 or 4 lists into triples or 4 tuples lines takes a string returns every line of that string in a separate list &gt; lines \"line 1\\nline 2\\nline 3\" &gt; [\"line 1\", \"line 2\", \"line 3\"] unlines takes a list of strings and joins them together with the ‘\\n’ character words and unwords split a line of text into words or join a list of words respectively delete takes an element and a list and deletes the first occurrence of that element in the list \\ the list difference function. For every element in the right hand list, it removes a matching element in the left one union returns the union of two lists intersect returns only the elements that are found in both lists insert takes an element and a list of elements that can be sorted and inserts it into the last position where it is less than or equal to the next element length, take, drop splitAt, !!, and replicte all take Int as one of their parameters, or return an Int. They could be more generic if they took any type that’s part of Integral or Num. Data.List contains genericLength, genericTake etc to provide these functions without breaking old code. The nub, delete, union, intersect, and group functions all have their more general counterparts nubBy etc. While the standard functions use == to test for equality, the By functions take an equality function as a parameter. Similarly there are sortBy, insertBy, maximumBy, and minimumBy functions. Data.Char The Data.Char module deals with characters isControl checks whether a character is a control character isSpace checks whether a character is a white space character isLower checks whether a character is lower cased isUpper checks whether a character is upper cased isAlpha checks whether a character is a letter isAlphaNum checks whether a character is a letter or a number isPrint checks whether a character is printable isDigit checks whether a character is a digit isOctDigit checks whether a character is an octal digit isHexDigit checks whether a character is a hexadecimal digit isLetter checks whether a character is a letter isMark checks for Unicode mark characters. These characters combine with preceding letters to form letters with accents isNumber checks whether a character is numeric isPunctuation checks whether a character is punctuation isSymbol checks whether a character is a symbol isSeparator checks for Unicode spaces and separators isAscii checks whether a character falls within the first 128 of the Unicode set isLatin1 checks whether a character falls into the first 256 characters of the Unicode set isAsciiUpper checks whether a character is ASCII and uppercase isAsciiLower checks whether a character is ASCII and lowercase All of the above functions have a type signature of Char -&gt; Bool Data.Char exports a data type which is similar to Ordering. The Ordering type can have a value of LT, EQ, or GT. It describes possible result that can arise from comparing elements. The GeneralCategory type is also an enumeration. It presents possible categories that a character can fall into. generalCategory has a type of Char -&gt; GeneralCategory. There are a total of 31 categories. &gt; generalCategory ' ' &gt; Space &gt; generalCategory 'A' &gt; UppercaseLetter &gt; generalCategory '|' &gt; MathSymbol toUpper converts a character to uppercase, ignoring those which do not have an uppercase toLower converts a character to lowercase toTitle converts a character to title case, which is usually the same as uppercase digitToInt converts a character to an Int. The character must be in the range ‘0..9, a..f, A..F’ intToDigit is the inverse of digitToInt ord and chr convert characters to their numeric values and vice versa Data.Map Association lists are lists that are used to store key-value pairs where ordering does not matter. We could represent this structure with a list of pairs, and find values by their key as follows findKey :: (Eq k) =&gt; k -&gt; [(k, v)] -&gt; v findKey key xs = snd . head . filter (\\(k,v) -&gt; key == k) $ xs The function takes the list of pairs, filters the list so that only matching keys remain, and takes the head value. In order to deal with elements which do not exist, we must return Maybe v findKey :: (Eq k) =&gt; k -&gt; [(k,v)] -&gt; Maybe v findKey key [] = Nothing findKey key ((k,v):xs) = if key == k then Just v else findKey key xs This recursive function on a list can be implemented as a fold findKey :: (Eq k) =&gt; k -&gt; [(k,v)] -&gt; Maybe v findKey key = foldr (\\(k,v) acc -&gt; if key == k then Just v else acc) Nothing The findKey function does the same thing as the lookup function from Data.List. The Data.Map module offers association lists which are much faster, as they are not traversing lists. Data.Map should qualified in order to stop namespace clashes with Prelude and Data.List. fromList takes an association list and returns a map with the same associations If there are duplicate keys in the list, they are discarded. fromList has the signature Map.fromList :: (Ord k) =&gt; [(k, v)] -&gt; Map.Map k v. The keys must be orderable so that they can be placed in a tree. empty represents an empty map insert takes a key, a value, and a map, and returns a new map with the new item &gt; Map.empty &gt; fromList [] &gt; Map.insert 3 100 Map.empty &gt; fromList [(3,100)] null checks if a map is empty size reports the size of a map, which is the number of key value pairs singleton takes a key and a value and creates a map with exactly one mapping lookup returns Just something if a key exists and Nothing if it does not member is a predicate that takes a key and a map and reports whether the key is in the map map and filter work much like their list equivalents, working on the values toList is the inverse of fromList keys and elems return a list of keys and values respectively fromListWith acts like fromList except that it takes a function supplied to decide what to do with duplicate keys The function is used to combine the values of those keys into some other value insertWIth inserts a key-value pair into a map, using the passed function if the key already exists Data.Set Data.Set offers set structures. fromList takes a list and converts it to a set &gt; Set.fromList \"The quick brown fox jumped over the lazy dog.\" &gt; fromList \" .Tabcdefghijklmnopqrstuvwxyz\" The elements are ordered and each element is unique intersection returns a set of the elements which are present in both sets difference returns a set of the elements which are in the first set but not the second union returns a set of the combined elements of both sets null, size, member, empty, singleton, insert, and delete work as expected isSubsetOf checks if the first set is a subset of the second set isProperSubsetOf checks if the first set is a proper subset of the second set Creating modules Modules are defined as follows module Geometry ( sphereVolume , sphereArea , cubeVolume , cubeArea , cuboidArea , cuboidVolume ) where sphereVolume :: Float -&gt; Float sphereVolume radius = (4.0 / 3.0) * pi * (radius ^ 3) sphereArea :: Float -&gt; Float sphereArea radius = 4 * pi * (radius ^ 2) cubeVolume :: Float -&gt; Float cubeVolume side = cuboidVolume side side side cubeArea :: Float -&gt; Float cubeArea side = cuboidArea side side side cuboidVolume :: Float -&gt; Float -&gt; Float -&gt; Float cuboidVolume a b c = rectangleArea a b * c cuboidArea :: Float -&gt; Float -&gt; Float -&gt; Float cuboidArea a b c = rectangleArea a b * 2 + rectangleArea a c * 2 + rectangleArea c b * 2 rectangleArea :: Float -&gt; Float -&gt; Float rectangleArea a b = a * b The helper function rectangleArea is not exported. Modules can be given hierarchical structures. Each module can have a number of submodules which can have submodules of their own. Creating submodules First we create a folder called Geometry. Within this folder we create three files: Sphere.hs, Cuboid.hs, and Cube.hs module Geometry.Sphere ( volume , area ) where volume :: Float -&gt; Float volume radius = (4.0 / 3.0) * pi * (radius ^ 3) area :: Float -&gt; Float area radius = 4 * pi * (radius ^ 2) module Geometry.Cuboid ( volume , area ) where volume :: Float -&gt; Float -&gt; Float -&gt; Float volume a b c = rectangleArea a b * c area :: Float -&gt; Float -&gt; Float -&gt; Float area a b c = rectangleArea a b * 2 + rectangleArea a c * 2 + rectangleArea c b * 2 rectangleArea :: Float -&gt; Float -&gt; Float rectangleArea a b = a * b module Geometry.Cube ( volume , area ) where import qualified Geometry.Cuboid as Cuboid volume :: Float -&gt; Float volume side = Cuboid.volume side side side area :: Float -&gt; Float area side = Cuboid.area side side side In each module we have defined functions with the same names. This is possible because they are separate modules. Making Types and Typeclassses Algebraic data types data Bool = False | True The data keyword is used to define a new data type. The part before the = denotes the type, and the parts after it are value constructors. They specify the different values that this type can have. We could think of Int as being data Int = -2147483648 | -2147483647 | ... | -1 | 0 | 1 | 2 | ... | 2147483647 Consider the definition of a shape data Shape = Circle Float Float Float | Rectangle Float Float Float Float The Circle value constructor has three fields. When we write a value constructor we optionally add some types after it and those types define the values it will contain. Value constructors are actually functions that ultimately return a value of a data type. &gt; :t Circle &gt; Circle :: Float -&gt; Float -&gt; Float -&gt; Shape &gt; :t Rectangle &gt; Rectangle :: Float -&gt; Float -&gt; Float -&gt; Float -&gt; Shape A function to find the surface of a Shape cane be written as follows surface :: Shape -&gt; Float surface (Circle _ _ r) = pi * r ^ 2 surface (Rectangle x1 y1 x2 y2) = (abs $ x2 - x1) * (abs $ y2 - y1) We could not write a type declaration of Circle -&gt; Float because Circle is not a type, whereas Shape is. We can pattern match against constructors, which we have been doing before when matching against values like [] or False. To make our type printable we modify it as below data Shape = Circle Float Float Float | Rectangle Float Float Float Float deriving (Show) When we add deriving (Show) at the end of a data declaration, Haskell makes that type part of the Show typeclass automatically. Value constructors are functions, so we can map them and partially apply them. &gt; map (Circle 10 20) [4,5,6,7] &gt; [Circle 10.0 20.0 4.0,Circle 10.0 20.0 5.0,Circle 10.0 20.0 6.0,Circle 10.0 20.0 7.0] To improve the Shape type we can define an intermediate data type to represent a point in two dimensional space data Point = Point Float Float deriving (Show) data Shape = Circle Point Float | Rectangle Point Point deriving (Show) When defining a point, we used the name for the data type and its value constructor. This has no special meaning. The surface function must now be adjusted surface :: Shape -&gt; Float surface (Circle r) = pi * r ^ 2 surface (Rectangle (Point x1 y1) (Point x2 y2)) = (abs $ x2 - x1) * (abs $ y2 - y1) When calculating the area of the rectangle we use nested pattern matching to access the fields. We can defined a function to modify the position of a shape nudge :: Shape -&gt; Float -&gt; Float -&gt; Shape nudge (Circle (Point x y) r) a b = Circle (Point (x+a) (y+b)) r nudge (Rectangle (Point x1 y1) (Point x2 y2)) a b = Rectangle (Point (x1+a) (y1+b)) (Point (x2+a) (y2+a)) &gt; nudge (Circle (Point 34 34) 10) 5 10 &gt; Circle (Point 39.0 44.0) 10.0 If we don’t want to deal directly with points, we can make auxiliary functions that create shapes of some size at the zero coordinates and then nudge those. baseCircle :: Float -&gt; Shape baseCircle r = Circle (Point 0 0) r baseRect :: Float -&gt; Float -&gt; Shape baseRect width height = Rectangle (Point 0 0) (Point width height) &gt; nudge (baseRect 40 100) 60 23 &gt; Rectangle (Point 60.0 23.0) (Point 100.0 123.0) These data types can be exported in modules. Write the type along with the functions to be exported, and then add parentheses and specify the value constructors to be exported for it. To export all the value constructors for a type, just write .. module Shapes ( Point(..) , Shape(..) , surface , nudge , baseCircle , baseRect ) where By writing Shape(..) we exported all the value constructors for Shape. This is the same as writing Shape(Rectangle, Circle). We could opt not to export the value constructors for Shape by just writing Shape. This would mean that any user of the module could only make shapes using the auxiliary functions baseCircle and baseRect. Record syntax Suppose we wish to create a data type to contain information about a person. data Person = Person String String Int Float String String deriving (Show) &gt; let guy = Person \"Buddy\" \"Finklestein\" 43 184.2 \"526-2928\" \"Chocolate\" &gt; guy Person \"Buddy\" \"Finklestein\" 43 184.2 \"526-2928\" \"Chocolate\" This is somewhat unreadable. Now suppose that we cant to create a function to get individual pieces of information from a Person. firstName :: Person -&gt; String firstName (Person firstname _ _ _ _ _) = firstname lastName :: Person -&gt; String lastName (Person _ lastname _ _ _ _) = lastname age :: Person -&gt; Int age (Person _ _ age _ _ _) = age height :: Person -&gt; Float height (Person _ _ _ height _ _) = height phoneNumber :: Person -&gt; String phoneNumber (Person _ _ _ _ number _) = number flavor :: Person -&gt; String flavor (Person _ _ _ _ _ flavor) = flavor This is tedious to write. Instead we can write out data type as follows data Person = Person { firstName :: String , lastName :: String , age :: Int , height :: Float , phoneNumber :: String , flavor :: String } deriving (Show) We define a name for each field, and then specify its type. Functions are automatically created for looking up fields. The functions have the same name as the fields. &gt; :t flavor &gt; flavor :: Person -&gt; String When we derive Show, the output is also much more useful. data Car = Car String String Int deriving (Show) &gt; Car \"Ford\" \"Mustang\" 1967 Car \"Ford\" \"Mustang\" 1967 data Car = Car {company :: String, model :: String, year :: Int} deriving (Show) &gt; Car {company=\"Ford\", model=\"Mustang\", year=1967} Car {company = \"Ford\", model = \"Mustang\", year = 1967} When making a new Car we don’t have to put the fields in their proper order, as long as we list all of them. If we were not using record syntax, we would have to specify them in order. Record syntax should be used when there are numerous parameters which are not immediately distinguishable. Type parameters A value constructor can take some values as parameters and then produce a new value. In a similar manner, type constructors take types as parameters and produce new types. data Maybe a = Nothing | Just a The a above is the type parameter. Because there is a type parameter involved, we call Maybe a type constructor. Depending on what we want this data type to hold when it is not Nothing, this type constructor can produce a type of Maybe Int, Maybe String or any other Maybe type. No value can have a type of just Maybe, because that is not a type, only a type constructor. If we pass Char as the type parameter to Maybe, we get a type of Maybe Char. The value Just 'a' has a type of Maybe Char. &gt; Just \"String\" &gt; Just \"String\" &gt; Just 84 &gt; Just 84 &gt; :t Just \"String\" &gt; Just \"String\" :: Maybe [Char] &gt; :t Just 84 &gt; Just 84 :: (Num t) =&gt; Maybe t &gt; :t Nothing &gt; Nothing :: Maybe a &gt; Just 10 :: Maybe Double &gt; Just 10.0 Type parameters are useful because we can make different types with them depending on what kind of types we want contained in our data type. The type of Nothing is Maybe a. It is polymorphic. If some function requires Maybe Int as a parameter, we can give it Nothing, because Nothing doesn’t contain a value anyway. The Maybe a type can act like a Maybe Int if it has to. Similarly, the type of an empty list is [a], so an empty list can act like anything. Another parametrized type is Map k v. Having maps parametrized enables us to have mappings from any type to any other type, as long as the type of the key is part of the Ord typeclass. If we were defining a mapping type, we could add a typeclass constraint in the data declaration. data (Ord k) =&gt; Map v k = ... It is a very strong convention in Haskell to never add typeclass constraints in data declarations. This is because we don’t benefit a lot, but we end up writing more class constraints, even when we don’t need them. If we put or don’t put the Ord k constraint for Map k v, we will have to put the constraint into functions that assume the keys in a map can be ordered. If we don’t put the constraint in the data declaration, we don’t have to put (Ord k) =&gt; in the type declarations of functions that don’t care whether the keys can be ordered. An example is toList, which has a type signature of toList :: Map k a -&gt; [(k, a)] rather than having to have a type constraint toList :: (Ord k) =&gt; Map k a -&gt; [(k, a)] without actually doing any comparing of keys. We don’t put type constraints in data declarations because they will have to be put in function type declarations anyway. A 3d vector type and some operations are defined as follows data Vector a = Vector a a a deriving (Show) vplus :: (Num t) =&gt; Vector t -&gt; Vector t -&gt; Vector t (Vector i j k) `vplus` (Vector l m n) = Vector (i+l) (j+m) (k+n) vectMult :: (Num t) =&gt; Vector t -&gt; t -&gt; Vector t (Vector i j k) `vectMult` m = Vector (i*m) (j*m) (k*m) scalarMult :: (Num t) =&gt; Vector t -&gt; Vector t -&gt; t (Vector i j k) `scalarMult` (Vector l m n) = i*l + j*m + k*n We use a parametrized type because the vector should support several numeric types. vplus is use to add two vectors together. scalarMult is for the scalar product of two vectors, and vectMult is for multiplying a vector with a scalar. These functions can operate on types of Vector Int, Vector Integer, Vector Float, and any other type from the Num typeclass. It is very important to distinguish between the type constructor and the value constructor. When declaring a data type, the part before the = is the type constructor and the constructors after it are value constructors. Derived instances A type can be an instance of a typeclass if it supports a particular behaviour. Haskell can automatically make a type an instance of any of the following typeclasses: Eq, Ord, Enum, Bounded, Show, Read. When we derive the Eq instance for a type and then try to compare two values, Haskell will see if the value constructors match, and it will then check if all the data contained inside matches by testing each pair of fields, each of which also have to be part of the Eq typeclass. We can derive instances for the Ord typeclass. If we compare two values of the same type that were made using different constructors, the value which was made with a constructor that’s defined first is smaller. data Bool = False | True deriving (Ord) Because the False constructor is specified first, we can consider True to be greater than False. In the Maybe a data type, the Nothing value constructor is specified before the Just value constructor. We can use algebraic data types to make enumerations with the Enum and Bounded typeclasses. data Day = Monday | Tuesday | Wednesday | Thursday | Friday | Saturday | Sunday deriving (Eq, Ord, Show, Read, Bounded, Enum) Day can be made part of the Enum typeclass because all the value constructors are nullary, taking no parameters. &gt; show Wednesday &gt; \"Wednesday\" &gt; read \"Saturday\" :: Day &gt; Saturday &gt; Saturday &gt; Friday &gt; True &gt; minBound :: Day &gt; Monday &gt; succ Monday &gt; Tuesday &gt; [Thursday .. Sunday] &gt; [Thursday, Friday, Saturday, Sunday] Type synonyms Type synonyms allow giving different names to complex types. type String = [Char] We are not actually defining a new type, only creating a synonym for an existing one. In the same way that functions can be partially applied, type parameters can also be partially applied type IntMap v = Map Int v or type IntMap = Map Int The Either data type takes two types as its parameters. data Either a b = Left a | Right b deriving (Eq, Ord, Read, Show) Either is useful to return a value and a possinle error. Recursive data structures We can make types whose constructors have fields that are of the same type. data List a = Empty | Cons a (List a) deriving (Show, Read, Eq, Ord) This list definition is either empty or a combination of a head value and a list. Cons is another word for :. We can define functions to be automatically infix by making them comprised of special characters. infixr 5 :-: data List a = Empty | a :-: (List a) deriving (Show, Read, Eq, Ord) When we define functions as operators, we can give them a fixity. The fixity states the associativity and the strength of the binding. &gt; 3 :-: 4 :-: 5 :-: Empty &gt; (:-:) 3 ((:-:) 4 ((:-:) 5 Empty)) When deriving Show for the type, Haskell will display it as if the constructor was a prefix function. Binary search tree data Tree a = EmptyTree | Node a (Tree a) (Tree a) deriving (Show, Read, Eq) Instead of manually building a tree, we can make a function that takes a tree and an element and inserts an element. singleton :: a -&gt; Tree a singleton x = Node x EmptyTree EmptyTree treeInsert :: (Ord a) =&gt; a -&gt; Tree a -&gt; Tree a treeInsert x EmptyTree = singleton x treeInsert x (Node a left right) | x == a = Node x left right | x &lt; a = Node a (treeInsert x left) right | x &gt; a = Node a left (treeInsert x right) treeElem :: (Ord a) =&gt; a -&gt; Tree a -&gt; Bool treeElem :: x EmptyTree = False treeElem :: x (Node a left right) | x == a = True | x &lt; a = treeElem x left | x &gt; a = treeElem x right We can use a fold to build up a tree from a list. &gt; let nums = [8,6,4,1,7,3,5] &gt; let numsTree = foldr treeInsert EmptyTree nums &gt; numsTree &gt; Node 5 (Node 3 (Node 1 EmptyTree EmptyTree) (Node 4 EmptyTree EmptyTree)) (Node 7 (Node 6 EmptyTree EmptyTree) (Node 8 EmptyTree EmptyTree)) Typeclasses The Eq typeclass is defined as follows class Eq a where (==) :: a -&gt; a -&gt; Bool (/=) :: a -&gt; a -&gt; Bool x == y = not (x /= y) x /= y = not (x == y) data TrafficLight = Red | Yellow | Green instance Eq TrafficLight where Red == Red = True Green == Green = True Yellow == Yellow = True _ == _ = False While Eq could have been implemented automatically, the code above demonstrates how it can be implemented by hand. The instance keyword is for making type instancs of typeclasses. Because == was defined in terms of ‘/=’ and vice versa in the class declaration, we only had to overwrite one of them in the instance. instance Show TrafficLight where show Red = \"Red light\" show Yellow = \"Yellow light\" show Green = \"Green light\" Typeclasses can also be subclasses of other typeclasses. class (Eq a) =&gt; Num a where This states that we have to make a type an instnace of Eq before it can be made an instance of Num. In the declaration of Eq we can see that a is used as a concrete type because all the types in functions have to be concrete types. For Maybe we must write instance Eq (Maybe m) where Just x == Just y = x == y Nothing == Nothing = True _ == _ = False We must also ensure that m is an instance of Eq to allow it to be compared. instance (Eq m) =&gt; Eq (Maybe m) where ... Most of the time, class constraints in class declarations are used for making a typeclass a subclass of another typeclass and class constraints in instance declarations are used to express requirements about the contents of some type. The :info command can be used to display information about a typeclass. Yes-No typeclass In some weakly typed languages, anything can be passed to a conditional expression. In JavaScript, non empty strings, and non 0 numbers are considered to be True. We could implement this in Haskell class YesNo a where yesno :: a -&gt; Bool instance YesNo Int where yesno 0 = False yesno _ = False instance YesNo [a] where yesno [] = False yesno _ = True instance YesNo Bool where yesno = id -- id is a standard library function which takes a parameter and returns the same thing instance YesNo (Maybe a) where yesno (Just _) = True yesno Nothing = False &gt; yesno $ length [] &gt; False &gt; yesno \"test\" &gt; True &gt; yesno \"\" &gt; False &gt; :t yesno &gt; Yesno :: (YesNo a) =&gt; a -&gt; Bool We can now create a function that mimics the if statement, but works with YesNo values yesnoIf :: (YesNo y) =&gt; y -&gt; a -&gt; a -&gt; a yesnoIf yesnoVal yesResult noResult = if yesno yesnoVal then yesResult else noResult The Functor typeclass class Functor f where fmap :: (a -&gt; b) f a -&gt; f b The Functor typeclass defines a single function, fmap. f is not a concrete type, but a type constructor that takes one parameter. fmap takes a function from one type to another and a functor applied with one type and returns a functor applied with another type. The list is an instance of the Functor typeclass instance Functor [] where fmap = map We didn’t write instance Functor [a] because from fmap :: (a -&gt; b) -&gt; f a -&gt; f b we see that the f has to be a type constructor that takes one type. [a] is a concrete type, while [] is a type constructor that takes one type. Types that can act like a box can be functors. Maybe can act like a box, holding Just &lt;something&gt; or Nothing. instance Functor Maybe where fmap f (Just x) = Just (f x) fmap f Nothing = Nothing Again we did not specify a type. Functor wants a type constructor that takes one type and not a concrete type. The Tree a can be mapped over and made an instance of Functor. instance Functor Tree where fmap f EmptyTree = EmptyTree fmap f (Node x leftsub rightsub) = Node (f x) (fmap f leftsub) (fmap f righsub) The fmap function for Tree recursively applies f to each of the items in the Tree. &gt; fmap (*4) (foldr treeInsert EmptyTree [5,7,3,2,1,7]) &gt; Node 28 (Node 4 EmptyTree (Node 8 EmptyTree (Node 12 EmptyTree (Node 20 EmptyTree EmptyTree)))) EmptyTree Now consider Either a b. The Functor typeclass wants a type constructor that takes only one type parameter, but Either takes two. We can partially apply Either by feeding it only one parameter, so that it has one free parameter. instance Functor (Either a) where fmap f (Right x) = Right (f x) fmap f (Left x) = Left x Either a is a type constructor that takes one parameter. The type signature for this specific fmap will be (b -&gt; c) -&gt; Either a b -&gt; Either a c In the implementation, we mapped in the case of a Right value constructor but not in the case of a Left. If we wanted to map one function over both of them, a and b would have to be the same type. Maps from Data.Map can also be made a functor because they hold values. fmap will map a function v -&gt; v' over a map of type Map k v and return a map of type Map k v'. Functors should obey some laws. fmap id = id fmap (g . f) = fmap g . fmap f Kinds Functions are also values because we can pass them etc. Types are like labels carried by values so that we can reason about them. Types have their own labels called kinds. A kind is something like the type of a type. &gt; :k Int &gt; Int :: * A * means that the type is a concrete type, a type without type parameters. &gt; :k Maybe &gt; Maybe :: * -&gt; * The Maybe constructor takes one concrete type, and then returns a concrete type. &gt; :k Maybe Int &gt; Maybe Int :: * We use :k on a type to get its kind, just like :t on a value to get its type. &gt; :k Either &gt; Either :: * -&gt; * -&gt; * &gt; :k Either Int &gt; Either Int :: * -&gt; * Either takes two concrete types as type parameters to produce a concrete type. A partially applied either takes a single concrete type to produce a concrete type. class Tofu t where tofu :: j a -&gt; t a j Because j a is used as the type of a value that the tofu function takes as its parameter, j a has to have a kind of *. We assume * for a so we can infer that j has to have a kind of * -&gt; *. We see that t has to produce a concrete value to, and that it takes two types. Knowing that a has a kind of * and j has a kind of * -&gt; *, we infer that t has to have a kind of * -&gt; (* -&gt; *) -&gt; *. So, it takes a concrete type (a), a type constructor that takes one concrete type (j) and produces a concrete type. data Frank a b = Frank {frankField :: b a} deriving (Show) This type has a kind of * -&gt; (* -&gt; *) -&gt; *. Fields in algebraic data types are made to hold values, so the must be of kind *. We assume * for a, which means that b takes one type parameter and so its kind is * -&gt; *. We now see that Frank has a kind of * -&gt; (* -&gt; *) -&gt; *. &gt; :t Frank {frankField = Just \"String\"} &gt; Frank {frankField = Just \"String\"} :: Frank [Char] Maybe &gt; :t Frank {frankField = \"String\"} &gt; Frank {frankField = \"String\"} :: Frank Char [] Because frankField has a type of form a b, its values must have types that are of a similar form as well. They can be Just \"String\", which has a type of Maybe [Char], or they can have a value of ['S', 't', 'r', 'i', 'n', 'g'] which has a type of [Char]. Making Frank an instance of Tofu is quite simple. tofu takes a j a, and returns a type of t a j instance Tofu Frank where tofu x = Frank x &gt; tofu (Just 'a') :: Frank Char Maybe &gt; Frank {frankField = Just 'a'} &gt; tofu [\"HELLO\"] :: Frank [Char] [] &gt; Frank {frankField = [\"HELLO\"]} This has no real use. A more complicated type is: data Barry t k p = Barry { yabba :: p, dabba :: t k} Now we want to make it an instance of Functor. Functor wants types of kind * -&gt; * It is safe to assume that p is a concrete type, and thus has a kind of *. For k, we assume *, and so t has a kind of * -&gt; *. Barry has a kind of (* -&gt; *) -&gt; * -&gt; * -&gt; *. Now we can make this type a part of Functor. We have to partially apply the first two type parameters, so that we are left with * -&gt; *. This means that the start of the instance declaration will be instance Functor (Barry a b) where. Considering fmap specifically for Barry, it would have type fmap :: (a -&gt; b) -&gt; Barry c d a -&gt; Barry c d b when the Functor’s f is replaced with Barry c d. instance Functor (Barry a b) where fmap f (Barry {yabba = x, dabba = y}) = Barry {yabba = f x, dabba = y} Input and output The function putStrLn prints a string &gt; :t putStrLn &gt; putStrLn :: String -&gt; IO () putStrLn takes a string and returns an IO action, that has a result type of (). An IO action is something that, when performed, will carry out an action with a side-effect, and will also contain some kind of return value. Printing a string doesn’t have a meaningful return value, so an empty tuple is returned. An IO action will be performed when we give it a name of main and then run our program. main = do putStrln \"Hello, what is your name?\" name &lt;- getLine putStrLn (\"Hello\" ++ name) main always has a type signature of main :: IO &lt;type&gt; where &lt;type&gt; is some concrete type. By convention, we do not usually specify a type declaration for main. getLine reads a line from the input, it has a type getLine :: IO String. The line name &lt;- getLine can be read as perform the IO action and then bind its result to name. As getLine has a type IO String, name will have a type of String. We can only take the data from getLine with &lt;- from within another IO action. getLine is impure because its result value is not guaranteed to be the same when performed twice. In a do block, the last action cannot be bound to a name. IO actions will only be performed when they are given a name of main or when they are inside a bigger IO faction that we composed with a do block. main = do line &lt;- getLine if null line then return () else do putStrLn $ reverseWords line main reverseWords :: String -&gt; String reverseWords = unwords . map reverse . words The program above reads input and reverses it until a blank line is input. In an IO do block, ifs have to have a form of if condition then IO action else IO action. Because we have to do exactly one IO action after the else, we use a do block to glue together two IO actions into one. Haskell return While return in most languages ends execution of a method or subroutine, in Haskell (IO actions specifically), it makes an IO action out of the pure value. Using return does not cause the IO do block to end execution. All these returns do is make IO actions that don’t do anything. We can use return in combination with &lt;- to bind to names. main = do a &lt;- return \"String\" b &lt;- return \"gnirtS\" putStrLn $ a ++ \" \" ++ b When dealing with IO blocks we mostly use return either because we need to create an IO action that does not do anything or because we do not want the IO action that is made up from a do block to have the result value of its last action. IO functions putStr takes a string as a parameter and returns an IO action that will print without a newline putChar takes a character as a parameter and returns an IO action that will print it print takes a value of a type that is an instance of Show, and prints it getChar an IO action that reads a character form input. Reading does not happen until the user presses the enter key when is found in Control.Monad. In a do block it appears like a control flow statement, but it is a function. It takes a boolean value and an IO action. If the boolean value is True, it returns the same IO action passed to it, otherwise it returns the return () action. sequence takes a list of IO actions and returns an IO action which will perform all of the Io actions in the list. sequence :: [IO a] -&gt; IO [a] mapM and mapM_ mapM takes a function and a list, maps the function over the list and then sequences it, mapM_ does the same except that it throws away the result later. mapM_ is used when we do not care what result our sequenced IO actions have forever located in Control.Monad, takes an IO action and returns an IO action that repeats the IO action forever forM located in Control.Monad, is like mapM except that it has its parameters switched around. The first parameter is the list and the second is the function to map over that list, which is then sequenced import Control.Monad main = do colors &lt;- forM [1,2,3,4] (\\a -&gt; do putStrLn $ \"Which color do you associate with the number \" ++ show a ++ \"?\" color &lt;- getLine return color) putStrLn \"The collors that you associate with 1, 2, 3, and 4 are: \" mapM putStrLn colors The (\\a -&gt; do ...) is a function that takes a number and returns an IO action. We have to surround it with parentheses, otherwise the lambda thinks the last two IO actions below to it. We do return color in the inside do block. We do that so that the IO action which the do block defines has the result of our color contained within it. We could have left the last line as getLine. The forM called with its two parameters, produces an IO action, whose result we bind to colors. colors is just a list of strings. At the end we print out those strings with mapM putStrLn colors. forM can be thought of as meaning ‘make an IO action for every element in this list, perform those actions and bind their results to something’. Files and streams getContents is an IO action that reads everything from the standard input until it encounters an end-of-file character. Its type is getContents :: IO String. getContents does lazy IO. The pattern of getting some string from the input, transforming it with a function, and then outputting the result is so common that there exists a function for it. interact takes a function of type String -&gt; String as a parameter and returns an IO action that will take some input run that function on it and then print out the function’s result. main = interact shortLinesOnly shortLinesOnly :: String -&gt; String shortLinesOnly input = let allLines = lines input shortLines = filter (\\line -&gt; length line &lt; 10) allLines result = unlines shortLines in result We could write thie in a less readable manner main = interact $ unlines . filter ((&lt;10) . length) . lines interact can be used to make programs that are piped some contents into them and then dump some result out, or it can be used to make programs that appear to take a line of input from the user, give back some result and then take another line and so on. respondPalindromes contents = unlines (map (\\xs -&gt; if isPalindrome xs then \"palindrome\" else \"not a palindrome\") (lines contents)) where isPalindrome xs = xs == reverse xs",
    "tags": "Notes Haskell Functional",
    "url": "/Haskell-Notes"
  },

  
  
  
  {
    "title": "Statistics Notes",
    "text": "SS02 Time series analysis Seasonal variation When asked for the type of variation Seasonal variation If the variations from the fit line appear to follow a pattern Random variation If they don’t Moving averages and seasonal effects Moving averages For Centered moving average The average of the current moving average and the surrounding moving averages The seasonal effect is the average of the values of the difference between the actual values and the centered moving average. Take the centered moving average and subtract it from the actual value for each item in a group. Then calculate the average of these values. Estimation from seasonal effects Once the seasonal effects has been calculated the fit line can be used to find a value for a given time, and the seasonal effect can then be applied to this value to produce an estimate Sampling Simple random samples Assign a range of values to the data Choose random values from the number table, starting from a random position Each item has the same probability of being chosen. If the data is in sections, each section may not be represented. May not give correct representations of strata. Stratified random sampling There may often be factors which divide up the population into groups (strata), and we may expect the measurement of interest to vary among the different groups. This can be accounted for when we select a sample from the population in order that we obtain a sample that is representative of the population. We generally require that the proportion of each stratum in the sample should be the same as in the population. Stratified sampling techniques are generally used when the population is heterogeneous, or dissimilar, where certain homogeneous sub populations can be isolated. Some reasons for using stratified sampling over simple random sampling are: The cost per observation may be reduced Estimates of the population parameters may be wanted for each sub-population Increased accuracy at a given cost Cluster, quota, and systematic sampling Cluster sampling The data is is divided into separate groups. Then a simple random sample of clusters is selected from the population. The population is divided into groups, called clusters The researcher randomly selects clusters to include in the sample The number of observations within each cluster is known, and . One-stage sampling All of the elements within selected clusters are included in the sample Two-stage sampling A subset of elements within selected clusters are randomly selected for inclusion in the sample Sometimes, the cost per sample point is less for cluster sampling than for other sampling methods. Given a fixed budget, the researcher may be able to use a bigger sample with cluster sampling than with the other methods. When the increased sample size is sufficient to offset the loss in precision, cluster sampling may be the best choice. Application: Select a cluster grouping as a sampling frame Mark each cluster with a unique number Choose a sample of clusters applying probability sampling Quota sampling Quota sampling requires, that representative individuals are chosen from a specific subgroup Advantages: Primary collection can be done in a short time The application of quota sampling can save costs and time Quota sampling is not dependent on the presence of the sampling frames. Disadvantages: It is not possible to calculate the sampling error Other important characteristics may be disproportionately represented in the final sample group There is a potential for researcher bis and the quality of work may suffer due to researcher incompetency Systematic sampling A sampling method in which the first position in the data set is randomly chosen, and every position after this is also chosen Advantages: Allows the researcher to add a degree of system or process into the random selection Known and equal probability of selection The assurance that the population will be evenly sampled. Simple random sampling allows a clustered selection of subjects Disadvantages: The process of selection can interact with a hidden periodic trait within the population The process can also hide a periodic trait Discrete probability distributions Expectations and variance Poisson (Same as MS02) Interpretation of data Pie charts Line diagrams Box and whisker plots Frequency diagrams Scatter diagrams Histograms not required Hypothesis testing Tests for means Errors Type I error: Rejecting a true null hypothesis Type II error: Accepting a false null hypothesis If it says test. State the fucking hypotheses! Tests Test Details Case to reject   SS02       Z/T test Determines whether two population means are different TV &gt; CV   SS03       Contingency tables A test for independence CV &gt; TV   Sign test Test for difference in medians TV &lt; CV   Wilcoxon Test for difference in mean or median TV &lt; CV   Mann-Whitney Test for equality of population TV &lt; CV   Kruskal-Wallis Test for equality of population of two or more samples TV &gt; CV   Correlation coefficient Test for existence of correlation between two random variables TV &gt; SL   SS04       Poisson Test for change in a Poisson variable TV &lt; SL   Proportion Test whether sample proportion represents the population TV &lt; SL   SS05       Variance Tests a sample for a given population variance TV &gt; CV(Upper) or TV &lt; CV(Lower)   Variance equality of samples (F) Test for equality of the variances of the populations of two samples of two normally distributed random variables TV &gt; CV   Difference in mean (Two sample Z) Test for the difference in the means of two independent populations |TV| &gt; |CV|   Difference in mean (Two sample T) Test for the difference in the means of two independent populations with unknown variances |TV| &gt; |CV|   Goodness of fit Test for the fit of a sample to a particular distributio n TV &gt; CV   SS06       Paired comparisons Analysis of the difference between pairs of values sampled from two normal populations TV &gt; CV   Analysis of variance An extension of F tests with more than 2 populations TV &gt; CV   Two way analysis of variance An analysis of variance which accounts for a second factor TV &gt; CV   Latin squares       SS03 Contingency tables State hypotheses (In context) i. : No assocation ii : Assocation Calculate the expected values. If any value is less than 5, merge the rows or columns Calculate the text statistic Find the critical value for degrees of freedom. This can either be done from the table or with If text , reject in context Yates’ correction For a 2 by 2 table, Yates’ correction is used. Rather than the corrected formula is Distribution free methods Test For Use case Sign test Median When Wilcoxon cannot be used as data is not symmetrical or is non-numeric Wilcoxon signed-rank test Median or Mean When a z or t test cannot be used Mann-Whitney U test Equality of populations of two samples There are two samples Kruskal-Wallis test Equality of populations of two or more samples There are more than two samples Sign test The sign test checks for a difference in the median value by comparing each pair. It does not require a symmetric distribution and could be used on non-numeric data so long as the data can be assigned to two groups (e.g. boolean values of opinions) State hypotheses i. that population medians are equal ii. : that population medians are not equal or Find the differences between each pair, ignoring any equal values Count the number of positive differences and the number of negative differences Find the value of Compare the value above with the significance level. If it is less, reject Wilcoxon Signed-rank test The Wilcoxon test is similar to the sign test except that it ranks the differences ignoring their signs. State the hypotheses i. Population average difference (in mean or median) of 0 ii. Population average difference not 0 Rank the absolutes of the differences, giving each rank the sign of its respective difference Calculate and , the sums of the positive and negative ranks respectively. Let Find the critical value, from the table Compare to , rejecting if is smaller Mann-Whitney U-test The Mann-Whitney U test tests whether two samples were taken from the same population. It is used when a t test cannot be applied as the data is not normal State the hypotheses i. The samples are from the same population, ii. The samples are from different populations, Rank the entire dataset and calculate the sum of the ranks for each set Calculate the test statistic for each set where is the sum of the ranks of the set and is the size of the set. Let Find the critical value for the significance level and the size of each data set If is less than the critical value, reject Kruskal-Wallis test The Kruskal-Wallis test is a non-parametric version of the ANOVA test. It determines a difference between samples State the hypotheses i. All samples are from the same population ii. Samples are from different populations Rank the entire dataset and calculate the sum of the ranks of each set Calculate the test statistic where is the sum of all samples sizes, and and are the rank sums and sizes of each sample Find the degrees of freedom, the number of samples minus one Calculate the critical value for the given significance level either from the tables or with If the test statistic is larger than the critical value, reject Correlation Spearman’s Rank Correlation Coefficient Spearman’s rank correlation coefficient is used when the data is ranked. The value is given by where is the difference between the rank of a pair of values, and is the (equal) size of each dataset Testing with the correlation coefficient A test can be carried out in order to determine whether there is or is not a correlation between two random variables. Assuming that the correlation coefficient, , is already known. State the hypotheses i. (independent) ii. (not-independent) Find the critical value from the table If the correlation coefficient is greater than the critical value, reject SS04 Linear combinations of independent normal variables If the letters and are variables and the letters and are constants then A linear combination of independent, normal variables will itself be normally distributed Given a normal distribution , if an event is given which is times then this new event has a distribution . The standard deviation of the new event is then . Given two normal distributions , and the normally distributed random variable has the distribution . Approximating distributions The purpose of making an approximation is: To reduce the amount of calculation To allow tables to be used where they otherwise could not To calculate confidence intervals The binomial distribution may be approximated by the Poisson distribution if and The conditions for the approximations are rules of theu,b. They are not shar dividing lines between good approximations and bad approximations The binomial distribution may be approximated by the normal distribution if and The Poisson distribution may be approximated by the normal distribution if Confidence intervals An estimate of a population standard deviation calculated from a random sample of size has degrees of freedom If is the mean of a random sample of size from a normal distribution with mean a confidence interval for is given by Further confidence intervals If is an observation from a Poisson distribution with mean then an approximate confidence interval for is given by , provided that is reasonably large, say If is an observation from a binomial distribution with parameters then an approximate confidence interval for is given by , provided is reasonably large, say Further hypothesis testing for means To carry out a hypothesis test for a mean based on a sample from a normal distribution with an unknown standard deviation: The test statistic is where Hypothesis tests for proportions and for the mean of a Poisson distribution To test hypotheses about a binomial population proportion, , either: a. Determine the cumulative binomial probability of State that the mean remains the same, and that it exhibits the expected change. Then find the probability that this value occurs, and reject if the probability is higher than the level of the test. b. use The hypotheses are then dealt with like a regular normal hypothesis test. To test hypotheses about a Poisson population mean , either a. Determine the cumulative Poisson probability of , or b. use SS05 Continuous probability distributions The random variables having probability density function where and are constants, it is said to follow a rectangular distribution The mean of is and the variance of is The exponential distribution has probability density function The exponential distribution with parameter has mean and standard deviation is known as the cumulative distribution function and is usually denoted For the exponential distribution with parameter , If and are two constants and , the probability that takes a value between and is The intervals between successive events from a Poisson distribution with mean are distributed according to the exponential distribution with parameter Estimation If denotes the variance estimate from a random sample of size from a normal population with variance of , then The distribution is not symmetric so both lower and upper percentage points need to be read from tables A confidence interval for a normal population variance, , is given by and Confidence limits for a normal population standard deviation, are found by taking the square root of those calculated for the population variance Hypothesis testing: one sample tests To test hypotheses about a normal population variance, or standard deviation , use To test hypotheses about a normal population with mean, , use Hypothesis testing: two-sample tests To test hypotheses about the equality of two normal population variances, or standard deviations, use To test hypotheses about the equality of (or given differece in) two normal population means, based upon independent random samples and known population variances use Note that for and the requirement for normal populations canbe relaxed and/or sample variances can be used as estimates of the population variances To test hypotheses about the equality of (or given difference in) two normal population means, based upon independent random samples and unknown but equal population variances use where Testing for goodness of fit may be approximated by a distribution provided that The s are frequenceies, The s are at least five, The classes form a sample space that is, every possible observation fits into one and only one class The number of degrees of freedom is the number of classes, minus the number of independent pieces of information derived from the s in order to calculate the s If there are classes and any necessary parameters are estimated from the data the number of degrees of is for a Poisson, binomial, or exponential distribution, and for a normal distribution SS06 Experimental design Experimental error is the effect of factors other than those controlled by the experimenter In a paired comparison, experimental error is reduced by applying both treatments to the same subjects or in the same conditions The purpose of randomisation is to eliminate bias Blocking is used to reduce experimental error by applying treatments (usually more than two) to the same subjects or in the same conditions If a new treatement is applied to an experimental group, a control group, which receives no treatment or the standard treatment, is needed to act as a measure of the effect of not applying the new treatment A placebo is a pill or treatment which contains no active ingredient In a blind trial subjects do not know whether they are receiving the treatment or a placebo In a double blind trial neither the subject nor the person administering the treatment knows whether a placebo or an active drug is being given Analysis of paired comparisons If and denote the mean and standard deviation, respectively, of a random sample of differences that can be assumed to be normally distributed with mean then Analysis of variance (ANOVA) The assumptions for the three models considered, one and two factor ANOVAs, and Latin square designs, are that: a. The observations are obtained independently and randomly from populations at each factor level (combination) b. These populations are (approximately) normally distributed with common variance $\\sigma^2$ c. When two or more factors are involved, there is no interaction between them One way ANOVA table Source of variation Sum of squares Degrees of freedom Mean square F ratio Between samples Within samples   Total     Two way ANOVA table Source of variation Sum of squares Degrees of freedom Mean square F ratio Between rows Between columns   Error   Total     Provided in the formulae booklet Statistical process control Statistical process control may be used when a large number of similar items are being produced. Its purpose is to give a signal when the process mean has moved away from the target value or when item-to-item variability has increased For control charts for means: Sample mean between warning limits- No action Sample mean between arning and action limits- Take another sample immediately. If new sample mean outside warning limits take action Sample mean outside action limits- Take action The warning limits are set at , and the action limits at , where is the target value, is the short-term standard deviation, and is the sample size Variability may be controlled by plotting the sample ranges or standard deviations on control charts. The limits for these charts are found by multiplying the process short-term standard deviation found by factors in the control charts for variability (Table 12) When the standard deviation must be estimated from a number of small samples the average sample range can be calculated and a factor from table 12 applied. Alternatively can be calculated for each sample and the formula evaluated If the tolerance width exceeds six standard deviations the process should be able to meet the tolerances consistently, provided the mean is kept on target For charts for proportion non-conforming providing is reasonably large: The warning limits are The action limits are Acceptance sampling Acceptance sampling may be applied to large batches of similar items. It is the process of deciding whether or not the batch is acceptable by testing a small sample of the items The operating characteristic for an acceptance sampling by attributes plan is a graph of probability of acceptance against proportion non-conforming in the batch The probabilities may be found from the binomial distribution provided the sample is random and the sample size is small compared to the batch In double sampling, the number of non-conforming items in the first sample will determine whether a decision is made immediately or whether it is delayed until a second sample has been inspected For acceptance sampling by variables the operating characteristic is a graph of probability of acceptance against batch mean MS03 Bayes’ theorem Example Event P(A) P(B) C 0.3 0.8 D 0.5 0.1 E 0.2 0.4 After event A, event B occured. Find the probability that event E occured. Let F be the probability that event B occured. Linear combinations of random variables Covariance is a measure of the joint variability of two random variables. The covariance can be used to find the product moment correlation coefficient of two random variables: The variance can also be computed as Distributional approximations Mean and variance of binomial and Poisson distributions Proof of for binomial Proof of for binomial",
    "tags": "Notes Statistics",
    "url": "/Statistics-Notes"
  }

]};

    
  
/*
Tipue Search 6.1
Copyright (c) 2017 Tipue
Tipue Search is released under the MIT License
http://www.tipue.com/search
*/


/*
Stop words
Stop words list from http://www.ranks.nl/stopwords
*/

var tipuesearch_stop_words = ["a", "about", "above", "after", "again", "against", "all", "am", "an", "and", "any", "are", "aren't", "as", "at", "be", "because", "been", "before", "being", "below", "between", "both", "but", "by", "can't", "cannot", "could", "couldn't", "did", "didn't", "do", "does", "doesn't", "doing", "don't", "down", "during", "each", "few", "for", "from", "further", "had", "hadn't", "has", "hasn't", "have", "haven't", "having", "he", "he'd", "he'll", "he's", "her", "here", "here's", "hers", "herself", "him", "himself", "his", "how", "how's", "i", "i'd", "i'll", "i'm", "i've", "if", "in", "into", "is", "isn't", "it", "it's", "its", "itself", "let's", "me", "more", "most", "mustn't", "my", "myself", "no", "nor", "not", "of", "off", "on", "once", "only", "or", "other", "ought", "our", "ours", "ourselves", "out", "over", "own", "same", "shan't", "she", "she'd", "she'll", "she's", "should", "shouldn't", "so", "some", "such", "than", "that", "that's", "the", "their", "theirs", "them", "themselves", "then", "there", "there's", "these", "they", "they'd", "they'll", "they're", "they've", "this", "those", "through", "to", "too", "under", "until", "up", "very", "was", "wasn't", "we", "we'd", "we'll", "we're", "we've", "were", "weren't", "what", "what's", "when", "when's", "where", "where's", "which", "while", "who", "who's", "whom", "why", "why's", "with", "won't", "would", "wouldn't", "you", "you'd", "you'll", "you're", "you've", "your", "yours", "yourself", "yourselves"];


// Word replace

var tipuesearch_replace = {'words': [
     {'word': 'tip', 'replace_with': 'tipue'},
     {'word': 'javscript', 'replace_with': 'javascript'},
     {'word': 'jqeury', 'replace_with': 'jquery'}
]};


// Weighting

var tipuesearch_weight = {'weight': [
     {'url': 'http://www.tipue.com', 'score': 20},
     {'url': 'http://www.tipue.com/search', 'score': 30},
     {'url': 'http://www.tipue.com/is', 'score': 10}
]};


// Illogical stemming

var tipuesearch_stem = {'words': [
     {'word': 'e-mail', 'stem': 'email'},
     {'word': 'javascript', 'stem': 'jquery'},
     {'word': 'javascript', 'stem': 'js'}
]};


// Related searches

var tipuesearch_related = {'searches': [
     {'search': 'tipue', 'related': 'Tipue Search'},
     {'search': 'tipue', 'before': 'Tipue Search', 'related': 'Getting Started'},
     {'search': 'tipue', 'before': 'Tipue', 'related': 'jQuery'},
     {'search': 'tipue', 'before': 'Tipue', 'related': 'Blog'}
]};


// Internal strings

var tipuesearch_string_1 = 'No title';
var tipuesearch_string_2 = 'Showing results for';
var tipuesearch_string_3 = 'Search instead for';
var tipuesearch_string_4 = '1 result';
var tipuesearch_string_5 = 'results';
var tipuesearch_string_6 = 'Back';
var tipuesearch_string_7 = 'More';
var tipuesearch_string_8 = 'Nothing found.';
var tipuesearch_string_9 = 'Common words are largely ignored.';
var tipuesearch_string_10 = 'Search too short';
var tipuesearch_string_11 = 'Should be one character or more.';
var tipuesearch_string_12 = 'Should be';
var tipuesearch_string_13 = 'characters or more.';
var tipuesearch_string_14 = 'seconds';
var tipuesearch_string_15 = 'Searches related to';


// Internals


// Timer for showTime

var startTimer = new Date().getTime();


  function defer(e){window.jQuery?e():setTimeout(function(){defer(e)},5)}defer(function(){!function(e){e.fn.tipuesearch=function(t){var a=e.extend({contentLocation:"tipuesearch/tipuesearch_content.json",contextBuffer:60,contextLength:60,contextStart:90,debug:!1,descriptiveWords:25,highlightTerms:!0,liveContent:"*",liveDescription:"*",minimumLength:3,mode:"static",newWindow:!1,show:9,showContext:!0,showRelated:!0,showTime:!0,showTitleCount:!0,showURL:!0,wholeWords:!0},t)
return this.each(function(){function t(e){var t=location.search,a=RegExp("[?|&]"+e+"=([^&;]+?)(&|#|;|$)").exec(t)||[,""],s=a[1].replace(/\+/g,"%20")
try{s=decodeURIComponent(s)}catch(i){s=unescape(s)}return s||null}function s(t,c){var h="",o=!1,l=!1,p=!0,u=0
found=[]
var _=e("#tipue_search_input").val(),g=_.toLowerCase()
g=e.trim(g),(g.match('^"')&&g.match('"$')||g.match("^'")&&g.match("'$"))&&(p=!1)
var d=g.split(" ")
if(p){g=""
for(var f=0;f<d.length;f++){for(var v=!0,w=0;w<tipuesearch_stop_words.length;w++)d[f]==tipuesearch_stop_words[w]&&(v=!1,l=!0)
v&&(g=g+" "+d[f])}g=e.trim(g),d=g.split(" ")}else g=g.substring(1,g.length-1)
if(g.length>=a.minimumLength){if(p){if(c){for(var m=g,f=0;f<d.length;f++)for(var w=0;w<tipuesearch_replace.words.length;w++)d[f]==tipuesearch_replace.words[w].word&&(g=g.replace(d[f],tipuesearch_replace.words[w].replace_with),o=!0)
d=g.split(" ")}for(var x=g,f=0;f<d.length;f++)for(var w=0;w<tipuesearch_stem.words.length;w++)d[f]==tipuesearch_stem.words[w].word&&(x=x+" "+tipuesearch_stem.words[w].stem)
d=x.split(" ")
for(var f=0;f<i.pages.length;f++){for(var b=0,L=i.pages[f].text,w=0;w<d.length&&("/"!=i.pages[f].url&&"/tags"!=i.pages[f].url);w++){if(a.wholeWords)var C=RegExp("\\b"+d[w]+"\\b","gi")
else var C=RegExp(d[w],"gi")
if(-1!=i.pages[f].title.search(C)){var R=i.pages[f].title.match(C).length
b+=20*R}if(-1!=i.pages[f].text.search(C)){var R=i.pages[f].text.match(C).length
b+=20*R}if(-1!=i.pages[f].tags.search(C)){var R=i.pages[f].tags.match(C).length
b+=10*R}if(-1!=i.pages[f].url.search(C)&&(b+=20),0!=b)for(var T=0;T<tipuesearch_weight.weight.length;T++)i.pages[f].url==tipuesearch_weight.weight[T].url&&(b+=tipuesearch_weight.weight[T].score)
d[w].match("^-")&&(C=RegExp(d[w].substring(1),"i"),(-1!=i.pages[f].title.search(C)||-1!=i.pages[f].text.search(C)||-1!=i.pages[f].tags.search(C))&&(b=0))}0!=b&&(found.push({score:b,title:i.pages[f].title,desc:L,url:i.pages[f].url}),u++)}}else for(var f=0;f<i.pages.length;f++){var b=0,L=i.pages[f].text,C=RegExp(g,"gi")
if(-1!=i.pages[f].title.search(C)){var R=i.pages[f].title.match(C).length
b+=20*R}if(-1!=i.pages[f].text.search(C)){var R=i.pages[f].text.match(C).length
b+=20*R}if(-1!=i.pages[f].tags.search(C)){var R=i.pages[f].tags.match(C).length
b+=10*R}if(-1!=i.pages[f].url.search(C)&&(b+=20),0!=b)for(var T=0;T<tipuesearch_weight.weight.length;T++)i.pages[f].url==tipuesearch_weight.weight[T].url&&(b+=tipuesearch_weight.weight[T].score)
0!=b&&(found.push({score:b,title:i.pages[f].title,desc:L,url:i.pages[f].url}),u++)}if(0!=u){if(a.showTitleCount&&0==r){var k=document.title
document.title="("+u+") "+k,r++}if(o&&(h+='<div id="tipue_search_warning">'+tipuesearch_string_2+" "+g+". "+tipuesearch_string_3+' <a id="tipue_search_replaced">'+m+"</a></div>"),1==u?h+='<div id="tipue_search_results_count">'+tipuesearch_string_4:(c_c=(""+u).replace(/\B(?=(\d{3})+(?!\d))/g,","),h+='<div id="tipue_search_results_count">'+c_c+" "+tipuesearch_string_5),a.showTime){var y=(new Date).getTime(),E=(y-startTimer)/1e3
h+=" ("+E.toFixed(2)+" "+tipuesearch_string_14+")",a.showTime=!1}h+="</div>",found.sort(function(e,t){return t.score-e.score})
for(var W=0,f=0;f<found.length;f++){if(W>=t&&W<a.show+t){if(h+='<a class="tipue_search_content_title" href="'+found[f].url+'"'+n+">"+found[f].title+"</a>",a.debug&&(h+='<div class="tipue_search_content_debug">Score: '+found[f].score+"</div>"),a.showURL){var O=found[f].url.toLowerCase()
0==O.indexOf("http://")&&(O=O.slice(7)),h+='<div class="tipue_search_content_url"><a href="'+found[f].url+'"'+n+">"+O+"</a></div>"}if(found[f].desc){var j=found[f].desc
if(a.showContext){d=g.split(" ")
var D=found[f].desc.toLowerCase().indexOf(d[0])
if(D>a.contextStart){var S=j.substr(D-a.contextBuffer),$=S.indexOf(" ")
S=j.substr(D-a.contextBuffer+$),S=e.trim(S),S.length>a.contextLength&&(j="... "+S)}}if(p){d=g.split(" ")
for(var w=0;w<d.length;w++)if(a.highlightTerms){var B=RegExp("("+d[w]+")","gi")
j=j.replace(B,"<h0011>$1<h0012>")}}else if(a.highlightTerms){var B=RegExp("("+g+")","gi")
j=j.replace(B,'<span class="tipue_search_content_bold">$1</span>')}var U="",q=j.split(" ")
if(q.length<a.descriptiveWords)U=j
else for(var w=0;w<a.descriptiveWords;w++)U+=q[w]+" "
U=e.trim(U),"."!=U.charAt(U.length-1)&&(U+=" ..."),U=U.replace(/h0011/g,'span class="tipue_search_content_bold"'),U=U.replace(/h0012/g,"/span"),h+='<div class="tipue_search_content_text">'+U+"</div>"}}W++}if(a.showRelated&&p){w=0
for(var f=0;f<tipuesearch_related.searches.length;f++)g==tipuesearch_related.searches[f].search&&(o&&(_=g),w||(h+='<div class="tipue_search_related_title">'+tipuesearch_string_15+' <span class="tipue_search_related_bold">'+_+'</span></div><div class="tipue_search_related_cols">'),h+='<div class="tipue_search_related_text"><a class="tipue_search_related" id="'+tipuesearch_related.searches[f].related+'">',tipuesearch_related.searches[f].before&&(h+='<span class="tipue_search_related_before">'+tipuesearch_related.searches[f].before+"</span> "),h+=tipuesearch_related.searches[f].related,tipuesearch_related.searches[f].after&&(h+=' <span class="tipue_search_related_after">'+tipuesearch_related.searches[f].after+"</span>"),h+="</a></div>",w++)
w&&(h+="</div>")}if(u>a.show){var I=Math.ceil(u/a.show),Q=t/a.show
if(h+='<nav><div id="tipue_search_foot"><ul id="tipue_search_foot_boxes">',t>0&&(h+='<li role="navigation"><a class="tipue_search_foot_box" accesskey="b" id="'+(t-a.show)+"_"+c+'">'+tipuesearch_string_6+"</a></li>"),2>=Q){var A=I
I>3&&(A=3)
for(var w=0;A>w;w++)h+=w==Q?'<li class="current" role="navigation">'+(w+1)+"</li>":'<li role="navigation"><a class="tipue_search_foot_box" id="'+w*a.show+"_"+c+'">'+(w+1)+"</a></li>"}else{var A=Q+2
A>I&&(A=I)
for(var w=Q-1;A>w;w++)h+=w==Q?'<li class="current" role="navigation">'+(w+1)+"</li>":'<li role="navigation"><a class="tipue_search_foot_box" id="'+w*a.show+"_"+c+'">'+(w+1)+"</a></li>"}Q+1!=I&&(h+='<li role="navigation"><a class="tipue_search_foot_box" accesskey="m" id="'+(t+a.show)+"_"+c+'">'+tipuesearch_string_7+"</a></li>"),h+="</ul></div></nav>"}}else h+='<div id="tipue_search_warning">'+tipuesearch_string_8+"</div>"}else l?h+='<div id="tipue_search_warning">'+tipuesearch_string_8+". "+tipuesearch_string_9+"</div>":(h+='<div id="tipue_search_warning">'+tipuesearch_string_10+"</div>",h+=1==a.minimumLength?'<div id="tipue_search_warning">'+tipuesearch_string_11+"</div>":'<div id="tipue_search_warning">'+tipuesearch_string_12+" "+a.minimumLength+" "+tipuesearch_string_13+"</div>")
e("#tipue_search_content").hide().html(h).slideDown(200),e("#tipue_search_replaced").click(function(){s(0,!1)}),e(".tipue_search_related").click(function(){e("#tipue_search_input").val(e(this).attr("id")),s(0,!0)}),e(".tipue_search_foot_box").click(function(){var t=e(this).attr("id"),a=t.split("_")
s(parseInt(a[0]),a[1])})}var i={pages:[]}
e.ajaxSetup({async:!1})
var r=0
if("live"==a.mode)for(var c=0;c<tipuesearch_pages.length;c++)e.get(tipuesearch_pages[c]).done(function(t){var s=e(a.liveContent,t).text()
s=s.replace(/\s+/g," ")
var r=e(a.liveDescription,t).text()
r=r.replace(/\s+/g," ")
var n=t.toLowerCase().indexOf("<title>"),h=t.toLowerCase().indexOf("</title>",n+7)
if(-1!=n&&-1!=h)var o=t.slice(n+7,h)
else var o=tipuesearch_string_1
i.pages.push({title:o,text:r,tags:s,url:tipuesearch_pages[c]})})
"json"==a.mode&&e.getJSON(a.contentLocation).done(function(t){i=e.extend({},t)}),"static"==a.mode&&(i=e.extend({},tipuesearch))
var n=""
a.newWindow&&(n=' target="_blank"'),t("q")&&(e("#tipue_search_input").val(t("q")),s(0,!0)),e("#search_form").submit(function(e){e.preventDefault()}),e(this).keyup(function(e){"13"==e.keyCode&&s(0,!0)})})}}(jQuery)})


  $(document).ready(function() {
    $('#tipue_search_input').tipuesearch({
      'wholeWords' : false,
      'showURL' : false,
    });
    $('#post-page').anchorific();

    $('#dropdown-button').click(function(event) {
        console.log("TOC click");
        event.stopPropagation();
        $('#dropdown-button').hide();
        $('#toc-content').show();
    });
    $(document).click(function() {
      $('#toc-content').hide();
      $('#dropdown-button').show();
    });

    var elTitleElements = $("#container :header");
    var ulClass = "toc-ul";
    var elTitleElementsLen = elTitleElements.length

    var tocContent = ''
    var tempLists = []

    for (var i = 0; i < elTitleElementsLen; i++) {
      var j = i + 1
      var elTitleElement = elTitleElements[i]
      var elTitleElementName = elTitleElement.tagName
      var id = elTitleElement.getAttribute('id')
      if (!id) {
        elTitleElement.setAttribute('id', 'tip' + i)
        id = '#tip' + i
      } else {
        id = '#' + id
      }

      tocContent += '\n<li>' + elTitleElement.innerHTML;

      if (j !== elTitleElementsLen) {
        elNextTitleElementName = elTitleElements[j].tagName
        if (elTitleElementName !== elNextTitleElementName) {
          var checkColse = false
          var y = 1
          for (var t = tempLists.length - 1; t >= 0; t--) {
            if (tempLists[t].tagName === elNextTitleElementName) {
              checkColse = true
              break
            }
            y++
          }
          if (checkColse) {
            tocContent += new Array(y + 1).join('</li>\n</ul>')
            tempLists.length = tempLists.length - y
          } else {
            tempLists.push(elTitleElement)
            if (ulClass) { tocContent += '<ul class="' + ulClass + '">' } else { tocContent += '<ul>' }
          }
        } else {
          tocContent += '</li>\n'
        }
      } else {
        if (tempLists.length) {
          tocContent += new Array(tempLists.length + 1).join('</li></ul>')
        } else {
          tocContent += '</li>\n'
        }
      }
    }
    if (ulClass) { tocContent = '<ul class="' + ulClass + '">' + tocContent + '</ul>' } else { tocContent = '<ul>' + tocContent + '</ul>' }
    $("#toc-content").html(tocContent);
  });
</script>

			
	</div>
</body>
</html>
