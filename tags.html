<!DOCTYPE html> <html> <head> <meta charset="UTF-8"/> <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1"> <meta name="generator" content="Jekyll"> <title>Tag</title> <meta name="description" content="A minimal, responsive, ready to use blog template, built with Jekyll."> <style type="text/css">*{-webkit-box-sizing:border-box;-moz-box-sizing:border-box;box-sizing:border-box}html,body,h1,h2,h3,h4,h5,h6,p,ul,ol,li,img{margin:0;padding:0;border:0}html{background-color:#fff;font-size:16px;line-height:1.8;color:#333}@media(min-width:940px){html{font-size:18px}}body{max-width:1000px;margin:0 auto;padding:0 10px}a{color:#333;text-decoration:none;font-weight:700}a:hover,a:focus{color:#262626}.f-right{float:right}.f-left{float:left}.clear{clear:both}.parent{display:flex}.inner{align-self:center}.justify-center{justify-content:center}.justify-spaceBetween{justify-content:space-between}.w100{width:100%}.h100{height:100%}.wh100{width:100%;height:100%}.absolute{position:absolute}.relative{position:relative}.top{top:0}.bottom{bottom:0}.right{right:0}.left{left:0}body{font-family:"Roboto","Helvetica Neue","Helvetica","Arial",sans-serif;font-style:normal;font-weight:400;font-size:16px;color:#333}p,ul,ol{font-size:1em;line-height:1.8em;margin-bottom:1.5em}h1{font-size:2.25em;line-height:1.8em;padding:.33335em 0}h2{font-size:1.5em;line-height:1.8em;padding:1em 0 0 0}h3,h4,h5,h6{font-size:1.125em;line-height:1.8em;padding:.66667em 0}blockquote{font-style:italic;margin:1.5em;-webkit-border-radius:4px;-moz-border-radius:4px;-ms-border-radius:4px;border-radius:4px;background-color:#f2f2f2;padding:0 1.5em}blockquote p,blockquote ul,blockquote ol{padding:1.5em 0}@media(min-width:940px){p,ul,ol{font-size:1em;line-height:1.8em;margin-bottom:1.3334em}h1{font-size:2.6667em;line-height:1.8em;padding:.25em 0}h2{font-size:2em;line-height:1.8em;padding:.66667em 0 0 0}h3,h4,h5,h6{font-size:1.3334em;line-height:1.8em;padding:.5em 0}blockquote{font-style:italic;margin:1.3334em;-webkit-border-radius:4px;-moz-border-radius:4px;-ms-border-radius:4px;border-radius:4px;background-color:#f2f2f2;padding:0 1.33334em}blockquote p,blockquote ul,blockquote ol{padding:1.33334em 0}}#nav a,#nav-left a{display:block;color:#333;padding:.33334em 0;font-size:1.5em;font-weight:400}@media(min-width:940px){#nav a,#nav-left a{font-size:1em}}#nav a:hover,#nav-left a:hover{background-color:rgba(13,13,13,0.6)}#nav span,#nav-left span{font-weight:200}#nav{width:14rem;position:fixed;background-color:#fff;top:0;bottom:0;right:-14rem;color:#fff;opacity:.95;-webkit-transition:all .3s ease-in;-moz-transition:all .3s ease-in;-ms-transition:all .3s ease-in;transition:all .3s ease-in;z-index:1;padding:72px 0;text-align:center}#nav-left{width:14rem;position:fixed;background-color:#fff;top:0;bottom:0;left:-14rem;color:#fff;opacity:.95;-webkit-transition:all .3s ease-in;-moz-transition:all .3s ease-in;-ms-transition:all .3s ease-in;transition:all .3s ease-in;z-index:1;padding:72px 0;text-align:center}#nav.menu-open{-webkit-transform:translateX(-14rem);-moz-transform:translateX(-14rem);-ms-transform:translateX(-14rem);transform:translateX(-14rem);width:100%;z-index:100}@media(min-width:940px){#nav.menu-open{width:30%}}#nav-left.menu-open-left{-webkit-transform:translateX(14rem);-moz-transform:translateX(14rem);-ms-transform:translateX(14rem);transform:translateX(14rem);width:100%;z-index:100}@media(min-width:940px){#nav-left.menu-open-left{width:30%}}@media(max-width:940px){#nav-links{display:none}}#nav-links a{padding-left:10px;color:#333;font-weight:300}#nav-list:after{display:block;content:'';width:5rem;height:1px;margin:23px auto;background-color:#333}#nav-menu{display:block;position:fixed;top:35px;right:25px;z-index:10;height:24px;z-index:500}@media(min-width:940px){#nav-menu{display:none}}#nav-menu-left{display:block;position:fixed;top:35px;left:25px;z-index:10;height:24px;z-index:500}@media(min-width:940px){#nav-menu-left{display:none}}#menu{height:4px;width:1.5em;background-color:#333;margin-top:8px}#menu:after,#menu:before{content:"";display:block;position:relative;height:4px;width:1.5em;background-color:#333;transition:all .3s ease-in}#menu:before{top:-8px}#menu:after{top:4px}#menu.btn-close{background:0}#menu.btn-close:before{top:0;-webkit-transform:rotate(-45deg);-moz-transform:rotate(-45deg);-ms-transform:rotate(-45deg);transform:rotate(-45deg);background-color:#333}#menu.btn-close:after{top:-4px;-webkit-transform:rotate(45deg);-moz-transform:rotate(45deg);-ms-transform:rotate(45deg);transform:rotate(45deg);background-color:#333}#container{margin:0 auto}#header{border-bottom:1px solid rgba(0,0,0,0.14);text-align:center;margin-bottom:3em;height:5em;position:relative}#header a{text-decoration:none;display:inline-block}#header div{margin:0 auto}#header h1{font-size:2em;padding-bottom:0}#header h1 span{color:rgba(0,0,0,0.6);font-weight:300}#posts li{list-style-type:none}#post-page{margin-bottom:1.5em}@media(min-width:940px){#post-page{margin-bottom:1.3334em}}.post+.post:before{display:block;content:'';width:5rem;height:1px;margin:23px auto;background-color:#e6e6e6}.by-line{display:block;color:#737373;line-height:1.8em;font-weight:200}
@media(min-width:940px){.by-line{display:block;color:#737373;line-height:1.8em;font-weight:200}}table,th,td{border:1px solid #dfe2e5;border-collapse:collapse;padding:6px 13px;padding-top:6px;padding-right:13px;padding-bottom:6px;padding-left:13px;margin-top:13px;margin-bottom:13px}.table-wrapper{overflow-x:auto;word-break:normal;word-break:keep-all}.MathJax_Display{overflow-x:scroll;overflow-y:hidden;-webkit-overflow-scrolling:touch}.post-info{margin-bottom:1.5em}.post-info>*{display:inline}img{max-width:100%;display:block;margin:0 auto;margin-bottom:24px;-webkit-border-radius:4px;-moz-border-radius:4px;-ms-border-radius:4px;border-radius:4px}img[title="Monochrome"]{box-shadow:0 2px 6px #ddd}.content ul,.content ol{line-height:1.8em;padding-left:1.5em}@media(min-width:940px){.content ul,.content ol{line-height:1.8em}}#page ul,#page ol{padding-left:1.5em}.pagination{text-align:center;margin:2.666668em}.pagination span{background-color:#f2f2f2;color:#333}.pagination a:hover{background-color:#404040}.page-item{background-color:#4d4d4d;color:#fff;padding:4px 8px;font-weight:400;padding:.5em 1em;-webkit-border-radius:4px;-moz-border-radius:4px;-ms-border-radius:4px;border-radius:4px}footer{background-color:#fff;color:#333;text-align:center;margin-top:3em;padding:.6667em 0}pre{overflow:auto;word-wrap:normal;white-space:pre}pre.highlight{background-color:#272822;border-radius:3px;padding:.5em}pre>code{color:#f8f8f2}.highlight pre{background-color:#272822}.highlight .hll{background-color:#272822}.highlight .c{color:#75715e}.highlight .err{color:#960050;background-color:#1e0010}.highlight .k{color:#66d9ef}.highlight .l{color:#ae81ff}.highlight .n{color:#f8f8f2}.highlight .o{color:#f92672}.highlight .p{color:#f8f8f2}.highlight .cm{color:#75715e}.highlight .cp{color:#75715e}.highlight .c1{color:#75715e}.highlight .cs{color:#75715e}.highlight .ge{font-style:italic}.highlight .gs{font-weight:bold}.highlight .kc{color:#66d9ef}.highlight .kd{color:#66d9ef}.highlight .kn{color:#f92672}.highlight .kp{color:#66d9ef}.highlight .kr{color:#66d9ef}.highlight .kt{color:#66d9ef}.highlight .ld{color:#e6db74}.highlight .m{color:#ae81ff}.highlight .s{color:#e6db74}.highlight .na{color:#a6e22e}.highlight .nb{color:#f8f8f2}.highlight .nc{color:#a6e22e}.highlight .no{color:#66d9ef}.highlight .nd{color:#a6e22e}.highlight .ni{color:#f8f8f2}.highlight .ne{color:#a6e22e}.highlight .nf{color:#a6e22e}.highlight .nl{color:#f8f8f2}.highlight .nn{color:#f8f8f2}.highlight .nx{color:#a6e22e}.highlight .py{color:#f8f8f2}.highlight .nt{color:#f92672}.highlight .nv{color:#f8f8f2}.highlight .ow{color:#f92672}.highlight .w{color:#f8f8f2}.highlight .mf{color:#ae81ff}.highlight .mh{color:#ae81ff}.highlight .mi{color:#ae81ff}.highlight .mo{color:#ae81ff}.highlight .sb{color:#e6db74}.highlight .sc{color:#e6db74}.highlight .sd{color:#e6db74}.highlight .s2{color:#e6db74}.highlight .se{color:#ae81ff}.highlight .sh{color:#e6db74}.highlight .si{color:#e6db74}.highlight .sx{color:#e6db74}.highlight .sr{color:#e6db74}.highlight .s1{color:#e6db74}.highlight .ss{color:#e6db74}.highlight .bp{color:#f8f8f2}.highlight .vc{color:#f8f8f2}.highlight .vg{color:#f8f8f2}.highlight .vi{color:#f8f8f2}.highlight .il{color:#ae81ff}.highlight .gu{color:#75715e}.highlight .gd{color:#f92672}.highlight .gi{color:#a6e22e}.dropdown{position:fixed;z-index:10;bottom:1%;right:5%}.dropdown .img{width:24px;height:24px}.dropdown-content{display:none;background-color:#f9f9f9;min-width:160px;box-shadow:0 8px 16px 0 rgba(0,0,0,0.2);padding:12px 16px;z-index:1000;overflow:auto;max-height:80vh;overflow-x:hidden;overflow-y:auto}.dropdown-content ::-webkit-scrollbar{display:none}.dropdown-content ul>li>a{font-weight:700}.dropdown-content ul>li>ul>li>a{font-weight:500}#toc{visibility:hidden}#toc ul{list-style-type:none}#toc ul>li{margin-left:10px}#tipue_search_input,#tipue_search_foot_boxes{font:300 14px/1 Roboto,sans-serif}#tipue_search_results_count,#tipue_search_warning,.tipue_search_content_url,.tipue_search_content_debug,.tipue_search_related_text{font:300 14px/1.7 Roboto,sans-serif}.tipue_search_content_title{color:#000;font:100 26px/1.7 Roboto,sans-serif}.tipue_search_content_text,.tipue_search_related_title{font:300 15px/1.7 Roboto,sans-serif}.tipue_search_content_bold,.tipue_search_related_bold{font-weight:400}#tipue_search_input{color:#000;max-width:210px;padding:17px;border:1px solid rgba(0,0,0,0.6);border-radius:0;-moz-appearance:none;-webkit-appearance:none;box-shadow:none;outline:0;margin:0}.tipue_search_icon{width:24px;height:24px}.tipue_search_left{float:left;padding:15px 9px 0 0}.tipue_search_right{float:left}#tipue_search_content{max-width:750px;padding-top:15px;margin:0}#tipue_search_results_count{color:#000}#tipue_search_warning{color:#fff;margin:7px 0}#tipue_search_warning a{color:#5396ea;text-decoration:none}#tipue_search_warning a:hover{color:#555}.tipue_search_related_title{color:#fff;margin:26px 0 7px 0}.tipue_search_related_cols{-webkit-columns:230px 2;-moz-columns:230px 2;columns:230px 2}
#tipue_search_foot{margin:51px 0 21px 0}#tipue_search_foot_boxes{padding:0;margin:0;cursor:pointer}#tipue_search_foot_boxes li{list-style:none;margin:0;padding:0;display:inline}#tipue_search_foot_boxes li a{padding:10px 17px 11px 17px;background-color:#fff;border:1px solid #e3e3e3;border-radius:1px;color:#333;margin-right:7px;text-decoration:none;text-align:center}#tipue_search_foot_boxes li.current{padding:10px 17px 11px 17px;background:#f6f6f6;border:1px solid #e3e3e3;border-radius:1px;color:#333;margin-right:7px;text-align:center}#tipue_search_foot_boxes li a:hover{background:#f6f6f6}</style> <link href="/atom.xml" type="application/atom+xml" rel="alternate" title="ATOM Feed"/> <link rel="shortcut icon" type="image/png" href="img/favicon.png"> </head> <body> <div id="wrap"> <nav id="nav"> <div id="nav-list"> <a href="/">Home</a> <a href="/about" title="About">About</a> <a href="/atom.xml">Atom feed</a> <a href="https://github.com/tpb1908/Notes">GitHub</a> </div> <footer> <span>version 1.0.0</span> </footer> </nav> <a id="nav-menu"> <div id="menu"></div> </a> <header id="header" class="parent justify-spaceBetween"> <div class="inner w100 relative"> <span class="f-left"> <a href="/"> <h1> <span>Theo's</span> notes </h1> </a> </span> <span id="nav-links" class="absolute right bottom"> <a href="/about" title="About">About</a> <a href="/atom.xml">Atom feed</a> <a href="https://github.com/tpb1908/Notes">GitHub</a> </span> </div> </header> <div id="container"> <main> <div> <div> <span><a href="#functional" class="post-tag">Functional</a></span> <span><a href="#haskell" class="post-tag">Haskell</a></span> <span><a href="#map" class="post-tag">Map</a></span> <span><a href="#notes" class="post-tag">Notes</a></span> <span><a href="#statistics" class="post-tag">Statistics</a></span> </div> <ul style="list-style: none;"> <li> <h1 id="functional">Functional</h1><br> <ul style="margin-left: 5%;"> <li class="post"> <h2><a href="/Test-Post">Test Post</a></h2> <time datetime="2017-08-12T00:00:00+01:00" class="by-line"> <i>12 Aug 2017</i> </time> <p> <a href="tags/#notes"> Notes </a> <a href="tags/#haskell"> Haskell </a> <a href="tags/#functional"> Functional </a> </p> <p><p>Not much here. A few lines of text.</p> <h3 id="heading-level-3">Heading level 3</h3> <p><strong>Bold</strong></p> <div class="language-kotlin highlighter-rouge"><pre class="highlight"><code><span class="k">fun</span> <span class="nf">test</span><span class="p">():</span> <span class="n">Int</span> <span class="p">{</span>
  <span class="k">return</span> <span class="m">0</span>
<span class="p">}</span>
</code></pre> </div> </p> </li> <li class="post"> <h2><a href="/Haskell-Notes">Haskell Notes</a></h2> <time datetime="2017-08-06T00:00:00+01:00" class="by-line"> <i>06 Aug 2017</i> </time> <p> <a href="tags/#notes"> Notes </a> <a href="tags/#haskell"> Haskell </a> <a href="tags/#functional"> Functional </a> </p> <p><p>This is a collection of notes on Haskell, primarily condensed from <a href="http://learnyouahaskell.com">learnyouahaskell</a></p> </p> </li> </ul> </li> <li> <h1 id="haskell">Haskell</h1><br> <ul style="margin-left: 5%;"> <li class="post"> <h2><a href="/Test-Post">Test Post</a></h2> <time datetime="2017-08-12T00:00:00+01:00" class="by-line"> <i>12 Aug 2017</i> </time> <p> <a href="tags/#notes"> Notes </a> <a href="tags/#haskell"> Haskell </a> <a href="tags/#functional"> Functional </a> </p> <p><p>Not much here. A few lines of text.</p> <h3 id="heading-level-3">Heading level 3</h3> <p><strong>Bold</strong></p> <div class="language-kotlin highlighter-rouge"><pre class="highlight"><code><span class="k">fun</span> <span class="nf">test</span><span class="p">():</span> <span class="n">Int</span> <span class="p">{</span>
  <span class="k">return</span> <span class="m">0</span>
<span class="p">}</span>
</code></pre> </div> </p> </li> <li class="post"> <h2><a href="/Haskell-Notes">Haskell Notes</a></h2> <time datetime="2017-08-06T00:00:00+01:00" class="by-line"> <i>06 Aug 2017</i> </time> <p> <a href="tags/#notes"> Notes </a> <a href="tags/#haskell"> Haskell </a> <a href="tags/#functional"> Functional </a> </p> <p><p>This is a collection of notes on Haskell, primarily condensed from <a href="http://learnyouahaskell.com">learnyouahaskell</a></p> </p> </li> </ul> </li> <li> <h1 id="map">Map</h1><br> <ul style="margin-left: 5%;"> <li class="post"> <h2><a href="/Edinburgh-Food-Shopping">Edinburgh Food Shopping</a></h2> <time datetime="2017-08-17T00:00:00+01:00" class="by-line"> <i>17 Aug 2017</i> </time> <p> <a href="tags/#map"> Map </a> </p> <p><p>A Google Map listing the locations of ~150 shops in Edinburgh for buying food.</p> </p> </li> </ul> </li> <li> <h1 id="notes">Notes</h1><br> <ul style="margin-left: 5%;"> <li class="post"> <h2><a href="/Test-Post">Test Post</a></h2> <time datetime="2017-08-12T00:00:00+01:00" class="by-line"> <i>12 Aug 2017</i> </time> <p> <a href="tags/#notes"> Notes </a> <a href="tags/#haskell"> Haskell </a> <a href="tags/#functional"> Functional </a> </p> <p><p>Not much here. A few lines of text.</p> <h3 id="heading-level-3">Heading level 3</h3> <p><strong>Bold</strong></p> <div class="language-kotlin highlighter-rouge"><pre class="highlight"><code><span class="k">fun</span> <span class="nf">test</span><span class="p">():</span> <span class="n">Int</span> <span class="p">{</span>
  <span class="k">return</span> <span class="m">0</span>
<span class="p">}</span>
</code></pre> </div> </p> </li> <li class="post"> <h2><a href="/Haskell-Notes">Haskell Notes</a></h2> <time datetime="2017-08-06T00:00:00+01:00" class="by-line"> <i>06 Aug 2017</i> </time> <p> <a href="tags/#notes"> Notes </a> <a href="tags/#haskell"> Haskell </a> <a href="tags/#functional"> Functional </a> </p> <p><p>This is a collection of notes on Haskell, primarily condensed from <a href="http://learnyouahaskell.com">learnyouahaskell</a></p> </p> </li> <li class="post"> <h2><a href="/Statistics-Notes">Statistics Notes</a></h2> <time datetime="2017-05-10T00:00:00+01:00" class="by-line"> <i>10 May 2017</i> </time> <p> <a href="tags/#notes"> Notes </a> <a href="tags/#statistics"> Statistics </a> </p> <p><p>Short notes on the AQA statistics A level.</p> <p>Split into topics for each module and topic.</p> </p> </li> </ul> </li> <li> <h1 id="statistics">Statistics</h1><br> <ul style="margin-left: 5%;"> <li class="post"> <h2><a href="/Statistics-Notes">Statistics Notes</a></h2> <time datetime="2017-05-10T00:00:00+01:00" class="by-line"> <i>10 May 2017</i> </time> <p> <a href="tags/#notes"> Notes </a> <a href="tags/#statistics"> Statistics </a> </p> <p><p>Short notes on the AQA statistics A level.</p> <p>Split into topics for each module and topic.</p> </p> </li> </ul> </li> </ul> </div> </main> </div> <footer> <div class="search"> <form action="/tags" id="search_form"> <div class="tipue_search_left"><img src="/js/tipuesearch/search.png" class="tipue_search_icon"></div> <div class="tipue_search_right "><input class="mdl-textfield__input"type="text" name="q" id="tipue_search_input" pattern=".{3,}" title="At least 3 characters" required></div> <div style="clear: both;"></div> </form> <div id="tipue_search_content"></div> </div> </footer> <script>function toggle(){var e=document.getElementById("nav"),t=document.getElementById("nav-left"),a=null!==e?e:t,n=document.getElementById("menu"),i=document.getElementById("wrap");"menu-open"==a.className||"menu-open-left"==a.className?(a.className="",n.className="",i.className=""):null!==reverse?(a.className+="menu-open-left",n.className+="btn-close",i.className+="fixed"):(a.className+="menu-open",n.className+="btn-close",i.className+="fixed")}function menuClick(){if(document.addEventListener&&null!==icon)icon.addEventListener("click",toggle);else{if(!document.attachEvent||null===icon)return;icon.attachEvent("onclick",toggle)}}function defer(e){window.jQuery?e():setTimeout(function(){defer(e)},5)}var normal=document.getElementById("nav-menu"),reverse=document.getElementById("nav-menu-left"),icon=null!==normal?normal:reverse;menuClick(),function(e,t){"use strict";"object"==typeof module&&"object"==typeof module.exports?module.exports=e.document?t(e,!0):function(e){if(!e.document)throw new Error("jQuery requires a window with a document");return t(e)}:t(e)}("undefined"!=typeof window?window:this,function(e,t){"use strict";function a(e,t){t=t||ae;var a=t.createElement("script");a.text=e,t.head.appendChild(a).parentNode.removeChild(a)}function n(e){var t=!!e&&"length"in e&&e.length,a=ge.type(e);return"function"!==a&&!ge.isWindow(e)&&("array"===a||0===t||"number"==typeof t&&t>0&&t-1 in e)}function i(e,t){return e.nodeName&&e.nodeName.toLowerCase()===t.toLowerCase()}function o(e,t,a){return ge.isFunction(t)?ge.grep(e,function(e,n){return!!t.call(e,n,e)!==a}):t.nodeType?ge.grep(e,function(e){return e===t!==a}):"string"!=typeof t?ge.grep(e,function(e){return se.call(t,e)>-1!==a}):Ie.test(t)?ge.filter(t,e,a):(t=ge.filter(t,e),ge.grep(e,function(e){return se.call(t,e)>-1!==a&&1===e.nodeType}))}function r(e,t){for(;(e=e[t])&&1!==e.nodeType;);return e}function s(e){var t={};return ge.each(e.match(Ee)||[],function(e,a){t[a]=!0}),t}function l(e){return e}function c(e){throw e}function u(e,t,a,n){var i;try{e&&ge.isFunction(i=e.promise)?i.call(e).done(t).fail(a):e&&ge.isFunction(i=e.then)?i.call(e,t,a):t.apply(void 0,[e].slice(n))}catch(e){a.apply(void 0,[e])}}function h(){ae.removeEventListener("DOMContentLoaded",h),e.removeEventListener("load",h),ge.ready()}function d(){this.expando=ge.expando+d.uid++}function p(e){return"true"===e||"false"!==e&&("null"===e?null:e===+e+""?+e:Pe.test(e)?JSON.parse(e):e)}function f(e,t,a){var n;if(void 0===a&&1===e.nodeType)if(n="data-"+t.replace(Be,"-$&").toLowerCase(),"string"==typeof(a=e.getAttribute(n))){try{a=p(a)}catch(e){}qe.set(e,t,a)}else a=void 0;return a}function g(e,t,a,n){var i,o=1,r=20,s=n?function(){return n.cur()}:function(){return ge.css(e,t,"")},l=s(),c=a&&a[3]||(ge.cssNumber[t]?"":"px"),u=(ge.cssNumber[t]||"px"!==c&&+l)&&je.exec(ge.css(e,t));if(u&&u[3]!==c){c=c||u[3],a=a||[],u=+l||1;do{o=o||".5",u/=o,ge.style(e,t,u+c)}while(o!==(o=s()/l)&&1!==o&&--r)}return a&&(u=+u||+l||0,i=a[1]?u+(a[1]+1)*a[2]:+a[2],n&&(n.unit=c,n.start=u,n.end=i)),i}function m(e){var t,a=e.ownerDocument,n=e.nodeName,i=$e[n];return i||(t=a.body.appendChild(a.createElement(n)),i=ge.css(t,"display"),t.parentNode.removeChild(t),"none"===i&&(i="block"),$e[n]=i,i)}function y(e,t){for(var a,n,i=[],o=0,r=e.length;o<r;o++)n=e[o],n.style&&(a=n.style.display,t?("none"===a&&(i[o]=We.get(n,"display")||null,i[o]||(n.style.display="")),""===n.style.display&&He(n)&&(i[o]=m(n))):"none"!==a&&(i[o]="none",We.set(n,"display",a)));for(o=0;o<r;o++)null!=i[o]&&(e[o].style.display=i[o]);return e}function w(e,t){var a;return a="undefined"!=typeof e.getElementsByTagName?e.getElementsByTagName(t||"*"):"undefined"!=typeof e.querySelectorAll?e.querySelectorAll(t||"*"):[],void 0===t||t&&i(e,t)?ge.merge([e],a):a}function v(e,t){for(var a=0,n=e.length;a<n;a++)We.set(e[a],"globalEval",!t||We.get(t[a],"globalEval"))}function b(e,t,a,n,i){for(var o,r,s,l,c,u,h=t.createDocumentFragment(),d=[],p=0,f=e.length;p<f;p++)if((o=e[p])||0===o)if("object"===ge.type(o))ge.merge(d,o.nodeType?[o]:o);else if(Ye.test(o)){for(r=r||h.appendChild(t.createElement("div")),s=(Ve.exec(o)||["",""])[1].toLowerCase(),l=Ue[s]||Ue._default,r.innerHTML=l[1]+ge.htmlPrefilter(o)+l[2],u=l[0];u--;)r=r.lastChild;ge.merge(d,r.childNodes),r=h.firstChild,r.textContent=""}else d.push(t.createTextNode(o));for(h.textContent="",p=0;o=d[p++];)if(n&&ge.inArray(o,n)>-1)i&&i.push(o);else if(c=ge.contains(o.ownerDocument,o),r=w(h.appendChild(o),"script"),c&&v(r),a)for(u=0;o=r[u++];)Ge.test(o.type||"")&&a.push(o);return h}function x(){return!0}function T(){return!1}function k(){try{return ae.activeElement}catch(e){}}function S(e,t,a,n,i,o){var r,s;if("object"==typeof t){"string"!=typeof a&&(n=n||a,a=void 0);for(s in t)S(e,s,a,n,t[s],o);return e}if(null==n&&null==i?(i=a,n=a=void 0):null==i&&("string"==typeof a?(i=n,n=void 0):(i=n,n=a,a=void 0)),!1===i)i=T;else if(!i)return e;return 1===o&&(r=i,i=function(e){return ge().off(e),r.apply(this,arguments)},i.guid=r.guid||(r.guid=ge.guid++)),e.each(function(){ge.event.add(this,t,i,n,a)})}function I(e,t){return i(e,"table")&&i(11!==t.nodeType?t:t.firstChild,"tr")?ge(">tbody",e)[0]||e:e}function C(e){return e.type=(null!==e.getAttribute("type"))+"/"+e.type,e}function F(e){var t=nt.exec(e.type);return t?e.type=t[1]:e.removeAttribute("type"),e}function A(e,t){var a,n,i,o,r,s,l,c;if(1===t.nodeType){if(We.hasData(e)&&(o=We.access(e),r=We.set(t,o),c=o.events)){delete r.handle,r.events={};for(i in c)for(a=0,n=c[i].length;a<n;a++)ge.event.add(t,i,c[i][a])}qe.hasData(e)&&(s=qe.access(e),l=ge.extend({},s),qe.set(t,l))}}function N(e,t){var a=t.nodeName.toLowerCase();"input"===a&&Je.test(e.type)?t.checked=e.checked:"input"!==a&&"textarea"!==a||(t.defaultValue=e.defaultValue)}function E(e,t,n,i){t=oe.apply([],t);var o,r,s,l,c,u,h=0,d=e.length,p=d-1,f=t[0],g=ge.isFunction(f);if(g||d>1&&"string"==typeof f&&!pe.checkClone&&at.test(f))return e.each(function(a){var o=e.eq(a);g&&(t[0]=f.call(this,a,o.html())),E(o,t,n,i)});if(d&&(o=b(t,e[0].ownerDocument,!1,e,i),r=o.firstChild,1===o.childNodes.length&&(o=r),r||i)){for(s=ge.map(w(o,"script"),C),l=s.length;h<d;h++)c=o,h!==p&&(c=ge.clone(c,!0,!0),l&&ge.merge(s,w(c,"script"))),n.call(e[h],c,h);if(l)for(u=s[s.length-1].ownerDocument,ge.map(s,F),h=0;h<l;h++)c=s[h],Ge.test(c.type||"")&&!We.access(c,"globalEval")&&ge.contains(u,c)&&(c.src?ge._evalUrl&&ge._evalUrl(c.src):a(c.textContent.replace(it,""),u))}return e}function _(e,t,a){for(var n,i=t?ge.filter(t,e):e,o=0;null!=(n=i[o]);o++)a||1!==n.nodeType||ge.cleanData(w(n)),n.parentNode&&(a&&ge.contains(n.ownerDocument,n)&&v(w(n,"script")),n.parentNode.removeChild(n));return e}function O(e,t,a){var n,i,o,r,s=e.style;return a=a||st(e),a&&(r=a.getPropertyValue(t)||a[t],""!==r||ge.contains(e.ownerDocument,e)||(r=ge.style(e,t)),!pe.pixelMarginRight()&&rt.test(r)&&ot.test(t)&&(n=s.width,i=s.minWidth,o=s.maxWidth,s.minWidth=s.maxWidth=s.width=r,r=a.width,s.width=n,s.minWidth=i,s.maxWidth=o)),void 0!==r?r+"":r}function L(e,t){return{get:function(){return e()?void delete this.get:(this.get=t).apply(this,arguments)}}}function M(e){if(e in pt)return e;for(var t=e[0].toUpperCase()+e.slice(1),a=dt.length;a--;)if((e=dt[a]+t)in pt)return e}function W(e){var t=ge.cssProps[e];return t||(t=ge.cssProps[e]=M(e)||e),t}function q(e,t,a){var n=je.exec(t);return n?Math.max(0,n[2]-(a||0))+(n[3]||"px"):t}function P(e,t,a,n,i){var o,r=0;for(o=a===(n?"border":"content")?4:"width"===t?1:0;o<4;o+=2)"margin"===a&&(r+=ge.css(e,a+Re[o],!0,i)),n?("content"===a&&(r-=ge.css(e,"padding"+Re[o],!0,i)),"margin"!==a&&(r-=ge.css(e,"border"+Re[o]+"Width",!0,i))):(r+=ge.css(e,"padding"+Re[o],!0,i),"padding"!==a&&(r+=ge.css(e,"border"+Re[o]+"Width",!0,i)));return r}function B(e,t,a){var n,i=st(e),o=O(e,t,i),r="border-box"===ge.css(e,"boxSizing",!1,i);return rt.test(o)?o:(n=r&&(pe.boxSizingReliable()||o===e.style[t]),"auto"===o&&(o=e["offset"+t[0].toUpperCase()+t.slice(1)]),(o=parseFloat(o)||0)+P(e,t,a||(r?"border":"content"),n,i)+"px")}function D(e,t,a,n,i){return new D.prototype.init(e,t,a,n,i)}function j(){gt&&(!1===ae.hidden&&e.requestAnimationFrame?e.requestAnimationFrame(j):e.setTimeout(j,ge.fx.interval),ge.fx.tick())}function R(){return e.setTimeout(function(){ft=void 0}),ft=ge.now()}function H(e,t){var a,n=0,i={height:e};for(t=t?1:0;n<4;n+=2-t)a=Re[n],i["margin"+a]=i["padding"+a]=e;return t&&(i.opacity=i.width=e),i}function z(e,t,a){for(var n,i=(V.tweeners[t]||[]).concat(V.tweeners["*"]),o=0,r=i.length;o<r;o++)if(n=i[o].call(a,t,e))return n}function $(e,t,a){var n,i,o,r,s,l,c,u,h="width"in t||"height"in t,d=this,p={},f=e.style,g=e.nodeType&&He(e),m=We.get(e,"fxshow");a.queue||(r=ge._queueHooks(e,"fx"),null==r.unqueued&&(r.unqueued=0,s=r.empty.fire,r.empty.fire=function(){r.unqueued||s()}),r.unqueued++,d.always(function(){d.always(function(){r.unqueued--,ge.queue(e,"fx").length||r.empty.fire()})}));for(n in t)if(i=t[n],mt.test(i)){if(delete t[n],o=o||"toggle"===i,i===(g?"hide":"show")){if("show"!==i||!m||void 0===m[n])continue;g=!0}p[n]=m&&m[n]||ge.style(e,n)}if((l=!ge.isEmptyObject(t))||!ge.isEmptyObject(p)){h&&1===e.nodeType&&(a.overflow=[f.overflow,f.overflowX,f.overflowY],c=m&&m.display,null==c&&(c=We.get(e,"display")),u=ge.css(e,"display"),"none"===u&&(c?u=c:(y([e],!0),c=e.style.display||c,u=ge.css(e,"display"),y([e]))),("inline"===u||"inline-block"===u&&null!=c)&&"none"===ge.css(e,"float")&&(l||(d.done(function(){f.display=c}),null==c&&(u=f.display,c="none"===u?"":u)),f.display="inline-block")),a.overflow&&(f.overflow="hidden",d.always(function(){f.overflow=a.overflow[0],f.overflowX=a.overflow[1],f.overflowY=a.overflow[2]})),l=!1;for(n in p)l||(m?"hidden"in m&&(g=m.hidden):m=We.access(e,"fxshow",{display:c}),o&&(m.hidden=!g),g&&y([e],!0),d.done(function(){g||y([e]),We.remove(e,"fxshow");for(n in p)ge.style(e,n,p[n])})),l=z(g?m[n]:0,n,d),n in m||(m[n]=l.start,g&&(l.end=l.start,l.start=0))}}function J(e,t){var a,n,i,o,r;for(a in e)if(n=ge.camelCase(a),i=t[n],o=e[a],Array.isArray(o)&&(i=o[1],o=e[a]=o[0]),a!==n&&(e[n]=o,delete e[a]),(r=ge.cssHooks[n])&&"expand"in r){o=r.expand(o),delete e[n];for(a in o)a in e||(e[a]=o[a],t[a]=i)}else t[n]=i}function V(e,t,a){var n,i,o=0,r=V.prefilters.length,s=ge.Deferred().always(function(){delete l.elem}),l=function(){if(i)return!1;for(var t=ft||R(),a=Math.max(0,c.startTime+c.duration-t),n=a/c.duration||0,o=1-n,r=0,l=c.tweens.length;r<l;r++)c.tweens[r].run(o);return s.notifyWith(e,[c,o,a]),o<1&&l?a:(l||s.notifyWith(e,[c,1,0]),s.resolveWith(e,[c]),!1)},c=s.promise({elem:e,props:ge.extend({},t),opts:ge.extend(!0,{specialEasing:{},easing:ge.easing._default},a),originalProperties:t,originalOptions:a,startTime:ft||R(),duration:a.duration,tweens:[],createTween:function(t,a){var n=ge.Tween(e,c.opts,t,a,c.opts.specialEasing[t]||c.opts.easing);return c.tweens.push(n),n},stop:function(t){var a=0,n=t?c.tweens.length:0;if(i)return this;for(i=!0;a<n;a++)c.tweens[a].run(1);return t?(s.notifyWith(e,[c,1,0]),s.resolveWith(e,[c,t])):s.rejectWith(e,[c,t]),this}}),u=c.props;for(J(u,c.opts.specialEasing);o<r;o++)if(n=V.prefilters[o].call(c,e,u,c.opts))return ge.isFunction(n.stop)&&(ge._queueHooks(c.elem,c.opts.queue).stop=ge.proxy(n.stop,n)),n;return ge.map(u,z,c),ge.isFunction(c.opts.start)&&c.opts.start.call(e,c),c.progress(c.opts.progress).done(c.opts.done,c.opts.complete).fail(c.opts.fail).always(c.opts.always),ge.fx.timer(ge.extend(l,{elem:e,anim:c,queue:c.opts.queue})),c}function G(e){return(e.match(Ee)||[]).join(" ")}function U(e){return e.getAttribute&&e.getAttribute("class")||""}function Y(e,t,a,n){var i;if(Array.isArray(t))ge.each(t,function(t,i){a||Ft.test(e)?n(e,i):Y(e+"["+("object"==typeof i&&null!=i?t:"")+"]",i,a,n)});else if(a||"object"!==ge.type(t))n(e,t);else for(i in t)Y(e+"["+i+"]",t[i],a,n)}function Q(e){return function(t,a){"string"!=typeof t&&(a=t,t="*");var n,i=0,o=t.toLowerCase().match(Ee)||[];if(ge.isFunction(a))for(;n=o[i++];)"+"===n[0]?(n=n.slice(1)||"*",(e[n]=e[n]||[]).unshift(a)):(e[n]=e[n]||[]).push(a)}}function X(e,t,a,n){function i(s){var l;return o[s]=!0,ge.each(e[s]||[],function(e,s){var c=s(t,a,n);return"string"!=typeof c||r||o[c]?r?!(l=c):void 0:(t.dataTypes.unshift(c),i(c),!1)}),l}var o={},r=e===Dt;return i(t.dataTypes[0])||!o["*"]&&i("*")}function K(e,t){var a,n,i=ge.ajaxSettings.flatOptions||{};for(a in t)void 0!==t[a]&&((i[a]?e:n||(n={}))[a]=t[a]);return n&&ge.extend(!0,e,n),e}function Z(e,t,a){for(var n,i,o,r,s=e.contents,l=e.dataTypes;"*"===l[0];)l.shift(),void 0===n&&(n=e.mimeType||t.getResponseHeader("Content-Type"));if(n)for(i in s)if(s[i]&&s[i].test(n)){l.unshift(i);break}if(l[0]in a)o=l[0];else{for(i in a){if(!l[0]||e.converters[i+" "+l[0]]){o=i;break}r||(r=i)}o=o||r}if(o)return o!==l[0]&&l.unshift(o),a[o]}function ee(e,t,a,n){var i,o,r,s,l,c={},u=e.dataTypes.slice();if(u[1])for(r in e.converters)c[r.toLowerCase()]=e.converters[r];for(o=u.shift();o;)if(e.responseFields[o]&&(a[e.responseFields[o]]=t),!l&&n&&e.dataFilter&&(t=e.dataFilter(t,e.dataType)),l=o,o=u.shift())if("*"===o)o=l;else if("*"!==l&&l!==o){if(!(r=c[l+" "+o]||c["* "+o]))for(i in c)if(s=i.split(" "),s[1]===o&&(r=c[l+" "+s[0]]||c["* "+s[0]])){!0===r?r=c[i]:!0!==c[i]&&(o=s[0],u.unshift(s[1]));break}if(!0!==r)if(r&&e["throws"])t=r(t);else try{t=r(t)}catch(e){return{state:"parsererror",error:r?e:"No conversion from "+l+" to "+o}}}return{state:"success",data:t}}var te=[],ae=e.document,ne=Object.getPrototypeOf,ie=te.slice,oe=te.concat,re=te.push,se=te.indexOf,le={},ce=le.toString,ue=le.hasOwnProperty,he=ue.toString,de=he.call(Object),pe={},fe="3.2.1",ge=function(e,t){return new ge.fn.init(e,t)},me=/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g,ye=/^-ms-/,we=/-([a-z])/g,ve=function(e,t){return t.toUpperCase()};ge.fn=ge.prototype={jquery:fe,constructor:ge,length:0,toArray:function(){return ie.call(this)},get:function(e){return null==e?ie.call(this):e<0?this[e+this.length]:this[e]},pushStack:function(e){var t=ge.merge(this.constructor(),e);return t.prevObject=this,t},each:function(e){return ge.each(this,e)},map:function(e){return this.pushStack(ge.map(this,function(t,a){return e.call(t,a,t)}))},slice:function(){return this.pushStack(ie.apply(this,arguments))},first:function(){return this.eq(0)},last:function(){return this.eq(-1)},eq:function(e){var t=this.length,a=+e+(e<0?t:0);return this.pushStack(a>=0&&a<t?[this[a]]:[])},end:function(){return this.prevObject||this.constructor()},push:re,sort:te.sort,splice:te.splice},ge.extend=ge.fn.extend=function(){var e,t,a,n,i,o,r=arguments[0]||{},s=1,l=arguments.length,c=!1;for("boolean"==typeof r&&(c=r,r=arguments[s]||{},s++),"object"==typeof r||ge.isFunction(r)||(r={}),s===l&&(r=this,s--);s<l;s++)if(null!=(e=arguments[s]))for(t in e)a=r[t],n=e[t],r!==n&&(c&&n&&(ge.isPlainObject(n)||(i=Array.isArray(n)))?(i?(i=!1,o=a&&Array.isArray(a)?a:[]):o=a&&ge.isPlainObject(a)?a:{},r[t]=ge.extend(c,o,n)):void 0!==n&&(r[t]=n));return r},ge.extend({expando:"jQuery"+(fe+Math.random()).replace(/\D/g,""),isReady:!0,error:function(e){throw new Error(e)},noop:function(){},isFunction:function(e){return"function"===ge.type(e)},isWindow:function(e){return null!=e&&e===e.window},isNumeric:function(e){var t=ge.type(e);return("number"===t||"string"===t)&&!isNaN(e-parseFloat(e))},isPlainObject:function(e){var t,a;return!(!e||"[object Object]"!==ce.call(e)||(t=ne(e))&&("function"!=typeof(a=ue.call(t,"constructor")&&t.constructor)||he.call(a)!==de))},isEmptyObject:function(e){var t;for(t in e)return!1;return!0},type:function(e){return null==e?e+"":"object"==typeof e||"function"==typeof e?le[ce.call(e)]||"object":typeof e},globalEval:function(e){a(e)},camelCase:function(e){return e.replace(ye,"ms-").replace(we,ve)},each:function(e,t){var a,i=0;if(n(e))for(a=e.length;i<a&&!1!==t.call(e[i],i,e[i]);i++);else for(i in e)if(!1===t.call(e[i],i,e[i]))break;return e},trim:function(e){return null==e?"":(e+"").replace(me,"")},makeArray:function(e,t){var a=t||[];return null!=e&&(n(Object(e))?ge.merge(a,"string"==typeof e?[e]:e):re.call(a,e)),a},inArray:function(e,t,a){return null==t?-1:se.call(t,e,a)},merge:function(e,t){for(var a=+t.length,n=0,i=e.length;n<a;n++)e[i++]=t[n];return e.length=i,e},grep:function(e,t,a){for(var n=[],i=0,o=e.length,r=!a;i<o;i++)!t(e[i],i)!==r&&n.push(e[i]);return n},map:function(e,t,a){var i,o,r=0,s=[];if(n(e))for(i=e.length;r<i;r++)null!=(o=t(e[r],r,a))&&s.push(o);else for(r in e)null!=(o=t(e[r],r,a))&&s.push(o);return oe.apply([],s)},guid:1,proxy:function(e,t){var a,n,i;if("string"==typeof t&&(a=e[t],t=e,e=a),ge.isFunction(e))return n=ie.call(arguments,2),i=function(){return e.apply(t||this,n.concat(ie.call(arguments)))},i.guid=e.guid=e.guid||ge.guid++,i},now:Date.now,support:pe}),"function"==typeof Symbol&&(ge.fn[Symbol.iterator]=te[Symbol.iterator]),ge.each("Boolean Number String Function Array Date RegExp Object Error Symbol".split(" "),function(e,t){le["[object "+t+"]"]=t.toLowerCase()});var be=function(e){function t(e,t,a,n){var i,o,r,s,l,c,u,d=t&&t.ownerDocument,f=t?t.nodeType:9;if(a=a||[],"string"!=typeof e||!e||1!==f&&9!==f&&11!==f)return a;if(!n&&((t?t.ownerDocument||t:R)!==L&&O(t),t=t||L,W)){if(11!==f&&(l=ye.exec(e)))if(i=l[1]){if(9===f){if(!(r=t.getElementById(i)))return a;if(r.id===i)return a.push(r),a}else if(d&&(r=d.getElementById(i))&&D(t,r)&&r.id===i)return a.push(r),a}else{if(l[2])return K.apply(a,t.getElementsByTagName(e)),a;if((i=l[3])&&T.getElementsByClassName&&t.getElementsByClassName)return K.apply(a,t.getElementsByClassName(i)),a}if(T.qsa&&!V[e+" "]&&(!q||!q.test(e))){if(1!==f)d=t,u=e;else if("object"!==t.nodeName.toLowerCase()){for((s=t.getAttribute("id"))?s=s.replace(xe,Te):t.setAttribute("id",s=j),c=C(e),o=c.length;o--;)c[o]="#"+s+" "+p(c[o]);u=c.join(","),d=we.test(e)&&h(t.parentNode)||t}if(u)try{return K.apply(a,d.querySelectorAll(u)),a}catch(e){}finally{s===j&&t.removeAttribute("id")}}}return A(e.replace(se,"$1"),t,a,n)}function a(){function e(a,n){return t.push(a+" ")>k.cacheLength&&delete e[t.shift()],e[a+" "]=n}var t=[];return e}function n(e){return e[j]=!0,e}function i(e){var t=L.createElement("fieldset");try{return!!e(t)}catch(e){return!1}finally{t.parentNode&&t.parentNode.removeChild(t),t=null}}function o(e,t){for(var a=e.split("|"),n=a.length;n--;)k.attrHandle[a[n]]=t}function r(e,t){var a=t&&e,n=a&&1===e.nodeType&&1===t.nodeType&&e.sourceIndex-t.sourceIndex;if(n)return n;if(a)for(;a=a.nextSibling;)if(a===t)return-1;return e?1:-1}function s(e){return function(t){return"input"===t.nodeName.toLowerCase()&&t.type===e}}function l(e){return function(t){var a=t.nodeName.toLowerCase();return("input"===a||"button"===a)&&t.type===e}}function c(e){return function(t){return"form"in t?t.parentNode&&!1===t.disabled?"label"in t?"label"in t.parentNode?t.parentNode.disabled===e:t.disabled===e:t.isDisabled===e||t.isDisabled!==!e&&Se(t)===e:t.disabled===e:"label"in t&&t.disabled===e}}function u(e){return n(function(t){return t=+t,n(function(a,n){for(var i,o=e([],a.length,t),r=o.length;r--;)a[i=o[r]]&&(a[i]=!(n[i]=a[i]))})})}function h(e){return e&&"undefined"!=typeof e.getElementsByTagName&&e}function d(){}function p(e){for(var t=0,a=e.length,n="";t<a;t++)n+=e[t].value;return n}function f(e,t,a){var n=t.dir,i=t.next,o=i||n,r=a&&"parentNode"===o,s=z++;return t.first?function(t,a,i){for(;t=t[n];)if(1===t.nodeType||r)return e(t,a,i);return!1}:function(t,a,l){var c,u,h,d=[H,s];if(l){for(;t=t[n];)if((1===t.nodeType||r)&&e(t,a,l))return!0}else for(;t=t[n];)if(1===t.nodeType||r)if(h=t[j]||(t[j]={}),u=h[t.uniqueID]||(h[t.uniqueID]={}),i&&i===t.nodeName.toLowerCase())t=t[n]||t;else{if((c=u[o])&&c[0]===H&&c[1]===s)return d[2]=c[2];if(u[o]=d,d[2]=e(t,a,l))return!0}return!1}}function g(e){return e.length>1?function(t,a,n){for(var i=e.length;i--;)if(!e[i](t,a,n))return!1;return!0}:e[0]}function m(e,a,n){for(var i=0,o=a.length;i<o;i++)t(e,a[i],n);return n}function y(e,t,a,n,i){for(var o,r=[],s=0,l=e.length,c=null!=t;s<l;s++)(o=e[s])&&(a&&!a(o,n,i)||(r.push(o),c&&t.push(s)));return r}function w(e,t,a,i,o,r){return i&&!i[j]&&(i=w(i)),o&&!o[j]&&(o=w(o,r)),n(function(n,r,s,l){var c,u,h,d=[],p=[],f=r.length,g=n||m(t||"*",s.nodeType?[s]:s,[]),w=!e||!n&&t?g:y(g,d,e,s,l),v=a?o||(n?e:f||i)?[]:r:w;if(a&&a(w,v,s,l),i)for(c=y(v,p),i(c,[],s,l),u=c.length;u--;)(h=c[u])&&(v[p[u]]=!(w[p[u]]=h));if(n){if(o||e){if(o){for(c=[],u=v.length;u--;)(h=v[u])&&c.push(w[u]=h);o(null,v=[],c,l)}for(u=v.length;u--;)(h=v[u])&&(c=o?ee(n,h):d[u])>-1&&(n[c]=!(r[c]=h))}}else v=y(v===r?v.splice(f,v.length):v),o?o(null,r,v,l):K.apply(r,v)})}function v(e){for(var t,a,n,i=e.length,o=k.relative[e[0].type],r=o||k.relative[" "],s=o?1:0,l=f(function(e){return e===t},r,!0),c=f(function(e){return ee(t,e)>-1},r,!0),u=[function(e,a,n){var i=!o&&(n||a!==N)||((t=a).nodeType?l(e,a,n):c(e,a,n));return t=null,i}];s<i;s++)if(a=k.relative[e[s].type])u=[f(g(u),a)];else{if(a=k.filter[e[s].type].apply(null,e[s].matches),a[j]){for(n=++s;n<i&&!k.relative[e[n].type];n++);return w(s>1&&g(u),s>1&&p(e.slice(0,s-1).concat({value:" "===e[s-2].type?"*":""})).replace(se,"$1"),a,s<n&&v(e.slice(s,n)),n<i&&v(e=e.slice(n)),n<i&&p(e))}u.push(a)}return g(u)}function b(e,a){var i=a.length>0,o=e.length>0,r=function(n,r,s,l,c){var u,h,d,p=0,f="0",g=n&&[],m=[],w=N,v=n||o&&k.find.TAG("*",c),b=H+=null==w?1:Math.random()||.1,x=v.length;for(c&&(N=r===L||r||c);f!==x&&null!=(u=v[f]);f++){if(o&&u){for(h=0,r||u.ownerDocument===L||(O(u),s=!W);d=e[h++];)if(d(u,r||L,s)){l.push(u);break}c&&(H=b)}i&&((u=!d&&u)&&p--,n&&g.push(u))}if(p+=f,i&&f!==p){for(h=0;d=a[h++];)d(g,m,r,s);if(n){if(p>0)for(;f--;)g[f]||m[f]||(m[f]=Q.call(l));m=y(m)}K.apply(l,m),c&&!n&&m.length>0&&p+a.length>1&&t.uniqueSort(l)}return c&&(H=b,N=w),g};return i?n(r):r}var x,T,k,S,I,C,F,A,N,E,_,O,L,M,W,q,P,B,D,j="sizzle"+1*new Date,R=e.document,H=0,z=0,$=a(),J=a(),V=a(),G=function(e,t){return e===t&&(_=!0),0},U={}.hasOwnProperty,Y=[],Q=Y.pop,X=Y.push,K=Y.push,Z=Y.slice,ee=function(e,t){for(var a=0,n=e.length;a<n;a++)if(e[a]===t)return a;return-1},te="checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|ismap|loop|multiple|open|readonly|required|scoped",ae="[\\x20\\t\\r\\n\\f]",ne="(?:\\\\.|[\\w-]|[^\0-\\xa0])+",ie="\\["+ae+"*("+ne+")(?:"+ae+"*([*^$|!~]?=)"+ae+"*(?:'((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\"|("+ne+"))|)"+ae+"*\\]",oe=":("+ne+")(?:\\((('((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\")|((?:\\\\.|[^\\\\()[\\]]|"+ie+")*)|.*)\\)|)",re=new RegExp(ae+"+","g"),se=new RegExp("^"+ae+"+|((?:^|[^\\\\])(?:\\\\.)*)"+ae+"+$","g"),le=new RegExp("^"+ae+"*,"+ae+"*"),ce=new RegExp("^"+ae+"*([>+~]|"+ae+")"+ae+"*"),ue=new RegExp("="+ae+"*([^\\]'\"]*?)"+ae+"*\\]","g"),he=new RegExp(oe),de=new RegExp("^"+ne+"$"),pe={ID:new RegExp("^#("+ne+")"),CLASS:new RegExp("^\\.("+ne+")"),TAG:new RegExp("^("+ne+"|[*])"),ATTR:new RegExp("^"+ie),PSEUDO:new RegExp("^"+oe),CHILD:new RegExp("^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\("+ae+"*(even|odd|(([+-]|)(\\d*)n|)"+ae+"*(?:([+-]|)"+ae+"*(\\d+)|))"+ae+"*\\)|)","i"),bool:new RegExp("^(?:"+te+")$","i"),needsContext:new RegExp("^"+ae+"*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\("+ae+"*((?:-\\d)?\\d*)"+ae+"*\\)|)(?=[^-]|$)","i")},fe=/^(?:input|select|textarea|button)$/i,ge=/^h\d$/i,me=/^[^{]+\{\s*\[native \w/,ye=/^(?:#([\w-]+)|(\w+)|\.([\w-]+))$/,we=/[+~]/,ve=new RegExp("\\\\([\\da-f]{1,6}"+ae+"?|("+ae+")|.)","ig"),be=function(e,t,a){var n="0x"+t-65536;return n!==n||a?t:n<0?String.fromCharCode(n+65536):String.fromCharCode(n>>10|55296,1023&n|56320)},xe=/([\0-\x1f\x7f]|^-?\d)|^-$|[^\0-\x1f\x7f-\uFFFF\w-]/g,Te=function(e,t){return t?"\0"===e?"\ufffd":e.slice(0,-1)+"\\"+e.charCodeAt(e.length-1).toString(16)+" ":"\\"+e},ke=function(){O()},Se=f(function(e){return!0===e.disabled&&("form"in e||"label"in e)},{dir:"parentNode",next:"legend"});try{K.apply(Y=Z.call(R.childNodes),R.childNodes),Y[R.childNodes.length].nodeType}catch(e){K={apply:Y.length?function(e,t){X.apply(e,Z.call(t))}:function(e,t){for(var a=e.length,n=0;e[a++]=t[n++];);e.length=a-1}}}T=t.support={},I=t.isXML=function(e){var t=e&&(e.ownerDocument||e).documentElement;return!!t&&"HTML"!==t.nodeName},O=t.setDocument=function(e){var t,a,n=e?e.ownerDocument||e:R;return n!==L&&9===n.nodeType&&n.documentElement?(L=n,M=L.documentElement,W=!I(L),R!==L&&(a=L.defaultView)&&a.top!==a&&(a.addEventListener?a.addEventListener("unload",ke,!1):a.attachEvent&&a.attachEvent("onunload",ke)),T.attributes=i(function(e){return e.className="i",!e.getAttribute("className")}),T.getElementsByTagName=i(function(e){return e.appendChild(L.createComment("")),!e.getElementsByTagName("*").length}),T.getElementsByClassName=me.test(L.getElementsByClassName),T.getById=i(function(e){return M.appendChild(e).id=j,!L.getElementsByName||!L.getElementsByName(j).length}),T.getById?(k.filter.ID=function(e){var t=e.replace(ve,be);return function(e){return e.getAttribute("id")===t}},k.find.ID=function(e,t){if("undefined"!=typeof t.getElementById&&W){var a=t.getElementById(e);return a?[a]:[]}}):(k.filter.ID=function(e){var t=e.replace(ve,be);return function(e){var a="undefined"!=typeof e.getAttributeNode&&e.getAttributeNode("id");return a&&a.value===t}},k.find.ID=function(e,t){if("undefined"!=typeof t.getElementById&&W){var a,n,i,o=t.getElementById(e);if(o){if((a=o.getAttributeNode("id"))&&a.value===e)return[o];for(i=t.getElementsByName(e),n=0;o=i[n++];)if((a=o.getAttributeNode("id"))&&a.value===e)return[o]}return[]}}),k.find.TAG=T.getElementsByTagName?function(e,t){return"undefined"!=typeof t.getElementsByTagName?t.getElementsByTagName(e):T.qsa?t.querySelectorAll(e):void 0}:function(e,t){var a,n=[],i=0,o=t.getElementsByTagName(e);if("*"===e){for(;a=o[i++];)1===a.nodeType&&n.push(a);return n}return o},k.find.CLASS=T.getElementsByClassName&&function(e,t){if("undefined"!=typeof t.getElementsByClassName&&W)return t.getElementsByClassName(e)},P=[],q=[],(T.qsa=me.test(L.querySelectorAll))&&(i(function(e){M.appendChild(e).innerHTML="<a id='"+j+"'></a><select id='"+j+"-\r\\' msallowcapture=''><option selected=''></option></select>",e.querySelectorAll("[msallowcapture^='']").length&&q.push("[*^$]="+ae+"*(?:''|\"\")"),e.querySelectorAll("[selected]").length||q.push("\\["+ae+"*(?:value|"+te+")"),e.querySelectorAll("[id~="+j+"-]").length||q.push("~="),e.querySelectorAll(":checked").length||q.push(":checked"),e.querySelectorAll("a#"+j+"+*").length||q.push(".#.+[+~]")}),i(function(e){e.innerHTML="<a href='' disabled='disabled'></a><select disabled='disabled'><option/></select>";var t=L.createElement("input");t.setAttribute("type","hidden"),e.appendChild(t).setAttribute("name","D"),e.querySelectorAll("[name=d]").length&&q.push("name"+ae+"*[*^$|!~]?="),2!==e.querySelectorAll(":enabled").length&&q.push(":enabled",":disabled"),M.appendChild(e).disabled=!0,2!==e.querySelectorAll(":disabled").length&&q.push(":enabled",":disabled"),e.querySelectorAll("*,:x"),q.push(",.*:")})),(T.matchesSelector=me.test(B=M.matches||M.webkitMatchesSelector||M.mozMatchesSelector||M.oMatchesSelector||M.msMatchesSelector))&&i(function(e){T.disconnectedMatch=B.call(e,"*"),B.call(e,"[s!='']:x"),P.push("!=",oe)}),q=q.length&&new RegExp(q.join("|")),P=P.length&&new RegExp(P.join("|")),t=me.test(M.compareDocumentPosition),D=t||me.test(M.contains)?function(e,t){var a=9===e.nodeType?e.documentElement:e,n=t&&t.parentNode;return e===n||!(!n||1!==n.nodeType||!(a.contains?a.contains(n):e.compareDocumentPosition&&16&e.compareDocumentPosition(n)))}:function(e,t){if(t)for(;t=t.parentNode;)if(t===e)return!0;return!1},G=t?function(e,t){if(e===t)return _=!0,0;var a=!e.compareDocumentPosition-!t.compareDocumentPosition;return a||(a=(e.ownerDocument||e)===(t.ownerDocument||t)?e.compareDocumentPosition(t):1,1&a||!T.sortDetached&&t.compareDocumentPosition(e)===a?e===L||e.ownerDocument===R&&D(R,e)?-1:t===L||t.ownerDocument===R&&D(R,t)?1:E?ee(E,e)-ee(E,t):0:4&a?-1:1)}:function(e,t){if(e===t)return _=!0,0;var a,n=0,i=e.parentNode,o=t.parentNode,s=[e],l=[t];if(!i||!o)return e===L?-1:t===L?1:i?-1:o?1:E?ee(E,e)-ee(E,t):0;if(i===o)return r(e,t);for(a=e;a=a.parentNode;)s.unshift(a);for(a=t;a=a.parentNode;)l.unshift(a);for(;s[n]===l[n];)n++;return n?r(s[n],l[n]):s[n]===R?-1:l[n]===R?1:0},L):L},t.matches=function(e,a){return t(e,null,null,a)},t.matchesSelector=function(e,a){if((e.ownerDocument||e)!==L&&O(e),a=a.replace(ue,"='$1']"),T.matchesSelector&&W&&!V[a+" "]&&(!P||!P.test(a))&&(!q||!q.test(a)))try{var n=B.call(e,a);if(n||T.disconnectedMatch||e.document&&11!==e.document.nodeType)return n}catch(e){}return t(a,L,null,[e]).length>0},t.contains=function(e,t){return(e.ownerDocument||e)!==L&&O(e),D(e,t)},t.attr=function(e,t){(e.ownerDocument||e)!==L&&O(e);var a=k.attrHandle[t.toLowerCase()],n=a&&U.call(k.attrHandle,t.toLowerCase())?a(e,t,!W):void 0;return void 0!==n?n:T.attributes||!W?e.getAttribute(t):(n=e.getAttributeNode(t))&&n.specified?n.value:null},t.escape=function(e){return(e+"").replace(xe,Te)},t.error=function(e){throw new Error("Syntax error, unrecognized expression: "+e)},t.uniqueSort=function(e){var t,a=[],n=0,i=0;if(_=!T.detectDuplicates,E=!T.sortStable&&e.slice(0),e.sort(G),_){for(;t=e[i++];)t===e[i]&&(n=a.push(i));for(;n--;)e.splice(a[n],1)}return E=null,e},S=t.getText=function(e){var t,a="",n=0,i=e.nodeType;if(i){if(1===i||9===i||11===i){if("string"==typeof e.textContent)return e.textContent;for(e=e.firstChild;e;e=e.nextSibling)a+=S(e)}else if(3===i||4===i)return e.nodeValue}else for(;t=e[n++];)a+=S(t);return a},k=t.selectors={cacheLength:50,createPseudo:n,match:pe,attrHandle:{},find:{},relative:{">":{dir:"parentNode",first:!0}," ":{dir:"parentNode"},"+":{dir:"previousSibling",first:!0},"~":{dir:"previousSibling"}},preFilter:{ATTR:function(e){return e[1]=e[1].replace(ve,be),e[3]=(e[3]||e[4]||e[5]||"").replace(ve,be),"~="===e[2]&&(e[3]=" "+e[3]+" "),e.slice(0,4)},CHILD:function(e){return e[1]=e[1].toLowerCase(),"nth"===e[1].slice(0,3)?(e[3]||t.error(e[0]),e[4]=+(e[4]?e[5]+(e[6]||1):2*("even"===e[3]||"odd"===e[3])),e[5]=+(e[7]+e[8]||"odd"===e[3])):e[3]&&t.error(e[0]),e},PSEUDO:function(e){var t,a=!e[6]&&e[2];return pe.CHILD.test(e[0])?null:(e[3]?e[2]=e[4]||e[5]||"":a&&he.test(a)&&(t=C(a,!0))&&(t=a.indexOf(")",a.length-t)-a.length)&&(e[0]=e[0].slice(0,t),e[2]=a.slice(0,t)),e.slice(0,3))}},filter:{TAG:function(e){var t=e.replace(ve,be).toLowerCase();return"*"===e?function(){return!0}:function(e){return e.nodeName&&e.nodeName.toLowerCase()===t}},CLASS:function(e){var t=$[e+" "];return t||(t=new RegExp("(^|"+ae+")"+e+"("+ae+"|$)"))&&$(e,function(e){return t.test("string"==typeof e.className&&e.className||"undefined"!=typeof e.getAttribute&&e.getAttribute("class")||"")})},ATTR:function(e,a,n){return function(i){var o=t.attr(i,e);return null==o?"!="===a:!a||(o+="","="===a?o===n:"!="===a?o!==n:"^="===a?n&&0===o.indexOf(n):"*="===a?n&&o.indexOf(n)>-1:"$="===a?n&&o.slice(-n.length)===n:"~="===a?(" "+o.replace(re," ")+" ").indexOf(n)>-1:"|="===a&&(o===n||o.slice(0,n.length+1)===n+"-"))}},CHILD:function(e,t,a,n,i){var o="nth"!==e.slice(0,3),r="last"!==e.slice(-4),s="of-type"===t;return 1===n&&0===i?function(e){return!!e.parentNode}:function(t,a,l){var c,u,h,d,p,f,g=o!==r?"nextSibling":"previousSibling",m=t.parentNode,y=s&&t.nodeName.toLowerCase(),w=!l&&!s,v=!1;if(m){if(o){for(;g;){for(d=t;d=d[g];)if(s?d.nodeName.toLowerCase()===y:1===d.nodeType)return!1;f=g="only"===e&&!f&&"nextSibling"}return!0}if(f=[r?m.firstChild:m.lastChild],r&&w){for(d=m,h=d[j]||(d[j]={}),u=h[d.uniqueID]||(h[d.uniqueID]={}),c=u[e]||[],p=c[0]===H&&c[1],v=p&&c[2],d=p&&m.childNodes[p];d=++p&&d&&d[g]||(v=p=0)||f.pop();)if(1===d.nodeType&&++v&&d===t){u[e]=[H,p,v];break}}else if(w&&(d=t,h=d[j]||(d[j]={}),u=h[d.uniqueID]||(h[d.uniqueID]={}),c=u[e]||[],p=c[0]===H&&c[1],v=p),!1===v)for(;(d=++p&&d&&d[g]||(v=p=0)||f.pop())&&((s?d.nodeName.toLowerCase()!==y:1!==d.nodeType)||!++v||(w&&(h=d[j]||(d[j]={}),u=h[d.uniqueID]||(h[d.uniqueID]={}),u[e]=[H,v]),d!==t)););return(v-=i)===n||v%n==0&&v/n>=0}}},PSEUDO:function(e,a){var i,o=k.pseudos[e]||k.setFilters[e.toLowerCase()]||t.error("unsupported pseudo: "+e);return o[j]?o(a):o.length>1?(i=[e,e,"",a],k.setFilters.hasOwnProperty(e.toLowerCase())?n(function(e,t){for(var n,i=o(e,a),r=i.length;r--;)n=ee(e,i[r]),e[n]=!(t[n]=i[r])}):function(e){return o(e,0,i)}):o}},pseudos:{not:n(function(e){var t=[],a=[],i=F(e.replace(se,"$1"));return i[j]?n(function(e,t,a,n){for(var o,r=i(e,null,n,[]),s=e.length;s--;)(o=r[s])&&(e[s]=!(t[s]=o))}):function(e,n,o){return t[0]=e,i(t,null,o,a),t[0]=null,!a.pop()}}),has:n(function(e){return function(a){return t(e,a).length>0}}),contains:n(function(e){return e=e.replace(ve,be),function(t){return(t.textContent||t.innerText||S(t)).indexOf(e)>-1}}),lang:n(function(e){return de.test(e||"")||t.error("unsupported lang: "+e),e=e.replace(ve,be).toLowerCase(),function(t){var a;do{
if(a=W?t.lang:t.getAttribute("xml:lang")||t.getAttribute("lang"))return(a=a.toLowerCase())===e||0===a.indexOf(e+"-")}while((t=t.parentNode)&&1===t.nodeType);return!1}}),target:function(t){var a=e.location&&e.location.hash;return a&&a.slice(1)===t.id},root:function(e){return e===M},focus:function(e){return e===L.activeElement&&(!L.hasFocus||L.hasFocus())&&!!(e.type||e.href||~e.tabIndex)},enabled:c(!1),disabled:c(!0),checked:function(e){var t=e.nodeName.toLowerCase();return"input"===t&&!!e.checked||"option"===t&&!!e.selected},selected:function(e){return e.parentNode&&e.parentNode.selectedIndex,!0===e.selected},empty:function(e){for(e=e.firstChild;e;e=e.nextSibling)if(e.nodeType<6)return!1;return!0},parent:function(e){return!k.pseudos.empty(e)},header:function(e){return ge.test(e.nodeName)},input:function(e){return fe.test(e.nodeName)},button:function(e){var t=e.nodeName.toLowerCase();return"input"===t&&"button"===e.type||"button"===t},text:function(e){var t;return"input"===e.nodeName.toLowerCase()&&"text"===e.type&&(null==(t=e.getAttribute("type"))||"text"===t.toLowerCase())},first:u(function(){return[0]}),last:u(function(e,t){return[t-1]}),eq:u(function(e,t,a){return[a<0?a+t:a]}),even:u(function(e,t){for(var a=0;a<t;a+=2)e.push(a);return e}),odd:u(function(e,t){for(var a=1;a<t;a+=2)e.push(a);return e}),lt:u(function(e,t,a){for(var n=a<0?a+t:a;--n>=0;)e.push(n);return e}),gt:u(function(e,t,a){for(var n=a<0?a+t:a;++n<t;)e.push(n);return e})}},k.pseudos.nth=k.pseudos.eq;for(x in{radio:!0,checkbox:!0,file:!0,password:!0,image:!0})k.pseudos[x]=s(x);for(x in{submit:!0,reset:!0})k.pseudos[x]=l(x);return d.prototype=k.filters=k.pseudos,k.setFilters=new d,C=t.tokenize=function(e,a){var n,i,o,r,s,l,c,u=J[e+" "];if(u)return a?0:u.slice(0);for(s=e,l=[],c=k.preFilter;s;){n&&!(i=le.exec(s))||(i&&(s=s.slice(i[0].length)||s),l.push(o=[])),n=!1,(i=ce.exec(s))&&(n=i.shift(),o.push({value:n,type:i[0].replace(se," ")}),s=s.slice(n.length));for(r in k.filter)!(i=pe[r].exec(s))||c[r]&&!(i=c[r](i))||(n=i.shift(),o.push({value:n,type:r,matches:i}),s=s.slice(n.length));if(!n)break}return a?s.length:s?t.error(e):J(e,l).slice(0)},F=t.compile=function(e,t){var a,n=[],i=[],o=V[e+" "];if(!o){for(t||(t=C(e)),a=t.length;a--;)o=v(t[a]),o[j]?n.push(o):i.push(o);o=V(e,b(i,n)),o.selector=e}return o},A=t.select=function(e,t,a,n){var i,o,r,s,l,c="function"==typeof e&&e,u=!n&&C(e=c.selector||e);if(a=a||[],1===u.length){if(o=u[0]=u[0].slice(0),o.length>2&&"ID"===(r=o[0]).type&&9===t.nodeType&&W&&k.relative[o[1].type]){if(!(t=(k.find.ID(r.matches[0].replace(ve,be),t)||[])[0]))return a;c&&(t=t.parentNode),e=e.slice(o.shift().value.length)}for(i=pe.needsContext.test(e)?0:o.length;i--&&(r=o[i],!k.relative[s=r.type]);)if((l=k.find[s])&&(n=l(r.matches[0].replace(ve,be),we.test(o[0].type)&&h(t.parentNode)||t))){if(o.splice(i,1),!(e=n.length&&p(o)))return K.apply(a,n),a;break}}return(c||F(e,u))(n,t,!W,a,!t||we.test(e)&&h(t.parentNode)||t),a},T.sortStable=j.split("").sort(G).join("")===j,T.detectDuplicates=!!_,O(),T.sortDetached=i(function(e){return 1&e.compareDocumentPosition(L.createElement("fieldset"))}),i(function(e){return e.innerHTML="<a href='#'></a>","#"===e.firstChild.getAttribute("href")})||o("type|href|height|width",function(e,t,a){if(!a)return e.getAttribute(t,"type"===t.toLowerCase()?1:2)}),T.attributes&&i(function(e){return e.innerHTML="<input/>",e.firstChild.setAttribute("value",""),""===e.firstChild.getAttribute("value")})||o("value",function(e,t,a){if(!a&&"input"===e.nodeName.toLowerCase())return e.defaultValue}),i(function(e){return null==e.getAttribute("disabled")})||o(te,function(e,t,a){var n;if(!a)return!0===e[t]?t.toLowerCase():(n=e.getAttributeNode(t))&&n.specified?n.value:null}),t}(e);ge.find=be,ge.expr=be.selectors,ge.expr[":"]=ge.expr.pseudos,ge.uniqueSort=ge.unique=be.uniqueSort,ge.text=be.getText,ge.isXMLDoc=be.isXML,ge.contains=be.contains,ge.escapeSelector=be.escape;var xe=function(e,t,a){for(var n=[],i=void 0!==a;(e=e[t])&&9!==e.nodeType;)if(1===e.nodeType){if(i&&ge(e).is(a))break;n.push(e)}return n},Te=function(e,t){for(var a=[];e;e=e.nextSibling)1===e.nodeType&&e!==t&&a.push(e);return a},ke=ge.expr.match.needsContext,Se=/^<([a-z][^\/\0>:\x20\t\r\n\f]*)[\x20\t\r\n\f]*\/?>(?:<\/\1>|)$/i,Ie=/^.[^:#\[\.,]*$/;ge.filter=function(e,t,a){var n=t[0];return a&&(e=":not("+e+")"),1===t.length&&1===n.nodeType?ge.find.matchesSelector(n,e)?[n]:[]:ge.find.matches(e,ge.grep(t,function(e){return 1===e.nodeType}))},ge.fn.extend({find:function(e){var t,a,n=this.length,i=this;if("string"!=typeof e)return this.pushStack(ge(e).filter(function(){for(t=0;t<n;t++)if(ge.contains(i[t],this))return!0}));for(a=this.pushStack([]),t=0;t<n;t++)ge.find(e,i[t],a);return n>1?ge.uniqueSort(a):a},filter:function(e){return this.pushStack(o(this,e||[],!1))},not:function(e){return this.pushStack(o(this,e||[],!0))},is:function(e){return!!o(this,"string"==typeof e&&ke.test(e)?ge(e):e||[],!1).length}});var Ce,Fe=/^(?:\s*(<[\w\W]+>)[^>]*|#([\w-]+))$/;(ge.fn.init=function(e,t,a){var n,i;if(!e)return this;if(a=a||Ce,"string"==typeof e){if(!(n="<"===e[0]&&">"===e[e.length-1]&&e.length>=3?[null,e,null]:Fe.exec(e))||!n[1]&&t)return!t||t.jquery?(t||a).find(e):this.constructor(t).find(e);if(n[1]){if(t=t instanceof ge?t[0]:t,ge.merge(this,ge.parseHTML(n[1],t&&t.nodeType?t.ownerDocument||t:ae,!0)),Se.test(n[1])&&ge.isPlainObject(t))for(n in t)ge.isFunction(this[n])?this[n](t[n]):this.attr(n,t[n]);return this}return i=ae.getElementById(n[2]),i&&(this[0]=i,this.length=1),this}return e.nodeType?(this[0]=e,this.length=1,this):ge.isFunction(e)?void 0!==a.ready?a.ready(e):e(ge):ge.makeArray(e,this)}).prototype=ge.fn,Ce=ge(ae);var Ae=/^(?:parents|prev(?:Until|All))/,Ne={children:!0,contents:!0,next:!0,prev:!0};ge.fn.extend({has:function(e){var t=ge(e,this),a=t.length;return this.filter(function(){for(var e=0;e<a;e++)if(ge.contains(this,t[e]))return!0})},closest:function(e,t){var a,n=0,i=this.length,o=[],r="string"!=typeof e&&ge(e);if(!ke.test(e))for(;n<i;n++)for(a=this[n];a&&a!==t;a=a.parentNode)if(a.nodeType<11&&(r?r.index(a)>-1:1===a.nodeType&&ge.find.matchesSelector(a,e))){o.push(a);break}return this.pushStack(o.length>1?ge.uniqueSort(o):o)},index:function(e){return e?"string"==typeof e?se.call(ge(e),this[0]):se.call(this,e.jquery?e[0]:e):this[0]&&this[0].parentNode?this.first().prevAll().length:-1},add:function(e,t){return this.pushStack(ge.uniqueSort(ge.merge(this.get(),ge(e,t))))},addBack:function(e){return this.add(null==e?this.prevObject:this.prevObject.filter(e))}}),ge.each({parent:function(e){var t=e.parentNode;return t&&11!==t.nodeType?t:null},parents:function(e){return xe(e,"parentNode")},parentsUntil:function(e,t,a){return xe(e,"parentNode",a)},next:function(e){return r(e,"nextSibling")},prev:function(e){return r(e,"previousSibling")},nextAll:function(e){return xe(e,"nextSibling")},prevAll:function(e){return xe(e,"previousSibling")},nextUntil:function(e,t,a){return xe(e,"nextSibling",a)},prevUntil:function(e,t,a){return xe(e,"previousSibling",a)},siblings:function(e){return Te((e.parentNode||{}).firstChild,e)},children:function(e){return Te(e.firstChild)},contents:function(e){return i(e,"iframe")?e.contentDocument:(i(e,"template")&&(e=e.content||e),ge.merge([],e.childNodes))}},function(e,t){ge.fn[e]=function(a,n){var i=ge.map(this,t,a);return"Until"!==e.slice(-5)&&(n=a),n&&"string"==typeof n&&(i=ge.filter(n,i)),this.length>1&&(Ne[e]||ge.uniqueSort(i),Ae.test(e)&&i.reverse()),this.pushStack(i)}});var Ee=/[^\x20\t\r\n\f]+/g;ge.Callbacks=function(e){e="string"==typeof e?s(e):ge.extend({},e);var t,a,n,i,o=[],r=[],l=-1,c=function(){for(i=i||e.once,n=t=!0;r.length;l=-1)for(a=r.shift();++l<o.length;)!1===o[l].apply(a[0],a[1])&&e.stopOnFalse&&(l=o.length,a=!1);e.memory||(a=!1),t=!1,i&&(o=a?[]:"")},u={add:function(){return o&&(a&&!t&&(l=o.length-1,r.push(a)),function t(a){ge.each(a,function(a,n){ge.isFunction(n)?e.unique&&u.has(n)||o.push(n):n&&n.length&&"string"!==ge.type(n)&&t(n)})}(arguments),a&&!t&&c()),this},remove:function(){return ge.each(arguments,function(e,t){for(var a;(a=ge.inArray(t,o,a))>-1;)o.splice(a,1),a<=l&&l--}),this},has:function(e){return e?ge.inArray(e,o)>-1:o.length>0},empty:function(){return o&&(o=[]),this},disable:function(){return i=r=[],o=a="",this},disabled:function(){return!o},lock:function(){return i=r=[],a||t||(o=a=""),this},locked:function(){return!!i},fireWith:function(e,a){return i||(a=a||[],a=[e,a.slice?a.slice():a],r.push(a),t||c()),this},fire:function(){return u.fireWith(this,arguments),this},fired:function(){return!!n}};return u},ge.extend({Deferred:function(t){var a=[["notify","progress",ge.Callbacks("memory"),ge.Callbacks("memory"),2],["resolve","done",ge.Callbacks("once memory"),ge.Callbacks("once memory"),0,"resolved"],["reject","fail",ge.Callbacks("once memory"),ge.Callbacks("once memory"),1,"rejected"]],n="pending",i={state:function(){return n},always:function(){return o.done(arguments).fail(arguments),this},"catch":function(e){return i.then(null,e)},pipe:function(){var e=arguments;return ge.Deferred(function(t){ge.each(a,function(a,n){var i=ge.isFunction(e[n[4]])&&e[n[4]];o[n[1]](function(){var e=i&&i.apply(this,arguments);e&&ge.isFunction(e.promise)?e.promise().progress(t.notify).done(t.resolve).fail(t.reject):t[n[0]+"With"](this,i?[e]:arguments)})}),e=null}).promise()},then:function(t,n,i){function o(t,a,n,i){return function(){var s=this,u=arguments,h=function(){var e,h;if(!(t<r)){if((e=n.apply(s,u))===a.promise())throw new TypeError("Thenable self-resolution");h=e&&("object"==typeof e||"function"==typeof e)&&e.then,ge.isFunction(h)?i?h.call(e,o(r,a,l,i),o(r,a,c,i)):(r++,h.call(e,o(r,a,l,i),o(r,a,c,i),o(r,a,l,a.notifyWith))):(n!==l&&(s=void 0,u=[e]),(i||a.resolveWith)(s,u))}},d=i?h:function(){try{h()}catch(e){ge.Deferred.exceptionHook&&ge.Deferred.exceptionHook(e,d.stackTrace),t+1>=r&&(n!==c&&(s=void 0,u=[e]),a.rejectWith(s,u))}};t?d():(ge.Deferred.getStackHook&&(d.stackTrace=ge.Deferred.getStackHook()),e.setTimeout(d))}}var r=0;return ge.Deferred(function(e){a[0][3].add(o(0,e,ge.isFunction(i)?i:l,e.notifyWith)),a[1][3].add(o(0,e,ge.isFunction(t)?t:l)),a[2][3].add(o(0,e,ge.isFunction(n)?n:c))}).promise()},promise:function(e){return null!=e?ge.extend(e,i):i}},o={};return ge.each(a,function(e,t){var r=t[2],s=t[5];i[t[1]]=r.add,s&&r.add(function(){n=s},a[3-e][2].disable,a[0][2].lock),r.add(t[3].fire),o[t[0]]=function(){return o[t[0]+"With"](this===o?void 0:this,arguments),this},o[t[0]+"With"]=r.fireWith}),i.promise(o),t&&t.call(o,o),o},when:function(e){var t=arguments.length,a=t,n=Array(a),i=ie.call(arguments),o=ge.Deferred(),r=function(e){return function(a){n[e]=this,i[e]=arguments.length>1?ie.call(arguments):a,--t||o.resolveWith(n,i)}};if(t<=1&&(u(e,o.done(r(a)).resolve,o.reject,!t),"pending"===o.state()||ge.isFunction(i[a]&&i[a].then)))return o.then();for(;a--;)u(i[a],r(a),o.reject);return o.promise()}});var _e=/^(Eval|Internal|Range|Reference|Syntax|Type|URI)Error$/;ge.Deferred.exceptionHook=function(t,a){e.console&&e.console.warn&&t&&_e.test(t.name)&&e.console.warn("jQuery.Deferred exception: "+t.message,t.stack,a)},ge.readyException=function(t){e.setTimeout(function(){throw t})};var Oe=ge.Deferred();ge.fn.ready=function(e){return Oe.then(e)["catch"](function(e){ge.readyException(e)}),this},ge.extend({isReady:!1,readyWait:1,ready:function(e){(!0===e?--ge.readyWait:ge.isReady)||(ge.isReady=!0,!0!==e&&--ge.readyWait>0||Oe.resolveWith(ae,[ge]))}}),ge.ready.then=Oe.then,"complete"===ae.readyState||"loading"!==ae.readyState&&!ae.documentElement.doScroll?e.setTimeout(ge.ready):(ae.addEventListener("DOMContentLoaded",h),e.addEventListener("load",h));var Le=function(e,t,a,n,i,o,r){var s=0,l=e.length,c=null==a;if("object"===ge.type(a)){i=!0;for(s in a)Le(e,t,s,a[s],!0,o,r)}else if(void 0!==n&&(i=!0,ge.isFunction(n)||(r=!0),c&&(r?(t.call(e,n),t=null):(c=t,t=function(e,t,a){return c.call(ge(e),a)})),t))for(;s<l;s++)t(e[s],a,r?n:n.call(e[s],s,t(e[s],a)));return i?e:c?t.call(e):l?t(e[0],a):o},Me=function(e){return 1===e.nodeType||9===e.nodeType||!+e.nodeType};d.uid=1,d.prototype={cache:function(e){var t=e[this.expando];return t||(t={},Me(e)&&(e.nodeType?e[this.expando]=t:Object.defineProperty(e,this.expando,{value:t,configurable:!0}))),t},set:function(e,t,a){var n,i=this.cache(e);if("string"==typeof t)i[ge.camelCase(t)]=a;else for(n in t)i[ge.camelCase(n)]=t[n];return i},get:function(e,t){return void 0===t?this.cache(e):e[this.expando]&&e[this.expando][ge.camelCase(t)]},access:function(e,t,a){return void 0===t||t&&"string"==typeof t&&void 0===a?this.get(e,t):(this.set(e,t,a),void 0!==a?a:t)},remove:function(e,t){var a,n=e[this.expando];if(void 0!==n){if(void 0!==t){Array.isArray(t)?t=t.map(ge.camelCase):(t=ge.camelCase(t),t=t in n?[t]:t.match(Ee)||[]),a=t.length;for(;a--;)delete n[t[a]]}(void 0===t||ge.isEmptyObject(n))&&(e.nodeType?e[this.expando]=void 0:delete e[this.expando])}},hasData:function(e){var t=e[this.expando];return void 0!==t&&!ge.isEmptyObject(t)}};var We=new d,qe=new d,Pe=/^(?:\{[\w\W]*\}|\[[\w\W]*\])$/,Be=/[A-Z]/g;ge.extend({hasData:function(e){return qe.hasData(e)||We.hasData(e)},data:function(e,t,a){return qe.access(e,t,a)},removeData:function(e,t){qe.remove(e,t)},_data:function(e,t,a){return We.access(e,t,a)},_removeData:function(e,t){We.remove(e,t)}}),ge.fn.extend({data:function(e,t){var a,n,i,o=this[0],r=o&&o.attributes;if(void 0===e){if(this.length&&(i=qe.get(o),1===o.nodeType&&!We.get(o,"hasDataAttrs"))){for(a=r.length;a--;)r[a]&&(n=r[a].name,0===n.indexOf("data-")&&(n=ge.camelCase(n.slice(5)),f(o,n,i[n])));We.set(o,"hasDataAttrs",!0)}return i}return"object"==typeof e?this.each(function(){qe.set(this,e)}):Le(this,function(t){var a;if(o&&void 0===t){if(void 0!==(a=qe.get(o,e)))return a;if(void 0!==(a=f(o,e)))return a}else this.each(function(){qe.set(this,e,t)})},null,t,arguments.length>1,null,!0)},removeData:function(e){return this.each(function(){qe.remove(this,e)})}}),ge.extend({queue:function(e,t,a){var n;if(e)return t=(t||"fx")+"queue",n=We.get(e,t),a&&(!n||Array.isArray(a)?n=We.access(e,t,ge.makeArray(a)):n.push(a)),n||[]},dequeue:function(e,t){t=t||"fx";var a=ge.queue(e,t),n=a.length,i=a.shift(),o=ge._queueHooks(e,t),r=function(){ge.dequeue(e,t)};"inprogress"===i&&(i=a.shift(),n--),i&&("fx"===t&&a.unshift("inprogress"),delete o.stop,i.call(e,r,o)),!n&&o&&o.empty.fire()},_queueHooks:function(e,t){var a=t+"queueHooks";return We.get(e,a)||We.access(e,a,{empty:ge.Callbacks("once memory").add(function(){We.remove(e,[t+"queue",a])})})}}),ge.fn.extend({queue:function(e,t){var a=2;return"string"!=typeof e&&(t=e,e="fx",a--),arguments.length<a?ge.queue(this[0],e):void 0===t?this:this.each(function(){var a=ge.queue(this,e,t);ge._queueHooks(this,e),"fx"===e&&"inprogress"!==a[0]&&ge.dequeue(this,e)})},dequeue:function(e){return this.each(function(){ge.dequeue(this,e)})},clearQueue:function(e){return this.queue(e||"fx",[])},promise:function(e,t){var a,n=1,i=ge.Deferred(),o=this,r=this.length,s=function(){--n||i.resolveWith(o,[o])};for("string"!=typeof e&&(t=e,e=void 0),e=e||"fx";r--;)(a=We.get(o[r],e+"queueHooks"))&&a.empty&&(n++,a.empty.add(s));return s(),i.promise(t)}});var De=/[+-]?(?:\d*\.|)\d+(?:[eE][+-]?\d+|)/.source,je=new RegExp("^(?:([+-])=|)("+De+")([a-z%]*)$","i"),Re=["Top","Right","Bottom","Left"],He=function(e,t){return e=t||e,"none"===e.style.display||""===e.style.display&&ge.contains(e.ownerDocument,e)&&"none"===ge.css(e,"display")},ze=function(e,t,a,n){var i,o,r={};for(o in t)r[o]=e.style[o],e.style[o]=t[o];i=a.apply(e,n||[]);for(o in t)e.style[o]=r[o];return i},$e={};ge.fn.extend({show:function(){return y(this,!0)},hide:function(){return y(this)},toggle:function(e){return"boolean"==typeof e?e?this.show():this.hide():this.each(function(){He(this)?ge(this).show():ge(this).hide()})}});var Je=/^(?:checkbox|radio)$/i,Ve=/<([a-z][^\/\0>\x20\t\r\n\f]+)/i,Ge=/^$|\/(?:java|ecma)script/i,Ue={option:[1,"<select multiple='multiple'>","</select>"],thead:[1,"<table>","</table>"],col:[2,"<table><colgroup>","</colgroup></table>"],tr:[2,"<table><tbody>","</tbody></table>"],td:[3,"<table><tbody><tr>","</tr></tbody></table>"],_default:[0,"",""]};Ue.optgroup=Ue.option,Ue.tbody=Ue.tfoot=Ue.colgroup=Ue.caption=Ue.thead,Ue.th=Ue.td;var Ye=/<|&#?\w+;/;!function(){var e=ae.createDocumentFragment(),t=e.appendChild(ae.createElement("div")),a=ae.createElement("input");a.setAttribute("type","radio"),a.setAttribute("checked","checked"),a.setAttribute("name","t"),t.appendChild(a),pe.checkClone=t.cloneNode(!0).cloneNode(!0).lastChild.checked,t.innerHTML="<textarea>x</textarea>",pe.noCloneChecked=!!t.cloneNode(!0).lastChild.defaultValue}();var Qe=ae.documentElement,Xe=/^key/,Ke=/^(?:mouse|pointer|contextmenu|drag|drop)|click/,Ze=/^([^.]*)(?:\.(.+)|)/;ge.event={global:{},add:function(e,t,a,n,i){var o,r,s,l,c,u,h,d,p,f,g,m=We.get(e);if(m)for(a.handler&&(o=a,a=o.handler,i=o.selector),i&&ge.find.matchesSelector(Qe,i),a.guid||(a.guid=ge.guid++),(l=m.events)||(l=m.events={}),(r=m.handle)||(r=m.handle=function(t){return void 0!==ge&&ge.event.triggered!==t.type?ge.event.dispatch.apply(e,arguments):void 0}),t=(t||"").match(Ee)||[""],c=t.length;c--;)s=Ze.exec(t[c])||[],p=g=s[1],f=(s[2]||"").split(".").sort(),p&&(h=ge.event.special[p]||{},p=(i?h.delegateType:h.bindType)||p,h=ge.event.special[p]||{},u=ge.extend({type:p,origType:g,data:n,handler:a,guid:a.guid,selector:i,needsContext:i&&ge.expr.match.needsContext.test(i),namespace:f.join(".")},o),(d=l[p])||(d=l[p]=[],d.delegateCount=0,h.setup&&!1!==h.setup.call(e,n,f,r)||e.addEventListener&&e.addEventListener(p,r)),h.add&&(h.add.call(e,u),u.handler.guid||(u.handler.guid=a.guid)),i?d.splice(d.delegateCount++,0,u):d.push(u),ge.event.global[p]=!0)},remove:function(e,t,a,n,i){var o,r,s,l,c,u,h,d,p,f,g,m=We.hasData(e)&&We.get(e);if(m&&(l=m.events)){for(t=(t||"").match(Ee)||[""],c=t.length;c--;)if(s=Ze.exec(t[c])||[],p=g=s[1],f=(s[2]||"").split(".").sort(),p){for(h=ge.event.special[p]||{},p=(n?h.delegateType:h.bindType)||p,d=l[p]||[],s=s[2]&&new RegExp("(^|\\.)"+f.join("\\.(?:.*\\.|)")+"(\\.|$)"),r=o=d.length;o--;)u=d[o],!i&&g!==u.origType||a&&a.guid!==u.guid||s&&!s.test(u.namespace)||n&&n!==u.selector&&("**"!==n||!u.selector)||(d.splice(o,1),u.selector&&d.delegateCount--,h.remove&&h.remove.call(e,u));r&&!d.length&&(h.teardown&&!1!==h.teardown.call(e,f,m.handle)||ge.removeEvent(e,p,m.handle),delete l[p])}else for(p in l)ge.event.remove(e,p+t[c],a,n,!0);ge.isEmptyObject(l)&&We.remove(e,"handle events")}},dispatch:function(e){var t,a,n,i,o,r,s=ge.event.fix(e),l=new Array(arguments.length),c=(We.get(this,"events")||{})[s.type]||[],u=ge.event.special[s.type]||{};for(l[0]=s,t=1;t<arguments.length;t++)l[t]=arguments[t];if(s.delegateTarget=this,!u.preDispatch||!1!==u.preDispatch.call(this,s)){for(r=ge.event.handlers.call(this,s,c),t=0;(i=r[t++])&&!s.isPropagationStopped();)for(s.currentTarget=i.elem,a=0;(o=i.handlers[a++])&&!s.isImmediatePropagationStopped();)s.rnamespace&&!s.rnamespace.test(o.namespace)||(s.handleObj=o,s.data=o.data,void 0!==(n=((ge.event.special[o.origType]||{}).handle||o.handler).apply(i.elem,l))&&!1===(s.result=n)&&(s.preventDefault(),s.stopPropagation()));return u.postDispatch&&u.postDispatch.call(this,s),s.result}},handlers:function(e,t){var a,n,i,o,r,s=[],l=t.delegateCount,c=e.target;if(l&&c.nodeType&&!("click"===e.type&&e.button>=1))for(;c!==this;c=c.parentNode||this)if(1===c.nodeType&&("click"!==e.type||!0!==c.disabled)){for(o=[],r={},a=0;a<l;a++)n=t[a],i=n.selector+" ",void 0===r[i]&&(r[i]=n.needsContext?ge(i,this).index(c)>-1:ge.find(i,this,null,[c]).length),r[i]&&o.push(n);o.length&&s.push({elem:c,handlers:o})}return c=this,l<t.length&&s.push({elem:c,handlers:t.slice(l)}),s},addProp:function(e,t){Object.defineProperty(ge.Event.prototype,e,{enumerable:!0,configurable:!0,get:ge.isFunction(t)?function(){if(this.originalEvent)return t(this.originalEvent)}:function(){if(this.originalEvent)return this.originalEvent[e]},set:function(t){Object.defineProperty(this,e,{enumerable:!0,configurable:!0,writable:!0,value:t})}})},fix:function(e){return e[ge.expando]?e:new ge.Event(e)},special:{load:{noBubble:!0},focus:{trigger:function(){if(this!==k()&&this.focus)return this.focus(),!1},delegateType:"focusin"},blur:{trigger:function(){if(this===k()&&this.blur)return this.blur(),!1},delegateType:"focusout"},click:{trigger:function(){if("checkbox"===this.type&&this.click&&i(this,"input"))return this.click(),!1},_default:function(e){return i(e.target,"a")}},beforeunload:{postDispatch:function(e){void 0!==e.result&&e.originalEvent&&(e.originalEvent.returnValue=e.result)}}}},ge.removeEvent=function(e,t,a){e.removeEventListener&&e.removeEventListener(t,a)},ge.Event=function(e,t){return this instanceof ge.Event?(e&&e.type?(this.originalEvent=e,this.type=e.type,this.isDefaultPrevented=e.defaultPrevented||void 0===e.defaultPrevented&&!1===e.returnValue?x:T,this.target=e.target&&3===e.target.nodeType?e.target.parentNode:e.target,this.currentTarget=e.currentTarget,this.relatedTarget=e.relatedTarget):this.type=e,t&&ge.extend(this,t),this.timeStamp=e&&e.timeStamp||ge.now(),void(this[ge.expando]=!0)):new ge.Event(e,t)},ge.Event.prototype={constructor:ge.Event,isDefaultPrevented:T,isPropagationStopped:T,isImmediatePropagationStopped:T,isSimulated:!1,preventDefault:function(){var e=this.originalEvent;this.isDefaultPrevented=x,e&&!this.isSimulated&&e.preventDefault()},stopPropagation:function(){var e=this.originalEvent;this.isPropagationStopped=x,e&&!this.isSimulated&&e.stopPropagation()},stopImmediatePropagation:function(){var e=this.originalEvent;this.isImmediatePropagationStopped=x,e&&!this.isSimulated&&e.stopImmediatePropagation(),this.stopPropagation()}},ge.each({altKey:!0,bubbles:!0,cancelable:!0,changedTouches:!0,ctrlKey:!0,detail:!0,eventPhase:!0,metaKey:!0,pageX:!0,pageY:!0,shiftKey:!0,view:!0,"char":!0,charCode:!0,key:!0,keyCode:!0,button:!0,buttons:!0,clientX:!0,clientY:!0,offsetX:!0,offsetY:!0,pointerId:!0,pointerType:!0,screenX:!0,screenY:!0,targetTouches:!0,toElement:!0,touches:!0,which:function(e){var t=e.button;return null==e.which&&Xe.test(e.type)?null!=e.charCode?e.charCode:e.keyCode:!e.which&&void 0!==t&&Ke.test(e.type)?1&t?1:2&t?3:4&t?2:0:e.which}},ge.event.addProp),ge.each({mouseenter:"mouseover",mouseleave:"mouseout",pointerenter:"pointerover",pointerleave:"pointerout"},function(e,t){ge.event.special[e]={delegateType:t,bindType:t,handle:function(e){var a,n=this,i=e.relatedTarget,o=e.handleObj;return i&&(i===n||ge.contains(n,i))||(e.type=o.origType,a=o.handler.apply(this,arguments),e.type=t),a}}}),ge.fn.extend({on:function(e,t,a,n){return S(this,e,t,a,n)},one:function(e,t,a,n){return S(this,e,t,a,n,1)},off:function(e,t,a){var n,i;if(e&&e.preventDefault&&e.handleObj)return n=e.handleObj,ge(e.delegateTarget).off(n.namespace?n.origType+"."+n.namespace:n.origType,n.selector,n.handler),this;if("object"==typeof e){for(i in e)this.off(i,t,e[i]);return this}return!1!==t&&"function"!=typeof t||(a=t,t=void 0),!1===a&&(a=T),this.each(function(){ge.event.remove(this,e,a,t)})}});var et=/<(?!area|br|col|embed|hr|img|input|link|meta|param)(([a-z][^\/\0>\x20\t\r\n\f]*)[^>]*)\/>/gi,tt=/<script|<style|<link/i,at=/checked\s*(?:[^=]|=\s*.checked.)/i,nt=/^true\/(.*)/,it=/^\s*<!(?:\[CDATA\[|--)|(?:\]\]|--)>\s*$/g;ge.extend({htmlPrefilter:function(e){return e.replace(et,"<$1></$2>")},clone:function(e,t,a){var n,i,o,r,s=e.cloneNode(!0),l=ge.contains(e.ownerDocument,e);if(!(pe.noCloneChecked||1!==e.nodeType&&11!==e.nodeType||ge.isXMLDoc(e)))for(r=w(s),o=w(e),n=0,i=o.length;n<i;n++)N(o[n],r[n]);if(t)if(a)for(o=o||w(e),r=r||w(s),n=0,i=o.length;n<i;n++)A(o[n],r[n]);else A(e,s);return r=w(s,"script"),r.length>0&&v(r,!l&&w(e,"script")),s},cleanData:function(e){for(var t,a,n,i=ge.event.special,o=0;void 0!==(a=e[o]);o++)if(Me(a)){if(t=a[We.expando]){if(t.events)for(n in t.events)i[n]?ge.event.remove(a,n):ge.removeEvent(a,n,t.handle);a[We.expando]=void 0}a[qe.expando]&&(a[qe.expando]=void 0)}}}),ge.fn.extend({detach:function(e){return _(this,e,!0)},remove:function(e){return _(this,e)},text:function(e){return Le(this,function(e){return void 0===e?ge.text(this):this.empty().each(function(){1!==this.nodeType&&11!==this.nodeType&&9!==this.nodeType||(this.textContent=e)})},null,e,arguments.length)},append:function(){return E(this,arguments,function(e){if(1===this.nodeType||11===this.nodeType||9===this.nodeType){I(this,e).appendChild(e)}})},prepend:function(){return E(this,arguments,function(e){if(1===this.nodeType||11===this.nodeType||9===this.nodeType){var t=I(this,e);t.insertBefore(e,t.firstChild)}})},before:function(){return E(this,arguments,function(e){this.parentNode&&this.parentNode.insertBefore(e,this)})},after:function(){return E(this,arguments,function(e){this.parentNode&&this.parentNode.insertBefore(e,this.nextSibling)})},empty:function(){for(var e,t=0;null!=(e=this[t]);t++)1===e.nodeType&&(ge.cleanData(w(e,!1)),e.textContent="");return this},clone:function(e,t){return e=null!=e&&e,t=null==t?e:t,this.map(function(){return ge.clone(this,e,t)})},html:function(e){return Le(this,function(e){var t=this[0]||{},a=0,n=this.length;if(void 0===e&&1===t.nodeType)return t.innerHTML;if("string"==typeof e&&!tt.test(e)&&!Ue[(Ve.exec(e)||["",""])[1].toLowerCase()]){e=ge.htmlPrefilter(e);try{for(;a<n;a++)t=this[a]||{},1===t.nodeType&&(ge.cleanData(w(t,!1)),t.innerHTML=e);t=0}catch(e){}}t&&this.empty().append(e)},null,e,arguments.length)},replaceWith:function(){var e=[];return E(this,arguments,function(t){var a=this.parentNode;ge.inArray(this,e)<0&&(ge.cleanData(w(this)),a&&a.replaceChild(t,this))},e)}}),ge.each({appendTo:"append",prependTo:"prepend",insertBefore:"before",insertAfter:"after",replaceAll:"replaceWith"},function(e,t){ge.fn[e]=function(e){for(var a,n=[],i=ge(e),o=i.length-1,r=0;r<=o;r++)a=r===o?this:this.clone(!0),ge(i[r])[t](a),re.apply(n,a.get());return this.pushStack(n)}});var ot=/^margin/,rt=new RegExp("^("+De+")(?!px)[a-z%]+$","i"),st=function(t){var a=t.ownerDocument.defaultView;return a&&a.opener||(a=e),a.getComputedStyle(t)};!function(){function t(){if(s){s.style.cssText="box-sizing:border-box;position:relative;display:block;margin:auto;border:1px;padding:1px;top:1%;width:50%",s.innerHTML="",Qe.appendChild(r);var t=e.getComputedStyle(s);a="1%"!==t.top,o="2px"===t.marginLeft,n="4px"===t.width,s.style.marginRight="50%",i="4px"===t.marginRight,Qe.removeChild(r),s=null}}var a,n,i,o,r=ae.createElement("div"),s=ae.createElement("div");s.style&&(s.style.backgroundClip="content-box",s.cloneNode(!0).style.backgroundClip="",pe.clearCloneStyle="content-box"===s.style.backgroundClip,r.style.cssText="border:0;width:8px;height:0;top:0;left:-9999px;padding:0;margin-top:1px;position:absolute",r.appendChild(s),ge.extend(pe,{pixelPosition:function(){return t(),a},boxSizingReliable:function(){return t(),n},pixelMarginRight:function(){return t(),i},reliableMarginLeft:function(){return t(),o}}))}();var lt=/^(none|table(?!-c[ea]).+)/,ct=/^--/,ut={position:"absolute",visibility:"hidden",display:"block"},ht={letterSpacing:"0",fontWeight:"400"},dt=["Webkit","Moz","ms"],pt=ae.createElement("div").style;ge.extend({cssHooks:{opacity:{get:function(e,t){if(t){var a=O(e,"opacity");return""===a?"1":a}}}},cssNumber:{animationIterationCount:!0,columnCount:!0,fillOpacity:!0,flexGrow:!0,flexShrink:!0,fontWeight:!0,lineHeight:!0,opacity:!0,order:!0,orphans:!0,widows:!0,zIndex:!0,zoom:!0},cssProps:{"float":"cssFloat"},style:function(e,t,a,n){if(e&&3!==e.nodeType&&8!==e.nodeType&&e.style){var i,o,r,s=ge.camelCase(t),l=ct.test(t),c=e.style;return l||(t=W(s)),r=ge.cssHooks[t]||ge.cssHooks[s],void 0===a?r&&"get"in r&&void 0!==(i=r.get(e,!1,n))?i:c[t]:(o=typeof a,"string"===o&&(i=je.exec(a))&&i[1]&&(a=g(e,t,i),o="number"),void(null!=a&&a===a&&("number"===o&&(a+=i&&i[3]||(ge.cssNumber[s]?"":"px")),pe.clearCloneStyle||""!==a||0!==t.indexOf("background")||(c[t]="inherit"),r&&"set"in r&&void 0===(a=r.set(e,a,n))||(l?c.setProperty(t,a):c[t]=a))))}},css:function(e,t,a,n){var i,o,r,s=ge.camelCase(t);return ct.test(t)||(t=W(s)),r=ge.cssHooks[t]||ge.cssHooks[s],r&&"get"in r&&(i=r.get(e,!0,a)),void 0===i&&(i=O(e,t,n)),"normal"===i&&t in ht&&(i=ht[t]),""===a||a?(o=parseFloat(i),!0===a||isFinite(o)?o||0:i):i}}),ge.each(["height","width"],function(e,t){ge.cssHooks[t]={get:function(e,a,n){if(a)return!lt.test(ge.css(e,"display"))||e.getClientRects().length&&e.getBoundingClientRect().width?B(e,t,n):ze(e,ut,function(){return B(e,t,n)})},set:function(e,a,n){var i,o=n&&st(e),r=n&&P(e,t,n,"border-box"===ge.css(e,"boxSizing",!1,o),o);return r&&(i=je.exec(a))&&"px"!==(i[3]||"px")&&(e.style[t]=a,a=ge.css(e,t)),q(e,a,r)}}}),ge.cssHooks.marginLeft=L(pe.reliableMarginLeft,function(e,t){if(t)return(parseFloat(O(e,"marginLeft"))||e.getBoundingClientRect().left-ze(e,{marginLeft:0},function(){return e.getBoundingClientRect().left}))+"px"}),ge.each({margin:"",padding:"",border:"Width"},function(e,t){ge.cssHooks[e+t]={expand:function(a){for(var n=0,i={},o="string"==typeof a?a.split(" "):[a];n<4;n++)i[e+Re[n]+t]=o[n]||o[n-2]||o[0];return i}},ot.test(e)||(ge.cssHooks[e+t].set=q)}),ge.fn.extend({css:function(e,t){return Le(this,function(e,t,a){var n,i,o={},r=0;if(Array.isArray(t)){for(n=st(e),i=t.length;r<i;r++)o[t[r]]=ge.css(e,t[r],!1,n);return o}return void 0!==a?ge.style(e,t,a):ge.css(e,t)},e,t,arguments.length>1)}}),ge.Tween=D,D.prototype={constructor:D,init:function(e,t,a,n,i,o){this.elem=e,this.prop=a,this.easing=i||ge.easing._default,this.options=t,this.start=this.now=this.cur(),this.end=n,this.unit=o||(ge.cssNumber[a]?"":"px")},cur:function(){var e=D.propHooks[this.prop];return e&&e.get?e.get(this):D.propHooks._default.get(this)},run:function(e){var t,a=D.propHooks[this.prop];return this.options.duration?this.pos=t=ge.easing[this.easing](e,this.options.duration*e,0,1,this.options.duration):this.pos=t=e,this.now=(this.end-this.start)*t+this.start,this.options.step&&this.options.step.call(this.elem,this.now,this),a&&a.set?a.set(this):D.propHooks._default.set(this),this}},D.prototype.init.prototype=D.prototype,D.propHooks={_default:{get:function(e){var t;return 1!==e.elem.nodeType||null!=e.elem[e.prop]&&null==e.elem.style[e.prop]?e.elem[e.prop]:(t=ge.css(e.elem,e.prop,""),t&&"auto"!==t?t:0)},set:function(e){ge.fx.step[e.prop]?ge.fx.step[e.prop](e):1!==e.elem.nodeType||null==e.elem.style[ge.cssProps[e.prop]]&&!ge.cssHooks[e.prop]?e.elem[e.prop]=e.now:ge.style(e.elem,e.prop,e.now+e.unit)}}},D.propHooks.scrollTop=D.propHooks.scrollLeft={set:function(e){e.elem.nodeType&&e.elem.parentNode&&(e.elem[e.prop]=e.now)}},ge.easing={linear:function(e){return e},swing:function(e){return.5-Math.cos(e*Math.PI)/2},_default:"swing"},ge.fx=D.prototype.init,ge.fx.step={};var ft,gt,mt=/^(?:toggle|show|hide)$/,yt=/queueHooks$/;ge.Animation=ge.extend(V,{tweeners:{"*":[function(e,t){var a=this.createTween(e,t);return g(a.elem,e,je.exec(t),a),a}]},tweener:function(e,t){ge.isFunction(e)?(t=e,e=["*"]):e=e.match(Ee);for(var a,n=0,i=e.length;n<i;n++)a=e[n],V.tweeners[a]=V.tweeners[a]||[],V.tweeners[a].unshift(t)},prefilters:[$],prefilter:function(e,t){t?V.prefilters.unshift(e):V.prefilters.push(e)}}),ge.speed=function(e,t,a){var n=e&&"object"==typeof e?ge.extend({},e):{complete:a||!a&&t||ge.isFunction(e)&&e,duration:e,easing:a&&t||t&&!ge.isFunction(t)&&t};return ge.fx.off?n.duration=0:"number"!=typeof n.duration&&(n.duration in ge.fx.speeds?n.duration=ge.fx.speeds[n.duration]:n.duration=ge.fx.speeds._default),null!=n.queue&&!0!==n.queue||(n.queue="fx"),n.old=n.complete,n.complete=function(){ge.isFunction(n.old)&&n.old.call(this),n.queue&&ge.dequeue(this,n.queue)},n},ge.fn.extend({fadeTo:function(e,t,a,n){return this.filter(He).css("opacity",0).show().end().animate({opacity:t},e,a,n)},animate:function(e,t,a,n){var i=ge.isEmptyObject(e),o=ge.speed(t,a,n),r=function(){var t=V(this,ge.extend({},e),o);(i||We.get(this,"finish"))&&t.stop(!0)};return r.finish=r,i||!1===o.queue?this.each(r):this.queue(o.queue,r)},stop:function(e,t,a){var n=function(e){var t=e.stop;delete e.stop,t(a)};return"string"!=typeof e&&(a=t,t=e,e=void 0),t&&!1!==e&&this.queue(e||"fx",[]),this.each(function(){var t=!0,i=null!=e&&e+"queueHooks",o=ge.timers,r=We.get(this);if(i)r[i]&&r[i].stop&&n(r[i]);else for(i in r)r[i]&&r[i].stop&&yt.test(i)&&n(r[i]);for(i=o.length;i--;)o[i].elem!==this||null!=e&&o[i].queue!==e||(o[i].anim.stop(a),t=!1,o.splice(i,1));!t&&a||ge.dequeue(this,e)})},finish:function(e){return!1!==e&&(e=e||"fx"),this.each(function(){var t,a=We.get(this),n=a[e+"queue"],i=a[e+"queueHooks"],o=ge.timers,r=n?n.length:0;for(a.finish=!0,ge.queue(this,e,[]),i&&i.stop&&i.stop.call(this,!0),t=o.length;t--;)o[t].elem===this&&o[t].queue===e&&(o[t].anim.stop(!0),o.splice(t,1));for(t=0;t<r;t++)n[t]&&n[t].finish&&n[t].finish.call(this);delete a.finish})}}),
ge.each(["toggle","show","hide"],function(e,t){var a=ge.fn[t];ge.fn[t]=function(e,n,i){return null==e||"boolean"==typeof e?a.apply(this,arguments):this.animate(H(t,!0),e,n,i)}}),ge.each({slideDown:H("show"),slideUp:H("hide"),slideToggle:H("toggle"),fadeIn:{opacity:"show"},fadeOut:{opacity:"hide"},fadeToggle:{opacity:"toggle"}},function(e,t){ge.fn[e]=function(e,a,n){return this.animate(t,e,a,n)}}),ge.timers=[],ge.fx.tick=function(){var e,t=0,a=ge.timers;for(ft=ge.now();t<a.length;t++)(e=a[t])()||a[t]!==e||a.splice(t--,1);a.length||ge.fx.stop(),ft=void 0},ge.fx.timer=function(e){ge.timers.push(e),ge.fx.start()},ge.fx.interval=13,ge.fx.start=function(){gt||(gt=!0,j())},ge.fx.stop=function(){gt=null},ge.fx.speeds={slow:600,fast:200,_default:400},ge.fn.delay=function(t,a){return t=ge.fx?ge.fx.speeds[t]||t:t,a=a||"fx",this.queue(a,function(a,n){var i=e.setTimeout(a,t);n.stop=function(){e.clearTimeout(i)}})},function(){var e=ae.createElement("input"),t=ae.createElement("select"),a=t.appendChild(ae.createElement("option"));e.type="checkbox",pe.checkOn=""!==e.value,pe.optSelected=a.selected,e=ae.createElement("input"),e.value="t",e.type="radio",pe.radioValue="t"===e.value}();var wt,vt=ge.expr.attrHandle;ge.fn.extend({attr:function(e,t){return Le(this,ge.attr,e,t,arguments.length>1)},removeAttr:function(e){return this.each(function(){ge.removeAttr(this,e)})}}),ge.extend({attr:function(e,t,a){var n,i,o=e.nodeType;if(3!==o&&8!==o&&2!==o)return"undefined"==typeof e.getAttribute?ge.prop(e,t,a):(1===o&&ge.isXMLDoc(e)||(i=ge.attrHooks[t.toLowerCase()]||(ge.expr.match.bool.test(t)?wt:void 0)),void 0!==a?null===a?void ge.removeAttr(e,t):i&&"set"in i&&void 0!==(n=i.set(e,a,t))?n:(e.setAttribute(t,a+""),a):i&&"get"in i&&null!==(n=i.get(e,t))?n:(n=ge.find.attr(e,t),null==n?void 0:n))},attrHooks:{type:{set:function(e,t){if(!pe.radioValue&&"radio"===t&&i(e,"input")){var a=e.value;return e.setAttribute("type",t),a&&(e.value=a),t}}}},removeAttr:function(e,t){var a,n=0,i=t&&t.match(Ee);if(i&&1===e.nodeType)for(;a=i[n++];)e.removeAttribute(a)}}),wt={set:function(e,t,a){return!1===t?ge.removeAttr(e,a):e.setAttribute(a,a),a}},ge.each(ge.expr.match.bool.source.match(/\w+/g),function(e,t){var a=vt[t]||ge.find.attr;vt[t]=function(e,t,n){var i,o,r=t.toLowerCase();return n||(o=vt[r],vt[r]=i,i=null!=a(e,t,n)?r:null,vt[r]=o),i}});var bt=/^(?:input|select|textarea|button)$/i,xt=/^(?:a|area)$/i;ge.fn.extend({prop:function(e,t){return Le(this,ge.prop,e,t,arguments.length>1)},removeProp:function(e){return this.each(function(){delete this[ge.propFix[e]||e]})}}),ge.extend({prop:function(e,t,a){var n,i,o=e.nodeType;if(3!==o&&8!==o&&2!==o)return 1===o&&ge.isXMLDoc(e)||(t=ge.propFix[t]||t,i=ge.propHooks[t]),void 0!==a?i&&"set"in i&&void 0!==(n=i.set(e,a,t))?n:e[t]=a:i&&"get"in i&&null!==(n=i.get(e,t))?n:e[t]},propHooks:{tabIndex:{get:function(e){var t=ge.find.attr(e,"tabindex");return t?parseInt(t,10):bt.test(e.nodeName)||xt.test(e.nodeName)&&e.href?0:-1}}},propFix:{"for":"htmlFor","class":"className"}}),pe.optSelected||(ge.propHooks.selected={get:function(e){var t=e.parentNode;return t&&t.parentNode&&t.parentNode.selectedIndex,null},set:function(e){var t=e.parentNode;t&&(t.selectedIndex,t.parentNode&&t.parentNode.selectedIndex)}}),ge.each(["tabIndex","readOnly","maxLength","cellSpacing","cellPadding","rowSpan","colSpan","useMap","frameBorder","contentEditable"],function(){ge.propFix[this.toLowerCase()]=this}),ge.fn.extend({addClass:function(e){var t,a,n,i,o,r,s,l=0;if(ge.isFunction(e))return this.each(function(t){ge(this).addClass(e.call(this,t,U(this)))});if("string"==typeof e&&e)for(t=e.match(Ee)||[];a=this[l++];)if(i=U(a),n=1===a.nodeType&&" "+G(i)+" "){for(r=0;o=t[r++];)n.indexOf(" "+o+" ")<0&&(n+=o+" ");s=G(n),i!==s&&a.setAttribute("class",s)}return this},removeClass:function(e){var t,a,n,i,o,r,s,l=0;if(ge.isFunction(e))return this.each(function(t){ge(this).removeClass(e.call(this,t,U(this)))});if(!arguments.length)return this.attr("class","");if("string"==typeof e&&e)for(t=e.match(Ee)||[];a=this[l++];)if(i=U(a),n=1===a.nodeType&&" "+G(i)+" "){for(r=0;o=t[r++];)for(;n.indexOf(" "+o+" ")>-1;)n=n.replace(" "+o+" "," ");s=G(n),i!==s&&a.setAttribute("class",s)}return this},toggleClass:function(e,t){var a=typeof e;return"boolean"==typeof t&&"string"===a?t?this.addClass(e):this.removeClass(e):ge.isFunction(e)?this.each(function(a){ge(this).toggleClass(e.call(this,a,U(this),t),t)}):this.each(function(){var t,n,i,o;if("string"===a)for(n=0,i=ge(this),o=e.match(Ee)||[];t=o[n++];)i.hasClass(t)?i.removeClass(t):i.addClass(t);else void 0!==e&&"boolean"!==a||(t=U(this),t&&We.set(this,"__className__",t),this.setAttribute&&this.setAttribute("class",t||!1===e?"":We.get(this,"__className__")||""))})},hasClass:function(e){var t,a,n=0;for(t=" "+e+" ";a=this[n++];)if(1===a.nodeType&&(" "+G(U(a))+" ").indexOf(t)>-1)return!0;return!1}});var Tt=/\r/g;ge.fn.extend({val:function(e){var t,a,n,i=this[0];return arguments.length?(n=ge.isFunction(e),this.each(function(a){var i;1===this.nodeType&&(i=n?e.call(this,a,ge(this).val()):e,null==i?i="":"number"==typeof i?i+="":Array.isArray(i)&&(i=ge.map(i,function(e){return null==e?"":e+""})),(t=ge.valHooks[this.type]||ge.valHooks[this.nodeName.toLowerCase()])&&"set"in t&&void 0!==t.set(this,i,"value")||(this.value=i))})):i?(t=ge.valHooks[i.type]||ge.valHooks[i.nodeName.toLowerCase()],t&&"get"in t&&void 0!==(a=t.get(i,"value"))?a:(a=i.value,"string"==typeof a?a.replace(Tt,""):null==a?"":a)):void 0}}),ge.extend({valHooks:{option:{get:function(e){var t=ge.find.attr(e,"value");return null!=t?t:G(ge.text(e))}},select:{get:function(e){var t,a,n,o=e.options,r=e.selectedIndex,s="select-one"===e.type,l=s?null:[],c=s?r+1:o.length;for(n=r<0?c:s?r:0;n<c;n++)if(a=o[n],(a.selected||n===r)&&!a.disabled&&(!a.parentNode.disabled||!i(a.parentNode,"optgroup"))){if(t=ge(a).val(),s)return t;l.push(t)}return l},set:function(e,t){for(var a,n,i=e.options,o=ge.makeArray(t),r=i.length;r--;)n=i[r],(n.selected=ge.inArray(ge.valHooks.option.get(n),o)>-1)&&(a=!0);return a||(e.selectedIndex=-1),o}}}}),ge.each(["radio","checkbox"],function(){ge.valHooks[this]={set:function(e,t){if(Array.isArray(t))return e.checked=ge.inArray(ge(e).val(),t)>-1}},pe.checkOn||(ge.valHooks[this].get=function(e){return null===e.getAttribute("value")?"on":e.value})});var kt=/^(?:focusinfocus|focusoutblur)$/;ge.extend(ge.event,{trigger:function(t,a,n,i){var o,r,s,l,c,u,h,d=[n||ae],p=ue.call(t,"type")?t.type:t,f=ue.call(t,"namespace")?t.namespace.split("."):[];if(r=s=n=n||ae,3!==n.nodeType&&8!==n.nodeType&&!kt.test(p+ge.event.triggered)&&(p.indexOf(".")>-1&&(f=p.split("."),p=f.shift(),f.sort()),c=p.indexOf(":")<0&&"on"+p,t=t[ge.expando]?t:new ge.Event(p,"object"==typeof t&&t),t.isTrigger=i?2:3,t.namespace=f.join("."),t.rnamespace=t.namespace?new RegExp("(^|\\.)"+f.join("\\.(?:.*\\.|)")+"(\\.|$)"):null,t.result=void 0,t.target||(t.target=n),a=null==a?[t]:ge.makeArray(a,[t]),h=ge.event.special[p]||{},i||!h.trigger||!1!==h.trigger.apply(n,a))){if(!i&&!h.noBubble&&!ge.isWindow(n)){for(l=h.delegateType||p,kt.test(l+p)||(r=r.parentNode);r;r=r.parentNode)d.push(r),s=r;s===(n.ownerDocument||ae)&&d.push(s.defaultView||s.parentWindow||e)}for(o=0;(r=d[o++])&&!t.isPropagationStopped();)t.type=o>1?l:h.bindType||p,u=(We.get(r,"events")||{})[t.type]&&We.get(r,"handle"),u&&u.apply(r,a),(u=c&&r[c])&&u.apply&&Me(r)&&(t.result=u.apply(r,a),!1===t.result&&t.preventDefault());return t.type=p,i||t.isDefaultPrevented()||h._default&&!1!==h._default.apply(d.pop(),a)||!Me(n)||c&&ge.isFunction(n[p])&&!ge.isWindow(n)&&(s=n[c],s&&(n[c]=null),ge.event.triggered=p,n[p](),ge.event.triggered=void 0,s&&(n[c]=s)),t.result}},simulate:function(e,t,a){var n=ge.extend(new ge.Event,a,{type:e,isSimulated:!0});ge.event.trigger(n,null,t)}}),ge.fn.extend({trigger:function(e,t){return this.each(function(){ge.event.trigger(e,t,this)})},triggerHandler:function(e,t){var a=this[0];if(a)return ge.event.trigger(e,t,a,!0)}}),ge.each("blur focus focusin focusout resize scroll click dblclick mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave change select submit keydown keypress keyup contextmenu".split(" "),function(e,t){ge.fn[t]=function(e,a){return arguments.length>0?this.on(t,null,e,a):this.trigger(t)}}),ge.fn.extend({hover:function(e,t){return this.mouseenter(e).mouseleave(t||e)}}),pe.focusin="onfocusin"in e,pe.focusin||ge.each({focus:"focusin",blur:"focusout"},function(e,t){var a=function(e){ge.event.simulate(t,e.target,ge.event.fix(e))};ge.event.special[t]={setup:function(){var n=this.ownerDocument||this,i=We.access(n,t);i||n.addEventListener(e,a,!0),We.access(n,t,(i||0)+1)},teardown:function(){var n=this.ownerDocument||this,i=We.access(n,t)-1;i?We.access(n,t,i):(n.removeEventListener(e,a,!0),We.remove(n,t))}}});var St=e.location,It=ge.now(),Ct=/\?/;ge.parseXML=function(t){var a;if(!t||"string"!=typeof t)return null;try{a=(new e.DOMParser).parseFromString(t,"text/xml")}catch(e){a=void 0}return a&&!a.getElementsByTagName("parsererror").length||ge.error("Invalid XML: "+t),a};var Ft=/\[\]$/,At=/\r?\n/g,Nt=/^(?:submit|button|image|reset|file)$/i,Et=/^(?:input|select|textarea|keygen)/i;ge.param=function(e,t){var a,n=[],i=function(e,t){var a=ge.isFunction(t)?t():t;n[n.length]=encodeURIComponent(e)+"="+encodeURIComponent(null==a?"":a)};if(Array.isArray(e)||e.jquery&&!ge.isPlainObject(e))ge.each(e,function(){i(this.name,this.value)});else for(a in e)Y(a,e[a],t,i);return n.join("&")},ge.fn.extend({serialize:function(){return ge.param(this.serializeArray())},serializeArray:function(){return this.map(function(){var e=ge.prop(this,"elements");return e?ge.makeArray(e):this}).filter(function(){var e=this.type;return this.name&&!ge(this).is(":disabled")&&Et.test(this.nodeName)&&!Nt.test(e)&&(this.checked||!Je.test(e))}).map(function(e,t){var a=ge(this).val();return null==a?null:Array.isArray(a)?ge.map(a,function(e){return{name:t.name,value:e.replace(At,"\r\n")}}):{name:t.name,value:a.replace(At,"\r\n")}}).get()}});var _t=/%20/g,Ot=/#.*$/,Lt=/([?&])_=[^&]*/,Mt=/^(.*?):[ \t]*([^\r\n]*)$/gm,Wt=/^(?:about|app|app-storage|.+-extension|file|res|widget):$/,qt=/^(?:GET|HEAD)$/,Pt=/^\/\//,Bt={},Dt={},jt="*/".concat("*"),Rt=ae.createElement("a");Rt.href=St.href,ge.extend({active:0,lastModified:{},etag:{},ajaxSettings:{url:St.href,type:"GET",isLocal:Wt.test(St.protocol),global:!0,processData:!0,async:!0,contentType:"application/x-www-form-urlencoded; charset=UTF-8",accepts:{"*":jt,text:"text/plain",html:"text/html",xml:"application/xml, text/xml",json:"application/json, text/javascript"},contents:{xml:/\bxml\b/,html:/\bhtml/,json:/\bjson\b/},responseFields:{xml:"responseXML",text:"responseText",json:"responseJSON"},converters:{"* text":String,"text html":!0,"text json":JSON.parse,"text xml":ge.parseXML},flatOptions:{url:!0,context:!0}},ajaxSetup:function(e,t){return t?K(K(e,ge.ajaxSettings),t):K(ge.ajaxSettings,e)},ajaxPrefilter:Q(Bt),ajaxTransport:Q(Dt),ajax:function(t,a){function n(t,a,n,s){var c,d,p,b,x,T=a;u||(u=!0,l&&e.clearTimeout(l),i=void 0,r=s||"",k.readyState=t>0?4:0,c=t>=200&&t<300||304===t,n&&(b=Z(f,k,n)),b=ee(f,b,k,c),c?(f.ifModified&&(x=k.getResponseHeader("Last-Modified"),x&&(ge.lastModified[o]=x),(x=k.getResponseHeader("etag"))&&(ge.etag[o]=x)),204===t||"HEAD"===f.type?T="nocontent":304===t?T="notmodified":(T=b.state,d=b.data,p=b.error,c=!p)):(p=T,!t&&T||(T="error",t<0&&(t=0))),k.status=t,k.statusText=(a||T)+"",c?y.resolveWith(g,[d,T,k]):y.rejectWith(g,[k,T,p]),k.statusCode(v),v=void 0,h&&m.trigger(c?"ajaxSuccess":"ajaxError",[k,f,c?d:p]),w.fireWith(g,[k,T]),h&&(m.trigger("ajaxComplete",[k,f]),--ge.active||ge.event.trigger("ajaxStop")))}"object"==typeof t&&(a=t,t=void 0),a=a||{};var i,o,r,s,l,c,u,h,d,p,f=ge.ajaxSetup({},a),g=f.context||f,m=f.context&&(g.nodeType||g.jquery)?ge(g):ge.event,y=ge.Deferred(),w=ge.Callbacks("once memory"),v=f.statusCode||{},b={},x={},T="canceled",k={readyState:0,getResponseHeader:function(e){var t;if(u){if(!s)for(s={};t=Mt.exec(r);)s[t[1].toLowerCase()]=t[2];t=s[e.toLowerCase()]}return null==t?null:t},getAllResponseHeaders:function(){return u?r:null},setRequestHeader:function(e,t){return null==u&&(e=x[e.toLowerCase()]=x[e.toLowerCase()]||e,b[e]=t),this},overrideMimeType:function(e){return null==u&&(f.mimeType=e),this},statusCode:function(e){var t;if(e)if(u)k.always(e[k.status]);else for(t in e)v[t]=[v[t],e[t]];return this},abort:function(e){var t=e||T;return i&&i.abort(t),n(0,t),this}};if(y.promise(k),f.url=((t||f.url||St.href)+"").replace(Pt,St.protocol+"//"),f.type=a.method||a.type||f.method||f.type,f.dataTypes=(f.dataType||"*").toLowerCase().match(Ee)||[""],null==f.crossDomain){c=ae.createElement("a");try{c.href=f.url,c.href=c.href,f.crossDomain=Rt.protocol+"//"+Rt.host!=c.protocol+"//"+c.host}catch(e){f.crossDomain=!0}}if(f.data&&f.processData&&"string"!=typeof f.data&&(f.data=ge.param(f.data,f.traditional)),X(Bt,f,a,k),u)return k;h=ge.event&&f.global,h&&0==ge.active++&&ge.event.trigger("ajaxStart"),f.type=f.type.toUpperCase(),f.hasContent=!qt.test(f.type),o=f.url.replace(Ot,""),f.hasContent?f.data&&f.processData&&0===(f.contentType||"").indexOf("application/x-www-form-urlencoded")&&(f.data=f.data.replace(_t,"+")):(p=f.url.slice(o.length),f.data&&(o+=(Ct.test(o)?"&":"?")+f.data,delete f.data),!1===f.cache&&(o=o.replace(Lt,"$1"),p=(Ct.test(o)?"&":"?")+"_="+It+++p),f.url=o+p),f.ifModified&&(ge.lastModified[o]&&k.setRequestHeader("If-Modified-Since",ge.lastModified[o]),ge.etag[o]&&k.setRequestHeader("If-None-Match",ge.etag[o])),(f.data&&f.hasContent&&!1!==f.contentType||a.contentType)&&k.setRequestHeader("Content-Type",f.contentType),k.setRequestHeader("Accept",f.dataTypes[0]&&f.accepts[f.dataTypes[0]]?f.accepts[f.dataTypes[0]]+("*"!==f.dataTypes[0]?", "+jt+"; q=0.01":""):f.accepts["*"]);for(d in f.headers)k.setRequestHeader(d,f.headers[d]);if(f.beforeSend&&(!1===f.beforeSend.call(g,k,f)||u))return k.abort();if(T="abort",w.add(f.complete),k.done(f.success),k.fail(f.error),i=X(Dt,f,a,k)){if(k.readyState=1,h&&m.trigger("ajaxSend",[k,f]),u)return k;f.async&&f.timeout>0&&(l=e.setTimeout(function(){k.abort("timeout")},f.timeout));try{u=!1,i.send(b,n)}catch(e){if(u)throw e;n(-1,e)}}else n(-1,"No Transport");return k},getJSON:function(e,t,a){return ge.get(e,t,a,"json")},getScript:function(e,t){return ge.get(e,void 0,t,"script")}}),ge.each(["get","post"],function(e,t){ge[t]=function(e,a,n,i){return ge.isFunction(a)&&(i=i||n,n=a,a=void 0),ge.ajax(ge.extend({url:e,type:t,dataType:i,data:a,success:n},ge.isPlainObject(e)&&e))}}),ge._evalUrl=function(e){return ge.ajax({url:e,type:"GET",dataType:"script",cache:!0,async:!1,global:!1,"throws":!0})},ge.fn.extend({wrapAll:function(e){var t;return this[0]&&(ge.isFunction(e)&&(e=e.call(this[0])),t=ge(e,this[0].ownerDocument).eq(0).clone(!0),this[0].parentNode&&t.insertBefore(this[0]),t.map(function(){for(var e=this;e.firstElementChild;)e=e.firstElementChild;return e}).append(this)),this},wrapInner:function(e){return ge.isFunction(e)?this.each(function(t){ge(this).wrapInner(e.call(this,t))}):this.each(function(){var t=ge(this),a=t.contents();a.length?a.wrapAll(e):t.append(e)})},wrap:function(e){var t=ge.isFunction(e);return this.each(function(a){ge(this).wrapAll(t?e.call(this,a):e)})},unwrap:function(e){return this.parent(e).not("body").each(function(){ge(this).replaceWith(this.childNodes)}),this}}),ge.expr.pseudos.hidden=function(e){return!ge.expr.pseudos.visible(e)},ge.expr.pseudos.visible=function(e){return!!(e.offsetWidth||e.offsetHeight||e.getClientRects().length)},ge.ajaxSettings.xhr=function(){try{return new e.XMLHttpRequest}catch(e){}};var Ht={0:200,1223:204},zt=ge.ajaxSettings.xhr();pe.cors=!!zt&&"withCredentials"in zt,pe.ajax=zt=!!zt,ge.ajaxTransport(function(t){var a,n;if(pe.cors||zt&&!t.crossDomain)return{send:function(i,o){var r,s=t.xhr();if(s.open(t.type,t.url,t.async,t.username,t.password),t.xhrFields)for(r in t.xhrFields)s[r]=t.xhrFields[r];t.mimeType&&s.overrideMimeType&&s.overrideMimeType(t.mimeType),t.crossDomain||i["X-Requested-With"]||(i["X-Requested-With"]="XMLHttpRequest");for(r in i)s.setRequestHeader(r,i[r]);a=function(e){return function(){a&&(a=n=s.onload=s.onerror=s.onabort=s.onreadystatechange=null,"abort"===e?s.abort():"error"===e?"number"!=typeof s.status?o(0,"error"):o(s.status,s.statusText):o(Ht[s.status]||s.status,s.statusText,"text"!==(s.responseType||"text")||"string"!=typeof s.responseText?{binary:s.response}:{text:s.responseText},s.getAllResponseHeaders()))}},s.onload=a(),n=s.onerror=a("error"),void 0!==s.onabort?s.onabort=n:s.onreadystatechange=function(){4===s.readyState&&e.setTimeout(function(){a&&n()})},a=a("abort");try{s.send(t.hasContent&&t.data||null)}catch(e){if(a)throw e}},abort:function(){a&&a()}}}),ge.ajaxPrefilter(function(e){e.crossDomain&&(e.contents.script=!1)}),ge.ajaxSetup({accepts:{script:"text/javascript, application/javascript, application/ecmascript, application/x-ecmascript"},contents:{script:/\b(?:java|ecma)script\b/},converters:{"text script":function(e){return ge.globalEval(e),e}}}),ge.ajaxPrefilter("script",function(e){void 0===e.cache&&(e.cache=!1),e.crossDomain&&(e.type="GET")}),ge.ajaxTransport("script",function(e){if(e.crossDomain){var t,a;return{send:function(n,i){t=ge("<script>").prop({charset:e.scriptCharset,src:e.url}).on("load error",a=function(e){t.remove(),a=null,e&&i("error"===e.type?404:200,e.type)}),ae.head.appendChild(t[0])},abort:function(){a&&a()}}}});var $t=[],Jt=/(=)\?(?=&|$)|\?\?/;ge.ajaxSetup({jsonp:"callback",jsonpCallback:function(){var e=$t.pop()||ge.expando+"_"+It++;return this[e]=!0,e}}),ge.ajaxPrefilter("json jsonp",function(t,a,n){var i,o,r,s=!1!==t.jsonp&&(Jt.test(t.url)?"url":"string"==typeof t.data&&0===(t.contentType||"").indexOf("application/x-www-form-urlencoded")&&Jt.test(t.data)&&"data");if(s||"jsonp"===t.dataTypes[0])return i=t.jsonpCallback=ge.isFunction(t.jsonpCallback)?t.jsonpCallback():t.jsonpCallback,s?t[s]=t[s].replace(Jt,"$1"+i):!1!==t.jsonp&&(t.url+=(Ct.test(t.url)?"&":"?")+t.jsonp+"="+i),t.converters["script json"]=function(){return r||ge.error(i+" was not called"),r[0]},t.dataTypes[0]="json",o=e[i],e[i]=function(){r=arguments},n.always(function(){void 0===o?ge(e).removeProp(i):e[i]=o,t[i]&&(t.jsonpCallback=a.jsonpCallback,$t.push(i)),r&&ge.isFunction(o)&&o(r[0]),r=o=void 0}),"script"}),pe.createHTMLDocument=function(){var e=ae.implementation.createHTMLDocument("").body;return e.innerHTML="<form></form><form></form>",2===e.childNodes.length}(),ge.parseHTML=function(e,t,a){if("string"!=typeof e)return[];"boolean"==typeof t&&(a=t,t=!1);var n,i,o;return t||(pe.createHTMLDocument?(t=ae.implementation.createHTMLDocument(""),n=t.createElement("base"),n.href=ae.location.href,t.head.appendChild(n)):t=ae),i=Se.exec(e),o=!a&&[],i?[t.createElement(i[1])]:(i=b([e],t,o),o&&o.length&&ge(o).remove(),ge.merge([],i.childNodes))},ge.fn.load=function(e,t,a){var n,i,o,r=this,s=e.indexOf(" ");return s>-1&&(n=G(e.slice(s)),e=e.slice(0,s)),ge.isFunction(t)?(a=t,t=void 0):t&&"object"==typeof t&&(i="POST"),r.length>0&&ge.ajax({url:e,type:i||"GET",dataType:"html",data:t}).done(function(e){o=arguments,r.html(n?ge("<div>").append(ge.parseHTML(e)).find(n):e)}).always(a&&function(e,t){r.each(function(){a.apply(this,o||[e.responseText,t,e])})}),this},ge.each(["ajaxStart","ajaxStop","ajaxComplete","ajaxError","ajaxSuccess","ajaxSend"],function(e,t){ge.fn[t]=function(e){return this.on(t,e)}}),ge.expr.pseudos.animated=function(e){return ge.grep(ge.timers,function(t){return e===t.elem}).length},ge.offset={setOffset:function(e,t,a){var n,i,o,r,s,l,c,u=ge.css(e,"position"),h=ge(e),d={};"static"===u&&(e.style.position="relative"),s=h.offset(),o=ge.css(e,"top"),l=ge.css(e,"left"),c=("absolute"===u||"fixed"===u)&&(o+l).indexOf("auto")>-1,c?(n=h.position(),r=n.top,i=n.left):(r=parseFloat(o)||0,i=parseFloat(l)||0),ge.isFunction(t)&&(t=t.call(e,a,ge.extend({},s))),null!=t.top&&(d.top=t.top-s.top+r),null!=t.left&&(d.left=t.left-s.left+i),"using"in t?t.using.call(e,d):h.css(d)}},ge.fn.extend({offset:function(e){if(arguments.length)return void 0===e?this:this.each(function(t){ge.offset.setOffset(this,e,t)});var t,a,n,i,o=this[0];return o?o.getClientRects().length?(n=o.getBoundingClientRect(),t=o.ownerDocument,a=t.documentElement,i=t.defaultView,{top:n.top+i.pageYOffset-a.clientTop,left:n.left+i.pageXOffset-a.clientLeft}):{top:0,left:0}:void 0},position:function(){if(this[0]){var e,t,a=this[0],n={top:0,left:0};return"fixed"===ge.css(a,"position")?t=a.getBoundingClientRect():(e=this.offsetParent(),t=this.offset(),i(e[0],"html")||(n=e.offset()),n={top:n.top+ge.css(e[0],"borderTopWidth",!0),left:n.left+ge.css(e[0],"borderLeftWidth",!0)}),{top:t.top-n.top-ge.css(a,"marginTop",!0),left:t.left-n.left-ge.css(a,"marginLeft",!0)}}},offsetParent:function(){return this.map(function(){for(var e=this.offsetParent;e&&"static"===ge.css(e,"position");)e=e.offsetParent;return e||Qe})}}),ge.each({scrollLeft:"pageXOffset",scrollTop:"pageYOffset"},function(e,t){var a="pageYOffset"===t;ge.fn[e]=function(n){return Le(this,function(e,n,i){var o;return ge.isWindow(e)?o=e:9===e.nodeType&&(o=e.defaultView),void 0===i?o?o[t]:e[n]:void(o?o.scrollTo(a?o.pageXOffset:i,a?i:o.pageYOffset):e[n]=i)},e,n,arguments.length)}}),ge.each(["top","left"],function(e,t){ge.cssHooks[t]=L(pe.pixelPosition,function(e,a){if(a)return a=O(e,t),rt.test(a)?ge(e).position()[t]+"px":a})}),ge.each({Height:"height",Width:"width"},function(e,t){ge.each({padding:"inner"+e,content:t,"":"outer"+e},function(a,n){ge.fn[n]=function(i,o){var r=arguments.length&&(a||"boolean"!=typeof i),s=a||(!0===i||!0===o?"margin":"border");return Le(this,function(t,a,i){var o;return ge.isWindow(t)?0===n.indexOf("outer")?t["inner"+e]:t.document.documentElement["client"+e]:9===t.nodeType?(o=t.documentElement,Math.max(t.body["scroll"+e],o["scroll"+e],t.body["offset"+e],o["offset"+e],o["client"+e])):void 0===i?ge.css(t,a,s):ge.style(t,a,i,s)},t,r?i:void 0,r)}})}),ge.fn.extend({bind:function(e,t,a){return this.on(e,null,t,a)},unbind:function(e,t){return this.off(e,null,t)},delegate:function(e,t,a,n){return this.on(t,e,a,n)},undelegate:function(e,t,a){return 1===arguments.length?this.off(e,"**"):this.off(t,e||"**",a)}}),ge.holdReady=function(e){e?ge.readyWait++:ge.ready(!0)},ge.isArray=Array.isArray,ge.parseJSON=JSON.parse,ge.nodeName=i,"function"==typeof define&&define.amd&&define("jquery",[],function(){return ge});var Vt=e.jQuery,Gt=e.$;return ge.noConflict=function(t){return e.$===ge&&(e.$=Gt),t&&e.jQuery===ge&&(e.jQuery=Vt),ge},t||(e.jQuery=e.$=ge),ge});var tipuesearch={pages:[{title:"Edinburgh Food Shopping",text:"A Google Map listing the locations of ~150 shops in Edinburgh for buying food.",tags:"Map",url:"/Edinburgh-Food-Shopping"},{title:"Test Post",text:"Not much here. A few lines of text. Heading level 3 Bold fun test(): Int { return 0 }",tags:"Notes Haskell Functional",url:"/Test-Post"},{title:"Haskell Notes",
text:'This is a collection of notes on Haskell, primarily condensed from learnyouahaskell Purely functional languages In a purely functional language, functions can have no side effects. This means that if a function is called twice with the same parameters, it is guaranteed to return the same result. This is called referential transparency and allows the compiler to reason about program behaviour, as well as proof that a function is correct. Lazy evaluation Functions will not be called and calculations will not be performed until a result is required. Programs can be thought of as a series of transformations on data. This allows structures such as infinite lists, which are only evaluated when required. Example: An infinite list of natural numbers can be generated as follows &gt; let naturals = 1 : map (+1) naturals When we want to use these values we can write &gt; take 10 naturals &gt; [1,2,3,4,5,6,7,8,9,10] We could more succinctly use the notation for a range &gt; let naturals = [1..] This gives the same infinite range as before. Static typing Haskell is a statically typed language, meaning that when it is compiled the compiler knows the type of every value. Type inference Haskell, along with many other languages, use a system of type inference. This means that when writing a = 2 + 3 it is not necessary to inform the compiler that a is a numeric value. If a function takes two parameters and adds them together, their types do not need to be stated explicitly. The function will can be executed with any two parameters that act like numbers. Basic syntax Examples: Arithmetic &gt; 3 + 16 &gt; 19 &gt; 27 * 53 &gt; 1431 &gt; 1314 - 133 &gt; 1181 &gt; 7 / 2 &gt; 3.5 When multiple operators are used on the same line, operator precedence and parentheses are respected. Negation When value are negated, they must be surrounded by parentheses. &gt; 5 * -3 The expression above will give a Precedence parsing error. Instead 5 * (-3) should be written Examples: Boolean algebra Operator Symbol And &amp;&amp; Or || Not not Equality == Inequality /= &gt; True &amp;&amp; False &gt; False &gt; True &amp;&amp; not False &gt; True &gt; False || True &gt; True &gt; not (True &amp;&amp; True) &gt; False &gt; True == False &gt; False &gt; 5 == 5 &gt; True &gt; 1 == 0 &gt; False &gt; 5 /= 5 &gt; False &gt; 5 /= 4 &gt; "string" == "string" &gt; True Functions All of the operations performed so far have been functions, specifically infix functions. Functions are usually prefix functions, which take their arguments after the function name. Infix functions are different in that the arguments surround the function name. Example: The successor function &gt; succ 9 &gt; 10 The successor function takes anything which has a defined successor, and returns that successor. The min and max functions both take two parameters &gt; min 10 11 &gt; 10 &gt; max 100 1000 &gt; 1000 &gt; min 1.5 1.4 &gt; 1.4 Function application as seen above has the highest precedence This means that the following statements are equivalent &gt; succ 9 + max 5 4 + 1 &gt; (succ 9) + (max 5 4) + 1 Suppose we want the successor to the product of two numbers, a, and b. As succ has the highest precedence writing succ a * b would first evaluate succ a and then evaluate its product with b. Instead we must right succ (a * b). Writing functions as infix If a function takes two parameters, it can be called as an infix function by surrounding it with backticks. div takes two integers and performs integral division. &gt; 92 `div` 9 &gt; 10 Function call syntax Many other languages require parentheses to denote function application. In Haskell, spaces are used instead. Function definition doubleValue x = x + x The function above consists of a function name, followed by parameters separated by spaces. After the = the function body is defined. This function will work on any numeric type. &gt; doubleValue 2 &gt; 4 &gt; doubleValue 2.5 &gt; 5 doubleSum x y = x * 2 + y * 2 This function takes two numeric parameters, doubles each of them, and returns the sum of the two doubled values. &gt; doubleSum 2 3 &gt; 10 &gt; doubleSum 5.5 7 &gt; 25.0 The function can take two numeric types, one of which is floating point and the other an integer. This will result in the integer type being converted to a floating point value. The function could also be defined in terms of the first function, doubleValue. doubleSum x y = doubleValue x + doubleValue y Function definitions do not have to be in any particular order, doubleSum could be defined before doubleValue. Conditional expressions doubleSmallNumber x = if x &gt; 100 then x else x * 2 The function doubleSmallNumber doubles the parameter x if x&lt;=100, otherwise it returns the original value of x. An if statement in Haskell is an expression, a piece of code which returns a value. Because the else is mandatory, an if statement will always return some value. If we wanted to add one to the return value in doubleSmallNumber we could write doubleSmallNumber\' x = (if x &gt; 100 then x else x * 2) + 1 Function naming The function above doubleSmallNumber\' has a \' character as its last character. This is a valid character in Haskell function names and is often used to denote a stricter, non-lazy version of a function, or a slightly modified version. Haskell functions cannot begin with uppercase characters. When a function does not take any parameters, it is called a definition or a name. Lists Lists are defined as comma separated lists of values within a set of square brackets []. A string is just syntax for a list of characters. As strings are backed by lists of characters, we can apply list functions to them. String and list concatenation Strings are concatenated with the ++ operator. &gt; "hello" ++ " " ++ "world" &gt; "hello world" This operator is used more widely for list concatenation. &gt; [1,2,3] ++ [4,5,6] &gt; [1,2,3,4,5,6] When two lists are added together, even when a singleton is added to the end of a list, Haskell has to walk through the whole list on the left side of the ++ operator which can be slow when dealing with large lists. Prepending to a list is effectively instantaneous. It is done with the : operator. &gt; \'A\' : "BC" &gt; "ABC" &gt; 5 : [4,3,2,1] &gt; [5,4,3,2,1] Note that ++ takes two lists. This means that any singleton value being appended to a list must be a list containing one item, such as [5], rather than just 5. A list definition such as [1,2,3] is actually just syntactic sugar for 1:2:3:[], where [] is an empty list. List indexing As with any sensible language, Haskell lists are indexed from 0. The !! operator is used to read an element from a list at a given index. &gt; [1,2,3,4,5] !! 2 &gt; 3 &gt; "hello" !! 1 &gt; \'e\' Attempting to access an index which does not exist will raise an error. Nested lists Lists can be infinitely nested within memory constraints. &gt; let b = [[1,2,3,4],[5,3,3,3],[1,2,2,3,4],[1,2,3]] &gt; b &gt; [[1,2,3,4],[5,3,3,3],[1,2,2,3,4],[1,2,3]] &gt; b ++ [[1,1,1,1]] &gt; [[1,2,3,4],[5,3,3,3],[1,2,2,3,4],[1,2,3],[1,1,1,1]] &gt; [6,6,6]:b &gt; [[6,6,6],[1,2,3,4],[5,3,3,3],[1,2,2,3,4],[1,2,3]] &gt; b !! 2 &gt; [1,2,2,3,4] The nested lists can be of different dimensions, but they must be of the same type. List comparisons Lists can be compared if there is a method for comparing their contents. When using &lt;, &lt;=, &gt;, &gt;= to compare lists, their elements are compared in lexicographical order. First the head elements are compared, if they are equal the next elements are compared and so forth, until two elements are not equal, or one of the lists ends. &gt; [3,4,2] == [3,4,2] &gt; True &gt; [3,2,1] &gt; [2,10,100] &gt; True &gt; [3,4,2] &gt; [3,4] &gt; True List operations head takes a list as a parameter and returns its head, the first element &gt; head [10,9,8] &gt; 10 tail takes a list as a parameter and returns its tail, the elements past the first &gt; tail [10,9,8] &gt; [9,8] last takes a list as a parameter and returns its last element &gt; last [10,9,8] &gt; 8 init takes a list as a parameter and returns the elements before the last &gt; init [10,9,8] &gt; [10,9] The functions above will raise an exception if applied to an empty list. length takes a list as a parameter and returns its length, the number of elements &gt; length [1,2,3,4,5] &gt; 5 null takes a list as a parameter and returns True if the list is empty, and False otherwise &gt; null [] &gt; True &gt; null [1,2,3] &gt; False reverse takes a list as a parameter returns the reversed list &gt; reverse [5,4,3,2,1] &gt; [1,2,3,4,5] take takes an integer and a list as parameters and extracts that many elements from the list, returning them If we try to take more elements than there are in the list, it just returns the list without raising an exception. &gt; take 3 [5,4,3,2,1] &gt; [5,4,3] &gt; take 1 [3,9,3] &gt; [3] &gt; take 5 [1,2] &gt; [1,2] &gt; take 0 [6,5,4] &gt; [] drop takes an integer and list as parameters, and drops that many elements from the start of the list &gt; drop 3 [8,4,2,1,5,6] &gt; [1,5,6] &gt; drop 0 [4,3,2,1] &gt; [4,3,2,1] &gt; drop 100 [1,2,3,4] &gt; [] maximum takes an orderable list as a parameter and returns the largest element minimum takes an orderable list as a parameter and returns the smallest element &gt; minimum [8,4,2,1,5,6] &gt; 1 &gt; maximum [1,9,2,3,4] &gt; 9 sum takes a list of numbers as a parameter and returns their sum &gt; sum [1,2,3,4,5] &gt; 15 product takes a list of numbers as a parameter and returns their product &gt; product [1,2,3,4] &gt; 24 elem takes an instance of type T and a list of type T as parameters and returns true if the instance is contained within the list elem is usually called as an infix function because it is easier to read. &gt; 4 `elem` [3,4,5,6] &gt; True &gt; 10 `elem` [1,2,3] &gt; False Ranges Ranges are a method for making lists that are arithmetic sequences of elements that can be enumerated, such as numbers and characters. &gt; [1..20] &gt; [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20] &gt; [\'a\'..\'z\'] &gt; [\'a\',\'b\',\'c\',\'d\',\'e\',\'g\',\'h\',\'j\',\'k\',\'l\',\'m\',\'n\',\'o\',\'p\',\'q\',\'r\',\'s\',\'t\',\'u\',\'v\',\'w\',\'x\',\'y\',\'z\'] The step for a range can also be specified. &gt; [2,4..20] &gt; [2,4,6,8,10,12,14,16,18,20] To make a list of numbers in descending order from m to n you have to write &gt; [m,m-1..n] Production of infinite lists Infinite lists can be produced by neglecting to specify an upper bound for a range. cycle takes a list as a parameter and cycles it into an infinite list. &gt; take 10 (cycle [3,2,1]) &gt; [3,2,1,3,2,1,3,2,1,3] repeat takes an element as a parameter and produces an infinite list of just that element &gt; take 10 (repeat 6) &gt; [6,6,6,6,6,6,6,6,6,6] If you want some number of the same element in a list it is simpler to use replicate replicate takes a number and an element a returns a list containing that many of the element &gt; replicate 5 6 &gt; [5,5,5,5,5,5] List comprehension Set comprehensions are often used for building specific sets from general sets. The part before the pipe is called the output function, is the variable, is the input set and is the the predicate. The set contains the doubles of all the values that satisfy the predicate. In Haskell we could write take 10 [2,4,..] but this would produce doubles of the first 10 natural numbers. A list comprehension should be used instead. &gt; [x*2 | x &lt;- [1..10]] &gt; [2,4,6,8,10,12,14,16,18,20] We can also add a predicate to the comprehension &gt; [x*2 | x &lt;- [1..10], x*2 &gt;= 12] &gt; [12,14,16,18,20] Suppose we want to all the numbers from 50 to 100 whose remainder when divided by the number 7 is 3. &gt; [x | x &lt;- [50,100], x `mod` 7 ==3] &gt; [52,59,66,73,80,87,94] This process is called filtering. We took a list and filtered it by the predicate. Now suppose we want to replace each odd number greater than 10 the string "BANG!" and each odd number less than 10 with "BOOM!". If a number isn\u2019t odd, we throw it out of our list. For convenience we can place out comprehension inside a function so that we can reuse it. &gt; let boomBang xs = [if x &lt; 10 then "BOOM!" else "BANG!" | x &lt;- xs, odd x] &gt; boomBang [7..13] &gt; ["BOOM!", "BOOM!", "BANG!", "BANG!"] We can include several predicates. A comprehension for numbers from 10 to 20 that are not 13, 15, or 19 can be written as. &gt; [x | x &lt;- [10..20], x /= 13, x /= 15, x /= 19] &gt; [10,11,12,14,16,17,18,20] Not only can we have multiple predicates in list comprehensions, we can also draw from multiple lists. A list produced by a comprehension that draws from two lists of lengths n and m respectively will have a length of n*m. If we have two lists, [2,5,10] and [8,10,11] and we wish to find the products of all the possible combinations between numbers in those lists, we can write &gt; [x*y | x &lt;- [2,5,10], y &lt;- [8,10,10]] &gt; [16,20,22,40,50,55,80,100,110] Now suppose that we want all possible products which are greater than 50 &gt; [x*y | x &lt;- [2,5,10], y &lt;- [8,10,10], x * y &gt; 50] &gt; [55,80,100,110] &gt; let nouns = ["hobo","frog","pope"] &gt; let adjectives = ["lazy","grouchy","scheming"] &gt; [adjective ++ " " ++ noun | adjective &lt;- adjectives, noun &lt;- nouns] &gt; ["lazy hobo","lazy frog","lazy pope","grouchy hobo","grouchy frog", "grouchy pope","scheming hobo","scheming frog","scheming pope"] We could use list comprehension to write a bad version of the length function. &gt; length` xs = sum [1 | _ &lt;- xs] This function replaces every element of the list with 1s and finds their sum. The underscore character, _, is used to denote a variable which is not used. Nested list comprehensions &gt; let xxs = [[1,3,5,2,3,1,2,4,5],[1,2,3,4,5,6,7,8,9].[1,2,4,2,1,6,3,1,3,2,3,6]] &gt; [[x | x &lt;- xs, even x] | xs &lt;- xxs] &gt; [[2,2,4],[2,4,6,8], [2,4,2,6,2,6]] The comprehension shown above applies a comprehension to each of the lists, within the outer list, filtering them to only even values. Tuples Tuples are similar to lists, providing a way to store several values in a single value. Tuples are used when the number of values you want to combine is known, and its type depends on how many components it has along with the type of the components. They are denoted with parentheses around a comma separated list of values. Unlike lists, tuples do not have to be homogeneous, meaning that they can contain several types. &gt; --List of tuples of the same type &gt; [(1,2),(3,4),(5,6)] &gt; --List of tuples of varying types -&gt; Error &gt; [(1,2),(3,"4"),(\'5\',6)] Tuples can contain lists. Tuples are much more rigid. A general function cannot be written to append an element to a tuple. There is no singleton tuple. This is because a singleton tuple would just be the value it contains and therefore provide no use. Tuple operations fst takes a pair and returns its first component &gt; fst (8,11) &gt; 8 snd takes a pair and returns its second component These functions only work on pairs. They will not work on triples, 4-tuples, 5-tuples etc. zip takes two lists and produces a list of pairs &gt; zip [1,2,3,4,5] [5,4,3,2,1] &gt; [(1,5),(2,4),(3,3),(4,2),(5,1)] &gt; zip [1..5] ["five", "four", "three", "two", "one"] &gt; [(1, "five"), (2, "four"), (3, "three"), (4, "two"), (5, "one")] If the lengths of the lists do not match the longer list is cut off and ignored past the length of the shorter list. We can apply zip to pairings of finite and infinite lists, or two infinite lists &gt; take 10 (zip [1..] [1,0..]) &gt; [(1,1),(2,0),(3,-1),(4,-2),(5,-3),(6,-4),(7,-5),(8,-6),(9,-7),(10,-8)] Types and typeclasses The :t command can be used to determine the type of an expression. &gt; :t \'a\' &gt; \'a\' :: Char &gt; :t True &gt; True :: Bool &gt; :t (True, \'a\') &gt; (True, \'a\') :: (Bool, Char) &gt; :t 4 == 5 &gt; 4 == 5 :: Bool :: should be read as \u2018has type of\u2019. Explicit types are always denoted with the first letter in capital case. Functions also have types. When writing functions, we can give an explicit type declaration. removeNonUppercase :: [Char] -&gt; [Char] removeNonUppercase st = [ c | c &lt;- st, c `elem` [\'A\'..\'Z\']] removeNonUppercase has a type of [Char] -&gt; [Char] as it maps a string to a string. We don\u2019t have to give this function a type decleration because the compiler can infer it, however it is still good practice to do so. addThree :: Int -&gt; Int -&gt; Int -&gt; Int addThree x y z = x + y + z The function above takes three parameters. The return type is the last item in the declaration and the parameters are the first three. Common types Int A 32 or 64 bit signed integer Integer A non-bounded integer Float A real floating point value with single precision Double A real floating point value with double precision Bool A boolean type, True or False Char Represents a single character Type variables head takes a list of any type and returns the first element &gt; :t head &gt; head :: [a] -&gt; a a is a type variable, meaning that it can be of any type. The type decleration of head means that it takes a list of some type a and returns a single instance of type a. This is much like generics in other languages. Functions that have type variables are called polymorphic functions. &gt; :t fst &gt; fst :: (a, b) -&gt; a fst takes a tuple which conatins two types, and returns an element which is of the same type as the first item in the pair. Note that despite the differing names of a and b they can be the same type. Typeclasses A typeclass behaves similarly to an interface. If a type is part of a typeclass, it supports and implements the behaviour that the typeclass describes. &gt; :t (==) &gt; (==) :: (Eq a) =&gt; a -&gt; a -&gt; -&gt; Bool The =&gt; symbol is called a class constraint. The euqality function takes any two values that are of the same type and returns a Bool. The class constraint is that the type of those two values must be a member of the Eq class. The Eq typeclass provides an interface for testing for equality. Any type where it makes sense to test for equality between two values of that type should be a member of the Eq class. All standard Haskell types except for IO and functions are part of the Eq typeclass. Consider the elem function which has a type of (Eq a) =&gt; a -&gt; [a] -&gt; Bool because it uses == over a list to check whether some value is contained. Common Typeclasses Eq Used for types that support equality testing. Members must implement == and /= Ord Used for types which have ordering. Ord covers &gt;, &lt;, &gt;=, and &lt;= The compare function takes two Ord members of the same type and returns an ordering. Ordering is a type that can be GT, LT, or EQ. To be a member of Ord, a type must first be a member of Eq Show Used for types that can be presented as strings. The most used function that deals with Show is show/ It takes a value whose type is a member of Show and presents it as a string. Read The read function takes a string and returns a type which is a member of Read &gt; read "True" || False &gt; True &gt; read "8.2" + 3.8 &gt; 12.0 &gt; read "[1,2,3,4]" ++ [3] &gt; [1,2,3,4,3] If we try read "4" an exception will be raised. &lt;interactive&gt;:1:0: Ambiguous type variable `a\' in the constraint: `Read a\' arising from a use of `read\' at &lt;interactive&gt;:1:0-7 Probable fix: add a type signature that fixes these type variable(s) The return type cannot be determined. Previously our use of the return value could be used to determine its type. &gt; :t read &gt; read :: (Read a) =&gt; String -&gt; a read returns a type that is part of Read, but if we do not use the value the type cannot be determined. We can use explicit type annotations to overcome this problem. &gt; read "5" :: Int &gt; 5 &gt; read "5" :: Float &gt; 5.0 &gt; read "(3, \'a\')" :: (Int, Char) &gt; (3, \'a\') Most expressions provide sufficient detail that the compiler can infer what their type is by itself. Enum Enum members are sequentially ordered types. The Enum typeclass can be used in list ranges. They also have defined successors and predecessors. (), Bool, Char, Ordering, Int, Integer, Float, and Double are in this class. &gt; [\'a\'..\'e\'] &gt; "abcde" &gt; [LT..GT] &gt; [LT, EQ, GT] &gt; succ \'B\' &gt; \'C\' Bounded Members of this typeclass have an upper and lower bound. Both minBound and maxBound have a type of (Bounded a) =&gt; a. Tuples are part of Bounded if all of their components are. &gt; minBound :: Int &gt; -2147483648 &gt; maxBound :: Bool &gt; True &gt; maxBound :: (Bool, Int, Char) &gt; (True, 2147483647, \'\\1114111\') Num Is a numeric typeclass. Its members have the property of being able to act like numbers. Whole numbers are polymorphic constants. They can act like any type that\u2019s a member of the Num typeclass. If we examine the type of * we can see that it accepts all numbers. &gt; :t (*) &gt; (*) :: (Num a) =&gt; a -&gt; a -&gt; a As * takes two numbers of the same type, (5 :: Int) * (6 :: Integer) will result in an error. To be part of Num, a type must also be part of Show and Eq. Integral Is a numeric typeclass containing Int and Integer Floating Is a numeric typeclass containing Float and Double The fromIntegral function has a type declaration of fromIntegral :: (Num b, Integral a) =&gt; a -&gt; b. It takes an integral number and turns it into a more general number. Syntax in functions Pattern matching Pattern matching is the process of specifying patterns to which data should conform and then checking to see if it does, deconstructing the data according to those patterns. When defining functions, separate bodies can be defined for different patterns. factorial :: (Integral a) =&gt; a -&gt; a factorial 0 = 1 factorial n = n * factorial(n - 1) Pattern matching can fail. charName :: Char -&gt; String charName \'a\' = "Albert" charName \'b\' = "Bert" charName \'c\' = "Cecil" When called with an unexpected input, and exception will be raised Non-exhaustive patterns in function charName Pattern matching can also be used on tuples. addVectors :: (Num a) =&gt; (a, a) -&gt; (a, a) -&gt; (a, a) addVectors a b = (fst a + fst b, snd a + snd b) Using pattern matching we can instead write the function as addVectors (x1, y1) (x2, y2) = (x1 + x2, y1 + y2) There are no provided functions to extract the components of triples, but they can be easily written. first :: (a, c, c) -&gt; a first (x, _, _) = x second :: (a, b, c) -&gt; b second (_, y, _) = y third :: (a, b, c) -&gt; c third (_, _, z) = z It is also possible to pattern match in list comprehensions. &gt; let xs = [(1, 3), (4, 3), (2, 4), (5, 3), (5, 6), (3, 1)] &gt; [a+b | (a, b) &lt;- xs] &gt; [4,7,6,8,11,4] If a pattern match fails, it will move to the next element. We can pattern match against a list to make our own implementation of head head\' :: [a] -&gt; a head\' [] = error "Empty list has no head" head\' (x:_) = x tell :: (Show a) =&gt; [a] -&gt; String tell [] = "The list is empty" tell (x:[]) = "The list has one element: " ++ show x tell (x:y:[]) = "The list has two elements: " ++ show x ++ " and " ++ show y tell (x:y:_) = "The list is long. The first two elements are " ++ show x ++ " and " ++ show y The tell function is safe because it handles the empty list, singleton list, two element list, and lists with more than two elements. We could rewrite (x:[]) and (x:y:[]) as [x] and [x,y] respectively. We cannot however rewrite (x:y:_) with square brackets because it matches any list of length 2 or more. We can implement a recursive length function using list comprehension length\' :: (Num b) =&gt; [a] -&gt; b length\' [] = 0 length\' (_:xs) = 1 + length` xs We first define the result of a known input, the empty list. This is known as the edge condition. In the second pattern we split the list into a head and a tail, and then state that the length is 1 plus the length of the tail. sum\' :: (Num a) =&gt; [a] -&gt; a sum\' [] = 0 sum\' (x:xs) = x + sum` xs Patterns Patterns are a method of breaking something up according to a pattern and binding it to names whilst still keeping a reference to the whole thing. xs@(x:y:ys) will match exactly the same thing as x:y:ys but the whole list can be accessed via xs instead of repeatedly typing x:y:ys within the function body. capital :: String -&gt; String capital "" = "Empty string" capital all@(x:xs) = "The first letter of " ++ all ++ " is " + [x] Patterns can be used to avoid needless repetition. Note that ++ cannot be used in pattern matching. Guards While patterns make sure a value conforms to some form and allow destructuring it, guards are a way of testing whether some property or properties of a value are true or false. Guards are much more readable that a statement when there are several conditions. bmi :: (RealFloat a) =&gt; a -&gt; String bmi i | i &lt;= 18.5 = "Underweight" | i &lt;= 25 = "Normal" | i &lt;= 30 "Fat" | i &lt;= "Land whale" Guards are indicated by pipes that follow a function\u2019s name and its parameters. They are usually indented. A guard is basically a boolean expression. If it evaluates to True, the corresponding body is used. Otherwise, the next guard is evaluated. The last guard will often be otherwise. otherwise is simply an alias for True, and catches everything. If all the guards of a function evaluate to False and there is no otherwise guard, evaluation falls through to the next pattern. If no suitable guards or patterns are found, an error is thrown. Guards can also be written inline, although it is less readable. max\' :: (Ord a) =&gt; a -&gt; a -&gt; a max\' a b | a &gt; b = a | otherwise = b compare\' :: (Ord a) =&gt; a -&gt; a -&gt; Ordering a `compare` b | a &gt; b = GT | a == b = EQ | otherwise = LT where Take note of the repetition in the function below bmi :: (RealFloat a) =&gt; a -&gt; a -&gt; String bmi weight height | weight / height ^2 &lt;= 18.5 = "Underweight" | weight / height ^2 &lt;= 25 = "Normal" | weight / height ^2 &lt;= 30 = "Overweight" | otherwise = "Land whale" Rather than repeating the bmi calculation, we can use the where keyword. bmi weight height | i &lt;= 18.5 = "Underweight" | i &lt;= 25 = "Normal" | i &lt;= 30 = "Overweight" | otherwise = "Land whale" where i = weight / height ^2 The value defined in where is visible across the guards. where bindings are not shared across function bodies of different patterns. If you want several patterns of one function to access a shared name, the name must be defined globally. We could also write a pattern match. where bmi = weight / height ^2 (underweight, normal, overweight) = (18.5, 25, 30) Another trivial function might five someone their initials initials :: String -&gt; String -&gt; String initials firstname lastname = [f] ++ ". " ++ [l] ++ "." where (f:_) = firstname (l:_) = lastname In the same way that we have defined constants in where blocks, we can also define functions. calcBmis :: (RealFloat a) =&gt; [(a, a)] -&gt; [a] calcBmis xs = [bmi w h | (w, h) &lt;- xs] where bmi weight height = weight / height ^2 Let it be let bindings are very similar to where bindings. let bindings allow you to bind variables anywhere and are themselves expressions. They do not span across guards. cylinder :: (RealFloat a) =&gt; a -&gt; a -&gt; a cylinder r h = let sideArea = 2 * pi * r * h topArea = pi * r^2 in sideArea + 2 * topArea A let binding is of the form let &lt;bindings&gt; in &lt;expression&gt;. The names defined in the binding are accessible in the expression. This is similar to splitting up a calculation in another language. fun cylinder(r: Int, h: Int): Float { val sideArea = 2 * Math.PI * r * h val topArea = Math.PI * r * r return sideArea + 2 * topArea } The difference between where and let bindings is that while where bindings are just syntactic constructs, let bindings are actually expressions. let bindings can be used almost anywhere, in the same way as if statements. &gt; 4 * (let a = 9 in a + 1) + 2 &gt; 42 &gt; [let square x = x * x in (square 5, square 3, square 2)] &gt; [(25, 9, 4)] If we want to bind several variables in line, we can separate them with semicolons. &gt; (let a = 100; b = 200; c = 300 in a*b*c, let foo="Hey"; bar = "there!" in foo ++ bar) &gt; (6000000, "Hey there!") let bindings are very useful for quickly dismantling a tuple into components and binding them to names. &gt; (let (a,b,c) = (1,2,3) in a+b+c)*100 &gt; 600 let bindings can also be used inside list comprehensions. calcBmis :: (RealFloat a) =&gt; [(a, a)] -&gt; [a] calcBmis xs = [bmi | (w, h) &lt;- xs, let bmi = w /h^2] We use let in a similar way to a predicate, the difference being that we do not filter the list. The names defined in a let are visible to the output function and all predicates and sections that come after the binding. listOverweight :: (RealFloat a) =&gt; [(a, a)] -&gt; [a] listOverweight xs :: [bmi | (w, h) &lt;- xs, let bmi = w / h^2, bmi &gt;= 25] We omitted the in part of the binding because the scope of the names is already predefined. If we used let in, the names would only be visible to that predicate. Case expressions The syntax for a case expression is simple case expression of pattern -&gt; result pattern -&gt; result pattern -&gt; result ... expression is matched against the patterns. The first pattern that matches the expression is used. If it falls through the whole case an exception occurs. Whereas pattern matching on function parameters can only be done when defining functions, case expressions can be used pretty much anywhere. They are useful for pattern matching against something in the middle of an expression. Recursion The maximum function takes a list of instances of the Ord typeclass, and returns the largest of them. In an imperative language you might define this function as so fun maximum(items: Array&lt;Int&gt;): Int { var max = Integer.MIN_VALUE items.forEach { if (it &gt; max) { max = it } } return max } In Haskell we might instead write our maximum function as follows maximum\' :: (Ord a) =&gt; [a] -&gt; a maximum\' [] = error "Empty list" maximum\' [x] = x maximum\' (x:xs) | x &gt; maxTail = x | otherwise = maxTail where maxTail = maximum\' xs We split the list into a head and a tail, and then compare the head to the maximum of the tail. Consider [2, 5, 1]. We reach the (x:xs) branch with a head of 2 and a tail of [5, 1]. maximum\' is called on [5, 1], reaching the same branch with a head of 5 and a tail of [1]. maximum\' is called once more on [1] which returns 1. We now cascade back up the call stack, comparing the head 5 to 1, giving 5 and then comparing 5 (maxTail) to 2 and returning 5. The function could be written more elegantly using max. maximum\' :: (Ord a) =&gt; [a] -&gt; a maximum\' [] = error "Empty list" maximum\' [x] = x maximum\' (x:xs) - max x (maximum\' xs) Recursive function Examples Replicate replicate\' :: (Num i, Ord i) =&gt; i -&gt; a -&gt; [a] replicate\' n x | n &lt;= 0 = [] | otherwise x:replicate` (n-1) x As we are testing boolean expressions we used guards. As Num is not a subclass of Ord we have to specify both class constraints. Take take\' :: (Num i, Ord i) =&gt; i -&gt; [a] -&gt; [a] take` n _ | n &lt;= 0 = [] take` _ [] = [] take` n (x:xs) = x:take` (n-1) xs The first pattern deals with negative values, the second with empty lists, and the third with lists containing some number of items. As our guard has no otherwise, the the matching will fall through when n &gt; 0. Reverse reverse\' :: [a] -&gt; [a] reverse\' [] = [] reverse\' (x:xs) = reverse\' xs ++ [x] Repeat repeat takes an element and returns an infinite list of that element. repeat\' :: a -&gt; [a] repeat\' x = x:repeat x Repeat zip takes two lists and zips them together to a list of pairs. zip\' :: [a] -&gt; [b] -&gt; [(a, b)] zip\' _ [] = [] zip\' [] _ = [] zip\' (x:xs) (y:ys) = (x,y):zip xs ys Elem elem\' :: a -&gt; [a] -&gt; Bool elem\' a [] = False elem\' a (x:xs) | a == x = True | otherwise = a `elem` xs Quick sort Implementing QuickSort is much easier in Haskell than in imperative languages. quicksort :: (Ord a) =&gt; [a] -&gt; [a] quicksort [] = [] quicksort (x:xs) = let smallerSorted = quicksort [a | a &lt;- xs, a &lt;= x] biggerSorted = quicksort [a | a &lt;- xs, a &lt;= x] in smallerSorted ++ [x] ++ biggerSorted This Quicksort implementation uses the head as a pivot for the sorting. Higher order functions Functions in Haskell can take functions as parameters and return functions. A function that does either of those is called a higher order function. Curried functions Every function in Haskell only takes one parameter. All the functions which take several parameters are curried functions. The following two calls are equivalent &gt; max 4 5 &gt; (max 4) 5 Calling max 4 5 first creates a function which takes a single parameter and returns either 4 or that parameter, whichever is larger. It then applies that function to 5. Putting a space between two pieces of code is simply function application. The space is like an operator with the highest precedence. Again considering max max :: (Ord a) =&gt; a -&gt; a-&gt; a max :: (Ord a) =&gt; a -&gt; (a -&gt; a) The second line could be read as max takes an a and returns a function that takes another a and returns an a. The return type of each functions are separated with the arrows. Consider the following function multThree :: (Num a) =&gt; a -&gt; a -&gt; a -&gt; a multThree x y z = x * y * z When we call multThree 3 5 9 we are actually calling ((multThree 3) 5) 9. This means that 3 is applied to multThree to create a function that takes one parameter and returns a function. Next, 5 is applied to that function, and returns a function which takes a single parameter and multiplies it by 15. Finally, 9 is applied to that function and the result is 135. By calling functions without some of their parameters, we can create new functions. &gt; let multTwoWithNine = multThree 9 &gt; multTwoWithNine 2 3 &gt; 54 &gt; let multWithEighteen = multTwoWithNine 2 &gt; multWithEighteen 10 &gt; 180 Infix functions can also be partially applied by using sections. To section an infix function, surround it with parentheses and only supply a parameter on one side. divTen :: (Floating a) =&gt; a -&gt; a divTen = (/10) isUpperAlphanum :: Char -&gt; Bool isUpperAlphanum = (\'elem\' [\'A\'..\'Z\']) Note that when using sections, - cannot be used directly. (-4) means -4. To make a function which takes a value and subtracts 4 from it you must replace the - with subtract, (subtract 4). Higher order functions applyTwice :: (a -&gt; a) -&gt; a -&gt; a applyTwice f x = f (f x) Notice that the type declaration contains parentheses. They are mandatory when one of the parameters is a function. &gt; applyTwice (+4) 10 &gt; 18 We can now re-implement another standard library function, zipWith. zipWith takes a function and two lists as parameters and then joins the two lists by applying the function between corresponding elements. zipWith\' (a -&gt; b -&gt; c) -&gt; [a] -&gt; b -&gt; [c] zipWith\' _ [] _ = [] zipWith\' _ _ [] = [] zipWith\' f (x:xs) (y:ys) = f x y : zipWith\' f xs ys In the type decleration the first parameter is a function that takes two things and produces a third. The second and third parameters are lists, and the return value is a list, with each list matching the respective types of the arguments of the first function. &gt; zipWith\' (+) [4,2,5,6] [2,6,2,3] &gt; [6,8,7,9] Another standard library function is flip. It takes a function and returns a function which is like the original function, but with the first two arguments flipped. flip\' :: (a -&gt; b -&gt; c) -&gt; (b -&gt; a -&gt; c) flip\' f = g where g x y = f y x Reading the type declaration we say that flip\' takes a function that takes an a and a b, and returns a function that takes a b and an a. Because functions are curried by default, the second pair of parentheses is really unnecessary, because -&gt; is right associative by default. (a -&gt; b -&gt; c) -&gt; (b -&gt; a -&gt; c) is the same as (a -&gt; b -&gt; c) -&gt; (b -&gt; (a -&gt; c)) which is the same as (a -&gt; b -&gt; c) -&gt; b -&gt; a -&gt; c. We can further simplify the function by writing it as flip\' :: (a -&gt; b -&gt; c) -&gt; b -&gt; a -&gt; c flip\' f y x = f x y Maps and filters map Takes a function and a list and applies that function to every element in the list, producing a new list. The definition of map is map :: (a -&gt; b) -&gt; [a] -&gt; [b] map _ [] = [] map f (x:xs) = f x : map f xs &gt; map (+2) [1,2,3,4] &gt; [3,4,5,6] This is much more readable than the equivalent list comprehension [x+2 | x &lt;- [1,2,3,4]]. filter is a function that takes a predicate and a list and returns the elements of the list that satisfy the predicate filter :: (a -&gt; Bool) -&gt; [a] -&gt; [a] filter _ [] = [] filter p (x:xs) | p x = x : filter p xs | otherwise = filter p xs &gt; filter (&gt;3) [1,2,3,4,5,6,7,8,9] &gt; [4,5,6,7,8,9] &gt; let notNull x = not (null x) in filter notNull [[1,2,3],[],[3,4,5],[2,2],[],[]] &gt; [[1,2,3],[3,4,5],[2,2]] Recalling the earlier implementation of QuickSort, we can replace the list comprehensions with calls to filter. quicksort :: (Ord a) =&gt; [a] -&gt; [a] quicksort [] = [] quicksort (x:xs) = let smallerSorted = quicksort (filter (&lt;=x) xs) biggerSorted = quicksort (filter (&gt;x) xs) in smallerSorted ++ [x] ++ biggerSorted takeWhile is a function that takes a list and a predicate and returns all of the elements from the start of the list while the predicate returns true Suppose we wish to find the sum of all odd square that are less than 10000 &gt; sum (takeWhile (&lt;10000) (filter odd (map (^2) [1..]))) &gt; 166650 In the Collatz sequence, we start with a natural number. If the number is even we divide it by 2. If the number is odd we multiply it by 3 and add 1. We take the resulting value and apply the same process to it, stopping when we reach one. chain :: (Integral a) =&gt; a -&gt; [a] chain 1 = [1] chain n | even n = n:chain (n / 2) | odd n = n:chain (n*3 + 2) &gt; chain 10 &gt; [10, 5, 16, 8, 4, 2, 1] Lambdas Lambdas are anonymous functions that are used because we need some functions only once, and do not want to pollute the namespace. We write a lambda with a \\newline and then write the parameters, followed by a -&gt; and then the function body. Filtering for long chains we might write numLongChains :: Int numLongChains = length (filter (\\xs -&gt; length xs &gt; 15) (map chain [1..100])) Lambdas can take any number of parameters in the same way as normal functions &gt; zipWith (\\a b -&gt; (a * 30 + 3) / b) [5,4,3,2,1] [1,2,3,4,5] &gt; [153.0, 61.5, 31.0, 15.75, 6.6] As with normal functions, we can pattern match in lambdas. &gt; map (\\newline(a,b) -&gt; a + b) [(1,2),(3,5),(6,3),(2,6),(2,5)] &gt; [3,8,9,8,7] Due to the way we curry functions, the following two are equivalent addThree :: (Num a) =&gt; a -&gt; a -&gt; a -&gt; a addThree x y z = x + y + z addThree :: (Num a) =&gt; a -&gt; a -&gt; a -&gt; a addThree = \\x -&gt; \\y -&gt; \\z -&gt; x + y + z While the example above decreases readability, it can aid with the understanding of some functions, such as flip flip\' :: (a -&gt; b -&gt; c) -&gt; b -&gt; a -&gt; c flip\' f = \\x y -&gt; f y x Folding foldl The left fold the folds a list up form the left side sum\' :: (Num a) =&gt; [a] -&gt; a sum\' xs = foldl (\\acc x -&gt; acc + x) 0 xs In the example above \\acc x -&gt; acc + x is the binary function. 0 is the starting value and xs is the list to be folded up. &gt; sum\' [3,5,2,1] &gt; 11 At each step we have | 0 + 3 | [3,5,2,1] | | 3 + 5 | [5,2,1] | | 8 + 2 | [2,1] | | 10 + 1| [1] | | 11 | | We could implement elem using foldl elem\' :: (Eq a) =&gt; a -&gt; [a] -&gt; Bool elem\' y ys = foldl (\\acc x -&gt; if x == y then True else acc) False ys The starting value and accumulator above are both boolean values. foldr Works in a similar way to foldl, except that it consumes values from the right foldr takes the accumulator as the second function. We can implement map with a foldr. map\' :: (a -&gt; b) -&gt; [a] -&gt; [b] map\' f xs = foldr (\\x acc -&gt; f x : acc) [] xs If we map (+3) to [1,2,3], we approach the list from the right side. We take the first element 3 and apply the function to it, giving 6. We prepend 6 to the accumulator. We then apply (+3) to 2, giving 5, and prepend it to the accumulator. Continuing in the same manner we reach [4,5,6]. One notable difference is that folr works on infinite lists, while foldl does not. Folds can be used to implement any function were you traverse a list once. There are also the functions foldl1 and foldr1 which do not require a starting value, instead assuming that the first value in their traversal order is the starting value. This would allow an implementation of sum as sum = foldl1 (+), although it would cause an error on an empty list. Fold implementations of standard library functions maximum\' :: (Ord a) =&gt; [a] -&gt; a maximum\' = foldr1 (\\x acc -&gt; if x &gt; acc then x else acc) reverse\' :: [a] -&gt; [a] reverse\' = foldl (\\acc x -&gt; x : acc) [] product\' :: (Num a) =&gt; [a] -&gt; a product\' = foldr1 (*) filter\' :: (a -&gt; Bool) -&gt; [a] -&gt; [a] filter\' p = foldr (\\x acc -&gt; if p x then x : acc else acc) [] head\' :: [a] -&gt; a head\' = foldr1 (\\x _ -&gt; x) last\' :: [a] -&gt; a last\' = foldl1 (\\_ x -&gt; x) The head function would be better implemented by pattern matching, as the fold traverses the entire list. In reverse we take a starting value of an empty list and append each value from the left to our list. scanl and scanr scanl and scanr are like foldl and foldr, with the difference being that they report all the intermediate accumulator states in the form of a list. There are also scanl1 and scanr1 &gt; scanl (+) 0 [3,5,2,1] &gt; [0,3,8,10,11] &gt; scanr (+) 0 [3,5,2,1] &gt; [11,8,3,1,0] &gt; scanl1 (\\acc x -&gt; if x &gt; acc then x else acc) [3,4,5,3,,7,9,2,1] &gt; [3,4,5,5,7,9,9,9] &gt; scanl (flip (:)) [] [3,2,1] &gt; [[],[3],[2,3],[1,2,3]] Scans are used to monitor the progression of a function that can be implemented as a fold. Function application with $ The $ function is also called function application. ($) :: (a -&gt; b) -&gt; a -&gt; b f $ x = f x Whereas normal function application has the highest precedence, $ has the lowest precedence. Function application with a space is left-associative so f a b c is the same as ((f a) b) c. Function application with $ is right associative. Consider the expression sum (map sqrt [1..130]). We can instead write sum $ map sqrt [1..130]. When a $ is encountered the expression on its right is applied as the parameter to the function on its left. Consider sqrt (3 + 4 + 9). We could instead write this as sqrt $ 3 + 4 + 9. In sum (filter (&gt; 10) (map (*2) [2..10])) we can write sum $ filter (&gt; 10) $ map (*2) [2..10] because f (g (z x)) is equal to f $ g $ z x. Function composition In Haskell, function composition is performed with the . function, which is defined as follows (.) :: (b -&gt; c) -&gt; (a -&gt; b) -&gt; a -&gt; c f . g = \\x -&gt; f (g x) f must take as its parameter a value that has the same type as g\u2019s return value. One of the uses for function composition is making functions on the fly to pass to other functions, which is often cleaner and more concise than lambdas. &gt; map (\\x -&gt; negate (abs x)) [5,-3,-6,7,-3,2,-19,24] &gt; [-5,-3,-6,-7,-3,-2,-19,-24] &gt; map (negate . abs) [5,-3,-6,7,-3,2,-19,24] &gt; [-5,-3,-6,-7,-3,-2,-19,-24] Function composition is right associative, so multiple functions can be composed together. Function composition with multiple parameters If we want to use a function with multiple parameters in a function composition, we usually have to partially apply them so that each function takes just one parameter. sum (replicate 5 (max 6.7 8.9)) can be rewritten as (sum . replicate 5. max 6.7) 8.9 or as sum . replicate 5 . max 6.7 $ 8.9. What is happening is the creation of a function that takes what max 6.7 takes and applies replicate 5 to it. Then a function that takes the result of that and does a sum of it is create. Finally, that unction is called with 8.9. However it is more easily read as taking the value of max 6.7 8.9, replicating it 5 times, and taking the sum of that replication. If you want to rewrite a function with lots of parentheses you can start by putting the last parameter of the innermost function after a $, and replacing each pair of parentheses with a .. replicate 100 (product (map (*3) (zipWith max [1,2,3,4,5] [4,5,6,7,8]))) can be rewritten as replicate 100 . product . map (*3) . zipWith max [1,2,3,4,5] $ [4,5,6,7,8]. The free point style allows functions to be written more cleanly fn x = ceiling (negate (tan (cos (max 50 x)))) can instead be written fn = ceiling . negate . tan . cos . max 50 Modules A Haskell module is a collection of related functions, types, and typeclasses. A program is a collection of modules in which the main module loads up the other modules and then uses their functions to perform some process. Modules provide many advantages. If a module is generic enough, the functions it exports can be used in many different programs. If code is separated into self-contained modules which aren\u2019t too reliant on each other, they can be reused later on and changed more easily without having to rewrite other code. The standard library is split into modules, each of which contains related functions and types. Modules are imported before the definition of any function with the syntax import module_name. The Data.List module has useful functions for working with lists. One of these functions is numUniques numUniques:: (Eq a) =&gt; [a] -&gt; Int numUniques = length . nub When Data.List is imported, all of its exports become available in the global namespace. nub is another function in Data.List that removes duplicate elements from a list. In the terminal, functions can be added to the global namespace with :m &gt; :m + Data.List Data.Map Data.Set Individual functions can also be imported import Data.List (nub, sort) We can also import all of the functions in a module except some which are explicitly excluded. This is useful if different modules export functions with the same name. import Data.List hiding (nub) Another method for dealing with name clashes is qualified imports. The Data.Map module contains functions with the same names as some of those in Prelude, such as filter or null import qualified Data.Map This means that when we wish to reference the filter function in Data.Map we must write Data.Map.Filter. As this can make code very verbose, there is the option to name the import import qualified Data.Map as M We can now access Data.Map.Filter as M.filter Data.List intersperse takes an element and a list and puts that element in between each pair of elements in the list &gt; intersperse 0 [1,2,3,4,5] &gt; [1,0,2,0,3,0,4,0,5] intercalate takes a list of lists and a list, and inserts the list between each of the lists within the list of lists, before flattening the result &gt; intercalate [0,0,0] [[1,2,3],[4,5,6],[7,8,9]] &gt; [1,2,3,0,0,0,4,5,6,0,0,0,7,8,9] transpose transposes a list of lists. Considering the list of lists as a 2d matrix, rows become columns and vice versa &gt; transpose [[1,2,3],[4,5,6],[7,8,9]] &gt; [[1,4,7],[2,5,8],[3,6,9]] fold\u2019 and foldl1\u2019 are stricter version of their respective lazy incarnations. When using lazy folds on very large lists, stack overflow errors may occur. Due to the lazy nature of folds, the accumulator is not actually updated as the folding happens. The strict fold functions actually compute the intermediate values rather than filling up the stack with thunks. concat flattens a list of lists into a list of elements &gt; concat [[1,2,3],[4,5,6],[7,8,9]] &gt; [1,2,3,4,5,6,7,8,9] concatMap is the same as first mapping a function to a list, and then concatenating the list with concat and takes a list of values and returns True only if all the values in the list are True or takes a list and returns True if any of the values in the list are True &gt; and $ map (&gt;4) [5,6,7,8] &gt; True &gt; or $ map (==4) [1,2,3,4,5,6,7,8] &gt; True any and all take a predicate and then check if any or all of the elements in the list satisfy the predicate, respectively. These functions are usually used rather than mapping over a list and then using or or and iterate takes a function and a starting value. It applies the function to the starting value, then applies that function to the result, and repeats, returning in the form of an infinite list &gt; take 10 $ iterate (*2) 1 &gt; [1,2,4,8,15,32,64,128,256,512] splitAt takes a number and a list. It then splits the list at that many elements, returning the two lists in a tuple &gt; splitAt 3 [1,2,3,4,5,6] &gt; ([1,2,3], [4,5,6]) takeWhile takes elements from a list while the predicate holds &gt; takeWhile (/=\' \') "This is a sentence" &gt; "This" dropWhile takes a list and drops all the elements from the list while the predicate holds &gt; dropWhile (&lt;3) [1,2,2,2,2,2,2,8,6,8] &gt; [8,6,8] span returns a pair of lists, the first list containing the result of takeWhile on the list, and the second list containing the remaining elements break break p is the equivalent of span (not . p) sort sorts a list of the Ord typeclass group takes a list and groups the adjacent elements into sublists if they are equal &gt; group [1,1,1,2,2,2,2,3,3,3,3,3,4,4,4,4,4,4] &gt; [[1,1,1],[2,2,2,2],[3,3,3,3,3],[4,4,4,4,4,4]] inits and tails are like init and tail except that they recursively apply to the list until there is nothing left &gt; inits "text" &gt; ["", "t", "te", "tex", "text"] isInfixOf returns true if a sublist is contained within a list isPrefixOf and isSuffixOf search for a sublist at the beginning and end of a list respectively elem and notElem check if an element is or is not inside a list partition takes a list and a predicate and returns a pair of lists, the first containing all the elements that satisfy the predicate, and the second containing those that do not find takes a list and a predicate and returns the first element that satisfies the predicate The type of find is Maybe a as it can contain Just a or Nothing. elemIndex returns the index of an element in a list, or Nothing if the element is not contained within the list elemIndices returns a list of the indices of an element within a list findIndex maybe returns the index of the first element that satisfies the predicate zip3, zip4, zipWith3, and zipWith4 zip 3 or 4 lists into triples or 4 tuples lines takes a string returns every line of that string in a separate list &gt; lines "line 1\\nline 2\\nline 3" &gt; ["line 1", "line 2", "line 3"] unlines takes a list of strings and joins them together with the \u2018\\n\u2019 character words and unwords split a line of text into words or join a list of words respectively delete takes an element and a list and deletes the first occurrence of that element in the list \\ the list difference function. For every element in the right hand list, it removes a matching element in the left one union returns the union of two lists intersect returns only the elements that are found in both lists insert takes an element and a list of elements that can be sorted and inserts it into the last position where it is less than or equal to the next element length, take, drop splitAt, !!, and replicate all take Int as one of their parameters, or return an Int. They could be more generic if they took any type that\u2019s part of Integral or Num. Data.List contains genericLength, genericTake etc to provide these functions without breaking old code. The nub, delete, union, intersect, and group functions all have their more general counterparts nubBy etc. While the standard functions use == to test for equality, the By functions take an equality function as a parameter. Similarly there are sortBy, insertBy, maximumBy, and minimumBy functions. Data.Char The Data.Char module deals with characters isControl checks whether a character is a control character isSpace checks whether a character is a white space character isLower checks whether a character is lower cased isUpper checks whether a character is upper cased isAlpha checks whether a character is a letter isAlphaNum checks whether a character is a letter or a number isPrint checks whether a character is printable isDigit checks whether a character is a digit isOctDigit checks whether a character is an octal digit isHexDigit checks whether a character is a hexadecimal digit isLetter checks whether a character is a letter isMark checks for Unicode mark characters. These characters combine with preceding letters to form letters with accents isNumber checks whether a character is numeric isPunctuation checks whether a character is punctuation isSymbol checks whether a character is a symbol isSeparator checks for Unicode spaces and separators isAscii checks whether a character falls within the first 128 of the Unicode set isLatin1 checks whether a character falls into the first 256 characters of the Unicode set isAsciiUpper checks whether a character is ASCII and uppercase isAsciiLower checks whether a character is ASCII and lowercase All of the above functions have a type signature of Char -&gt; Bool Data.Char exports a data type which is similar to Ordering. The Ordering type can have a value of LT, EQ, or GT. It describes possible result that can arise from comparing elements. The GeneralCategory type is also an enumeration. It presents possible categories that a character can fall into. generalCategory has a type of Char -&gt; GeneralCategory. There are a total of 31 categories. &gt; generalCategory \' \' &gt; Space &gt; generalCategory \'A\' &gt; UppercaseLetter &gt; generalCategory \'|\' &gt; MathSymbol toUpper converts a character to uppercase, ignoring those which do not have an uppercase toLower converts a character to lowercase toTitle converts a character to title case, which is usually the same as uppercase digitToInt converts a character to an Int. The character must be in the range \u20180..9, a..f, A..F\u2019 intToDigit is the inverse of digitToInt ord and chr convert characters to their numeric values and vice versa Data.Map Association lists are lists that are used to store key-value pairs where ordering does not matter. We could represent this structure with a list of pairs, and find values by their key as follows findKey :: (Eq k) =&gt; k -&gt; [(k, v)] -&gt; v findKey key xs = snd . head . filter (\\(k,v) -&gt; key == k) $ xs The function takes the list of pairs, filters the list so that only matching keys remain, and takes the head value. In order to deal with elements which do not exist, we must return Maybe v findKey :: (Eq k) =&gt; k -&gt; [(k,v)] -&gt; Maybe v findKey key [] = Nothing findKey key ((k,v):xs) = if key == k then Just v else findKey key xs This recursive function on a list can be implemented as a fold findKey :: (Eq k) =&gt; k -&gt; [(k,v)] -&gt; Maybe v findKey key = foldr (\\(k,v) acc -&gt; if key == k then Just v else acc) Nothing The findKey function does the same thing as the lookup function from Data.List. The Data.Map module offers association lists which are much faster, as they are not traversing lists. Data.Map should qualified in order to stop namespace clashes with Prelude and Data.List. fromList takes an association list and returns a map with the same associations If there are duplicate keys in the list, they are discarded. fromList has the signature Map.fromList :: (Ord k) =&gt; [(k, v)] -&gt; Map.Map k v. The keys must be orderable so that they can be placed in a tree. empty represents an empty map insert takes a key, a value, and a map, and returns a new map with the new item &gt; Map.empty &gt; fromList [] &gt; Map.insert 3 100 Map.empty &gt; fromList [(3,100)] null checks if a map is empty size reports the size of a map, which is the number of key value pairs singleton takes a key and a value and creates a map with exactly one mapping lookup returns Just something if a key exists and Nothing if it does not member is a predicate that takes a key and a map and reports whether the key is in the map map and filter work much like their list equivalents, working on the values toList is the inverse of fromList keys and elems return a list of keys and values respectively fromListWith acts like fromList except that it takes a function supplied to decide what to do with duplicate keys The function is used to combine the values of those keys into some other value insertWIth inserts a key-value pair into a map, using the passed function if the key already exists Data.Set Data.Set offers set structures. fromList takes a list and converts it to a set &gt; Set.fromList "The quick brown fox jumped over the lazy dog." &gt; fromList " .Tabcdefghijklmnopqrstuvwxyz" The elements are ordered and each element is unique intersection returns a set of the elements which are present in both sets difference returns a set of the elements which are in the first set but not the second union returns a set of the combined elements of both sets null, size, member, empty, singleton, insert, and delete work as expected isSubsetOf checks if the first set is a subset of the second set isProperSubsetOf checks if the first set is a proper subset of the second set Creating modules Modules are defined as follows module Geometry ( sphereVolume , sphereArea , cubeVolume , cubeArea , cuboidArea , cuboidVolume ) where sphereVolume :: Float -&gt; Float sphereVolume radius = (4.0 / 3.0) * pi * (radius ^ 3) sphereArea :: Float -&gt; Float sphereArea radius = 4 * pi * (radius ^ 2) cubeVolume :: Float -&gt; Float cubeVolume side = cuboidVolume side side side cubeArea :: Float -&gt; Float cubeArea side = cuboidArea side side side cuboidVolume :: Float -&gt; Float -&gt; Float -&gt; Float cuboidVolume a b c = rectangleArea a b * c cuboidArea :: Float -&gt; Float -&gt; Float -&gt; Float cuboidArea a b c = rectangleArea a b * 2 + rectangleArea a c * 2 + rectangleArea c b * 2 rectangleArea :: Float -&gt; Float -&gt; Float rectangleArea a b = a * b The helper function rectangleArea is not exported. Modules can be given hierarchical structures. Each module can have a number of submodules which can have submodules of their own. Creating submodules First we create a folder called Geometry. Within this folder we create three files: Sphere.hs, Cuboid.hs, and Cube.hs module Geometry.Sphere ( volume , area ) where volume :: Float -&gt; Float volume radius = (4.0 / 3.0) * pi * (radius ^ 3) area :: Float -&gt; Float area radius = 4 * pi * (radius ^ 2) module Geometry.Cuboid ( volume , area ) where volume :: Float -&gt; Float -&gt; Float -&gt; Float volume a b c = rectangleArea a b * c area :: Float -&gt; Float -&gt; Float -&gt; Float area a b c = rectangleArea a b * 2 + rectangleArea a c * 2 + rectangleArea c b * 2 rectangleArea :: Float -&gt; Float -&gt; Float rectangleArea a b = a * b module Geometry.Cube ( volume , area ) where import qualified Geometry.Cuboid as Cuboid volume :: Float -&gt; Float volume side = Cuboid.volume side side side area :: Float -&gt; Float area side = Cuboid.area side side side In each module we have defined functions with the same names. This is possible because they are separate modules. Making Types and Typeclassses Algebraic data types data Bool = False | True The data keyword is used to define a new data type. The part before the = denotes the type, and the parts after it are value constructors. They specify the different values that this type can have. We could think of Int as being data Int = -2147483648 | -2147483647 | ... | -1 | 0 | 1 | 2 | ... | 2147483647 Consider the definition of a shape data Shape = Circle Float Float Float | Rectangle Float Float Float Float The Circle value constructor has three fields. When we write a value constructor we optionally add some types after it and those types define the values it will contain. Value constructors are actually functions that ultimately return a value of a data type. &gt; :t Circle &gt; Circle :: Float -&gt; Float -&gt; Float -&gt; Shape &gt; :t Rectangle &gt; Rectangle :: Float -&gt; Float -&gt; Float -&gt; Float -&gt; Shape A function to find the surface of a Shape cane be written as follows surface :: Shape -&gt; Float surface (Circle _ _ r) = pi * r ^ 2 surface (Rectangle x1 y1 x2 y2) = (abs $ x2 - x1) * (abs $ y2 - y1) We could not write a type declaration of Circle -&gt; Float because Circle is not a type, whereas Shape is. We can pattern match against constructors, which we have been doing before when matching against values like [] or False. To make our type printable we modify it as below data Shape = Circle Float Float Float | Rectangle Float Float Float Float deriving (Show) When we add deriving (Show) at the end of a data declaration, Haskell makes that type part of the Show typeclass automatically. Value constructors are functions, so we can map them and partially apply them. &gt; map (Circle 10 20) [4,5,6,7] &gt; [Circle 10.0 20.0 4.0,Circle 10.0 20.0 5.0,Circle 10.0 20.0 6.0,Circle 10.0 20.0 7.0] To improve the Shape type we can define an intermediate data type to represent a point in two dimensional space data Point = Point Float Float deriving (Show) data Shape = Circle Point Float | Rectangle Point Point deriving (Show) When defining a point, we used the name for the data type and its value constructor. This has no special meaning. The surface function must now be adjusted surface :: Shape -&gt; Float surface (Circle r) = pi * r ^ 2 surface (Rectangle (Point x1 y1) (Point x2 y2)) = (abs $ x2 - x1) * (abs $ y2 - y1) When calculating the area of the rectangle we use nested pattern matching to access the fields. We can defined a function to modify the position of a shape nudge :: Shape -&gt; Float -&gt; Float -&gt; Shape nudge (Circle (Point x y) r) a b = Circle (Point (x+a) (y+b)) r nudge (Rectangle (Point x1 y1) (Point x2 y2)) a b = Rectangle (Point (x1+a) (y1+b)) (Point (x2+a) (y2+a)) &gt; nudge (Circle (Point 34 34) 10) 5 10 &gt; Circle (Point 39.0 44.0) 10.0 If we don\u2019t want to deal directly with points, we can make auxiliary functions that create shapes of some size at the zero coordinates and then nudge those. baseCircle :: Float -&gt; Shape baseCircle r = Circle (Point 0 0) r baseRect :: Float -&gt; Float -&gt; Shape baseRect width height = Rectangle (Point 0 0) (Point width height) &gt; nudge (baseRect 40 100) 60 23 &gt; Rectangle (Point 60.0 23.0) (Point 100.0 123.0) These data types can be exported in modules. Write the type along with the functions to be exported, and then add parentheses and specify the value constructors to be exported for it. To export all the value constructors for a type, just write .. module Shapes ( Point(..) , Shape(..) , surface , nudge , baseCircle , baseRect ) where By writing Shape(..) we exported all the value constructors for Shape. This is the same as writing Shape(Rectangle, Circle). We could opt not to export the value constructors for Shape by just writing Shape. This would mean that any user of the module could only make shapes using the auxiliary functions baseCircle and baseRect. Record syntax Suppose we wish to create a data type to contain information about a person. data Person = Person String String Int Float String String deriving (Show) &gt; let guy = Person "Buddy" "Finklestein" 43 184.2 "526-2928" "Chocolate" &gt; guy Person "Buddy" "Finklestein" 43 184.2 "526-2928" "Chocolate" This is somewhat unreadable. Now suppose that we cant to create a function to get individual pieces of information from a Person. firstName :: Person -&gt; String firstName (Person firstname _ _ _ _ _) = firstname lastName :: Person -&gt; String lastName (Person _ lastname _ _ _ _) = lastname age :: Person -&gt; Int age (Person _ _ age _ _ _) = age height :: Person -&gt; Float height (Person _ _ _ height _ _) = height phoneNumber :: Person -&gt; String phoneNumber (Person _ _ _ _ number _) = number flavor :: Person -&gt; String flavor (Person _ _ _ _ _ flavor) = flavor This is tedious to write. Instead we can write out data type as follows data Person = Person { firstName :: String , lastName :: String , age :: Int , height :: Float , phoneNumber :: String , flavor :: String } deriving (Show) We define a name for each field, and then specify its type. Functions are automatically created for looking up fields. The functions have the same name as the fields. &gt; :t flavor &gt; flavor :: Person -&gt; String When we derive Show, the output is also much more useful. data Car = Car String String Int deriving (Show) &gt; Car "Ford" "Mustang" 1967 Car "Ford" "Mustang" 1967 data Car = Car {company :: String, model :: String, year :: Int} deriving (Show) &gt; Car {company="Ford", model="Mustang", year=1967} Car {company = "Ford", model = "Mustang", year = 1967} When making a new Car we don\u2019t have to put the fields in their proper order, as long as we list all of them. If we were not using record syntax, we would have to specify them in order. Record syntax should be used when there are numerous parameters which are not immediately distinguishable. Type parameters A value constructor can take some values as parameters and then produce a new value. In a similar manner, type constructors take types as parameters and produce new types. data Maybe a = Nothing | Just a The a above is the type parameter. Because there is a type parameter involved, we call Maybe a type constructor. Depending on what we want this data type to hold when it is not Nothing, this type constructor can produce a type of Maybe Int, Maybe String or any other Maybe type. No value can have a type of just Maybe, because that is not a type, only a type constructor. If we pass Char as the type parameter to Maybe, we get a type of Maybe Char. The value Just \'a\' has a type of Maybe Char. &gt; Just "String" &gt; Just "String" &gt; Just 84 &gt; Just 84 &gt; :t Just "String" &gt; Just "String" :: Maybe [Char] &gt; :t Just 84 &gt; Just 84 :: (Num t) =&gt; Maybe t &gt; :t Nothing &gt; Nothing :: Maybe a &gt; Just 10 :: Maybe Double &gt; Just 10.0 Type parameters are useful because we can make different types with them depending on what kind of types we want contained in our data type. The type of Nothing is Maybe a. It is polymorphic. If some function requires Maybe Int as a parameter, we can give it Nothing, because Nothing doesn\u2019t contain a value anyway. The Maybe a type can act like a Maybe Int if it has to. Similarly, the type of an empty list is [a], so an empty list can act like anything. Another parametrized type is Map k v. Having maps parametrized enables us to have mappings from any type to any other type, as long as the type of the key is part of the Ord typeclass. If we were defining a mapping type, we could add a typeclass constraint in the data declaration. data (Ord k) =&gt; Map v k = ... It is a very strong convention in Haskell to never add typeclass constraints in data declarations. This is because we don\u2019t benefit a lot, but we end up writing more class constraints, even when we don\u2019t need them. If we put or don\u2019t put the Ord k constraint for Map k v, we will have to put the constraint into functions that assume the keys in a map can be ordered. If we don\u2019t put the constraint in the data declaration, we don\u2019t have to put (Ord k) =&gt; in the type declarations of functions that don\u2019t care whether the keys can be ordered. An example is toList, which has a type signature of toList :: Map k a -&gt; [(k, a)] rather than having to have a type constraint toList :: (Ord k) =&gt; Map k a -&gt; [(k, a)] without actually doing any comparing of keys. We don\u2019t put type constraints in data declarations because they will have to be put in function type declarations anyway. A 3d vector type and some operations are defined as follows data Vector a = Vector a a a deriving (Show) vplus :: (Num t) =&gt; Vector t -&gt; Vector t -&gt; Vector t (Vector i j k) `vplus` (Vector l m n) = Vector (i+l) (j+m) (k+n) vectMult :: (Num t) =&gt; Vector t -&gt; t -&gt; Vector t (Vector i j k) `vectMult` m = Vector (i*m) (j*m) (k*m) scalarMult :: (Num t) =&gt; Vector t -&gt; Vector t -&gt; t (Vector i j k) `scalarMult` (Vector l m n) = i*l + j*m + k*n We use a parametrized type because the vector should support several numeric types. vplus is use to add two vectors together. scalarMult is for the scalar product of two vectors, and vectMult is for multiplying a vector with a scalar. These functions can operate on types of Vector Int, Vector Integer, Vector Float, and any other type from the Num typeclass. It is very important to distinguish between the type constructor and the value constructor. When declaring a data type, the part before the = is the type constructor and the constructors after it are value constructors. Derived instances A type can be an instance of a typeclass if it supports a particular behaviour. Haskell can automatically make a type an instance of any of the following typeclasses: Eq, Ord, Enum, Bounded, Show, Read. When we derive the Eq instance for a type and then try to compare two values, Haskell will see if the value constructors match, and it will then check if all the data contained inside matches by testing each pair of fields, each of which also have to be part of the Eq typeclass. We can derive instances for the Ord typeclass. If we compare two values of the same type that were made using different constructors, the value which was made with a constructor that\u2019s defined first is smaller. data Bool = False | True deriving (Ord) Because the False constructor is specified first, we can consider True to be greater than False. In the Maybe a data type, the Nothing value constructor is specified before the Just value constructor. We can use algebraic data types to make enumerations with the Enum and Bounded typeclasses. data Day = Monday | Tuesday | Wednesday | Thursday | Friday | Saturday | Sunday deriving (Eq, Ord, Show, Read, Bounded, Enum) Day can be made part of the Enum typeclass because all the value constructors are nullary, taking no parameters. &gt; show Wednesday &gt; "Wednesday" &gt; read "Saturday" :: Day &gt; Saturday &gt; Saturday &gt; Friday &gt; True &gt; minBound :: Day &gt; Monday &gt; succ Monday &gt; Tuesday &gt; [Thursday .. Sunday] &gt; [Thursday, Friday, Saturday, Sunday] Type synonyms Type synonyms allow giving different names to complex types. type String = [Char] We are not actually defining a new type, only creating a synonym for an existing one. In the same way that functions can be partially applied, type parameters can also be partially applied type IntMap v = Map Int v or type IntMap = Map Int The Either data type takes two types as its parameters. data Either a b = Left a | Right b deriving (Eq, Ord, Read, Show) Either is useful to return a value and a possinle error. Recursive data structures We can make types whose constructors have fields that are of the same type. data List a = Empty | Cons a (List a) deriving (Show, Read, Eq, Ord) This list definition is either empty or a combination of a head value and a list. Cons is another word for :. We can define functions to be automatically infix by making them comprised of special characters. infixr 5 :-: data List a = Empty | a :-: (List a) deriving (Show, Read, Eq, Ord) When we define functions as operators, we can give them a fixity. The fixity states the associativity and the strength of the binding. &gt; 3 :-: 4 :-: 5 :-: Empty &gt; (:-:) 3 ((:-:) 4 ((:-:) 5 Empty)) When deriving Show for the type, Haskell will display it as if the constructor was a prefix function. Binary search tree data Tree a = EmptyTree | Node a (Tree a) (Tree a) deriving (Show, Read, Eq) Instead of manually building a tree, we can make a function that takes a tree and an element and inserts an element. singleton :: a -&gt; Tree a singleton x = Node x EmptyTree EmptyTree treeInsert :: (Ord a) =&gt; a -&gt; Tree a -&gt; Tree a treeInsert x EmptyTree = singleton x treeInsert x (Node a left right) | x == a = Node x left right | x &lt; a = Node a (treeInsert x left) right | x &gt; a = Node a left (treeInsert x right) treeElem :: (Ord a) =&gt; a -&gt; Tree a -&gt; Bool treeElem :: x EmptyTree = False treeElem :: x (Node a left right) | x == a = True | x &lt; a = treeElem x left | x &gt; a = treeElem x right We can use a fold to build up a tree from a list. &gt; let nums = [8,6,4,1,7,3,5] &gt; let numsTree = foldr treeInsert EmptyTree nums &gt; numsTree &gt; Node 5 (Node 3 (Node 1 EmptyTree EmptyTree) (Node 4 EmptyTree EmptyTree)) (Node 7 (Node 6 EmptyTree EmptyTree) (Node 8 EmptyTree EmptyTree)) Typeclasses The Eq typeclass is defined as follows class Eq a where (==) :: a -&gt; a -&gt; Bool (/=) :: a -&gt; a -&gt; Bool x == y = not (x /= y) x /= y = not (x == y) data TrafficLight = Red | Yellow | Green instance Eq TrafficLight where Red == Red = True Green == Green = True Yellow == Yellow = True _ == _ = False While Eq could have been implemented automatically, the code above demonstrates how it can be implemented by hand. The instance keyword is for making type instancs of typeclasses. Because == was defined in terms of \u2018/=\u2019 and vice versa in the class declaration, we only had to overwrite one of them in the instance. instance Show TrafficLight where show Red = "Red light" show Yellow = "Yellow light" show Green = "Green light" Typeclasses can also be subclasses of other typeclasses. class (Eq a) =&gt; Num a where This states that we have to make a type an instnace of Eq before it can be made an instance of Num. In the declaration of Eq we can see that a is used as a concrete type because all the types in functions have to be concrete types. For Maybe we must write instance Eq (Maybe m) where Just x == Just y = x == y Nothing == Nothing = True _ == _ = False We must also ensure that m is an instance of Eq to allow it to be compared. instance (Eq m) =&gt; Eq (Maybe m) where ... Most of the time, class constraints in class declarations are used for making a typeclass a subclass of another typeclass and class constraints in instance declarations are used to express requirements about the contents of some type. The :info command can be used to display information about a typeclass. Yes-No typeclass In some weakly typed languages, anything can be passed to a conditional expression. In JavaScript, non empty strings, and non 0 numbers are considered to be True. We could implement this in Haskell class YesNo a where yesno :: a -&gt; Bool instance YesNo Int where yesno 0 = False yesno _ = False instance YesNo [a] where yesno [] = False yesno _ = True instance YesNo Bool where yesno = id -- id is a standard library function which takes a parameter and returns the same thing instance YesNo (Maybe a) where yesno (Just _) = True yesno Nothing = False &gt; yesno $ length [] &gt; False &gt; yesno "test" &gt; True &gt; yesno "" &gt; False &gt; :t yesno &gt; Yesno :: (YesNo a) =&gt; a -&gt; Bool We can now create a function that mimics the if statement, but works with YesNo values yesnoIf :: (YesNo y) =&gt; y -&gt; a -&gt; a -&gt; a yesnoIf yesnoVal yesResult noResult = if yesno yesnoVal then yesResult else noResult The Functor typeclass class Functor f where fmap :: (a -&gt; b) f a -&gt; f b The Functor typeclass defines a single function, fmap. f is not a concrete type, but a type constructor that takes one parameter. fmap takes a function from one type to another and a functor applied with one type and returns a functor applied with another type. The list is an instance of the Functor typeclass instance Functor [] where fmap = map We didn\u2019t write instance Functor [a] because from fmap :: (a -&gt; b) -&gt; f a -&gt; f b we see that the f has to be a type constructor that takes one type. [a] is a concrete type, while [] is a type constructor that takes one type. Types that can act like a box can be functors. Maybe can act like a box, holding Just &lt;something&gt; or Nothing. instance Functor Maybe where fmap f (Just x) = Just (f x) fmap f Nothing = Nothing Again we did not specify a type. Functor wants a type constructor that takes one type and not a concrete type. The Tree a can be mapped over and made an instance of Functor. instance Functor Tree where fmap f EmptyTree = EmptyTree fmap f (Node x leftsub rightsub) = Node (f x) (fmap f leftsub) (fmap f righsub) The fmap function for Tree recursively applies f to each of the items in the Tree. &gt; fmap (*4) (foldr treeInsert EmptyTree [5,7,3,2,1,7]) &gt; Node 28 (Node 4 EmptyTree (Node 8 EmptyTree (Node 12 EmptyTree (Node 20 EmptyTree EmptyTree)))) EmptyTree Now consider Either a b. The Functor typeclass wants a type constructor that takes only one type parameter, but Either takes two. We can partially apply Either by feeding it only one parameter, so that it has one free parameter. instance Functor (Either a) where fmap f (Right x) = Right (f x) fmap f (Left x) = Left x Either a is a type constructor that takes one parameter. The type signature for this specific fmap will be (b -&gt; c) -&gt; Either a b -&gt; Either a c In the implementation, we mapped in the case of a Right value constructor but not in the case of a Left. If we wanted to map one function over both of them, a and b would have to be the same type. Maps from Data.Map can also be made a functor because they hold values. fmap will map a function v -&gt; v\' over a map of type Map k v and return a map of type Map k v\'. Functors should obey some laws. fmap id = id fmap (g . f) = fmap g . fmap f Kinds Functions are also values because we can pass them etc. Types are like labels carried by values so that we can reason about them. Types have their own labels called kinds. A kind is something like the type of a type. &gt; :k Int &gt; Int :: * A * means that the type is a concrete type, a type without type parameters. &gt; :k Maybe &gt; Maybe :: * -&gt; * The Maybe constructor takes one concrete type, and then returns a concrete type. &gt; :k Maybe Int &gt; Maybe Int :: * We use :k on a type to get its kind, just like :t on a value to get its type. &gt; :k Either &gt; Either :: * -&gt; * -&gt; * &gt; :k Either Int &gt; Either Int :: * -&gt; * Either takes two concrete types as type parameters to produce a concrete type. A partially applied either takes a single concrete type to produce a concrete type. class Tofu t where tofu :: j a -&gt; t a j Because j a is used as the type of a value that the tofu function takes as its parameter, j a has to have a kind of *. We assume * for a so we can infer that j has to have a kind of * -&gt; *. We see that t has to produce a concrete value to, and that it takes two types. Knowing that a has a kind of * and j has a kind of * -&gt; *, we infer that t has to have a kind of * -&gt; (* -&gt; *) -&gt; *. So, it takes a concrete type (a), a type constructor that takes one concrete type (j) and produces a concrete type. data Frank a b = Frank {frankField :: b a} deriving (Show) This type has a kind of * -&gt; (* -&gt; *) -&gt; *. Fields in algebraic data types are made to hold values, so the must be of kind *. We assume * for a, which means that b takes one type parameter and so its kind is * -&gt; *. We now see that Frank has a kind of * -&gt; (* -&gt; *) -&gt; *. &gt; :t Frank {frankField = Just "String"} &gt; Frank {frankField = Just "String"} :: Frank [Char] Maybe &gt; :t Frank {frankField = "String"} &gt; Frank {frankField = "String"} :: Frank Char [] Because frankField has a type of form a b, its values must have types that are of a similar form as well. They can be Just "String", which has a type of Maybe [Char], or they can have a value of [\'S\', \'t\', \'r\', \'i\', \'n\', \'g\'] which has a type of [Char]. Making Frank an instance of Tofu is quite simple. tofu takes a j a, and returns a type of t a j instance Tofu Frank where tofu x = Frank x &gt; tofu (Just \'a\') :: Frank Char Maybe &gt; Frank {frankField = Just \'a\'} &gt; tofu ["HELLO"] :: Frank [Char] [] &gt; Frank {frankField = ["HELLO"]} This has no real use. A more complicated type is: data Barry t k p = Barry { yabba :: p, dabba :: t k} Now we want to make it an instance of Functor. Functor wants types of kind * -&gt; * It is safe to assume that p is a concrete type, and thus has a kind of *. For k, we assume *, and so t has a kind of * -&gt; *. Barry has a kind of (* -&gt; *) -&gt; * -&gt; * -&gt; *. Now we can make this type a part of Functor. We have to partially apply the first two type parameters, so that we are left with * -&gt; *. This means that the start of the instance declaration will be instance Functor (Barry a b) where. Considering fmap specifically for Barry, it would have type fmap :: (a -&gt; b) -&gt; Barry c d a -&gt; Barry c d b when the Functor\u2019s f is replaced with Barry c d. instance Functor (Barry a b) where fmap f (Barry {yabba = x, dabba = y}) = Barry {yabba = f x, dabba = y} Input and output The function putStrLn prints a string &gt; :t putStrLn &gt; putStrLn :: String -&gt; IO () putStrLn takes a string and returns an IO action, that has a result type of (). An IO action is something that, when performed, will carry out an action with a side-effect, and will also contain some kind of return value. Printing a string doesn\u2019t have a meaningful return value, so an empty tuple is returned. An IO action will be performed when we give it a name of main and then run our program. main = do putStrln "Hello, what is your name?" name &lt;- getLine putStrLn ("Hello" ++ name) main always has a type signature of main :: IO &lt;type&gt; where &lt;type&gt; is some concrete type. By convention, we do not usually specify a type declaration for main. getLine reads a line from the input, it has a type getLine :: IO String. The line name &lt;- getLine can be read as perform the IO action and then bind its result to name. As getLine has a type IO String, name will have a type of String. We can only take the data from getLine with &lt;- from within another IO action. getLine is impure because its result value is not guaranteed to be the same when performed twice. In a do block, the last action cannot be bound to a name. IO actions will only be performed when they are given a name of main or when they are inside a bigger IO faction that we composed with a do block. main = do line &lt;- getLine if null line then return () else do putStrLn $ reverseWords line main reverseWords :: String -&gt; String reverseWords = unwords . map reverse . words The program above reads input and reverses it until a blank line is input. In an IO do block, ifs have to have a form of if condition then IO action else IO action. Because we have to do exactly one IO action after the else, we use a do block to glue together two IO actions into one. Haskell return While return in most languages ends execution of a method or subroutine, in Haskell (IO actions specifically), it makes an IO action out of the pure value. Using return does not cause the IO do block to end execution. All these returns do is make IO actions that don\u2019t do anything. We can use return in combination with &lt;- to bind to names. main = do a &lt;- return "String" b &lt;- return "gnirtS" putStrLn $ a ++ " " ++ b When dealing with IO blocks we mostly use return either because we need to create an IO action that does not do anything or because we do not want the IO action that is made up from a do block to have the result value of its last action. IO functions putStr takes a string as a parameter and returns an IO action that will print without a newline putChar takes a character as a parameter and returns an IO action that will print it print takes a value of a type that is an instance of Show, and prints it getChar an IO action that reads a character form input. Reading does not happen until the user presses the enter key when is found in Control.Monad. In a do block it appears like a control flow statement, but it is a function. It takes a boolean value and an IO action. If the boolean value is True, it returns the same IO action passed to it, otherwise it returns the return () action. sequence takes a list of IO actions and returns an IO action which will perform all of the Io actions in the list. sequence :: [IO a] -&gt; IO [a] mapM and mapM_ mapM takes a function and a list, maps the function over the list and then sequences it, mapM_ does the same except that it throws away the result later. mapM_ is used when we do not care what result our sequenced IO actions have forever located in Control.Monad, takes an IO action and returns an IO action that repeats the IO action forever forM located in Control.Monad, is like mapM except that it has its parameters switched around. The first parameter is the list and the second is the function to map over that list, which is then sequenced import Control.Monad main = do colors &lt;- forM [1,2,3,4] (\\a -&gt; do putStrLn $ "Which color do you associate with the number " ++ show a ++ "?" color &lt;- getLine return color) putStrLn "The collors that you associate with 1, 2, 3, and 4 are: " mapM putStrLn colors The (\\a -&gt; do ...) is a function that takes a number and returns an IO action. We have to surround it with parentheses, otherwise the lambda thinks the last two IO actions below to it. We do return color in the inside do block. We do that so that the IO action which the do block defines has the result of our color contained within it. We could have left the last line as getLine. The forM called with its two parameters, produces an IO action, whose result we bind to colors. colors is just a list of strings. At the end we print out those strings with mapM putStrLn colors. forM can be thought of as meaning \u2018make an IO action for every element in this list, perform those actions and bind their results to something\u2019. Files and streams getContents is an IO action that reads everything from the standard input until it encounters an end-of-file character. Its type is getContents :: IO String. getContents does lazy IO. The pattern of getting some string from the input, transforming it with a function, and then outputting the result is so common that there exists a function for it. interact takes a function of type String -&gt; String as a parameter and returns an IO action that will take some input run that function on it and then print out the function\u2019s result. main = interact shortLinesOnly shortLinesOnly :: String -&gt; String shortLinesOnly input = let allLines = lines input shortLines = filter (\\line -&gt; length line &lt; 10) allLines result = unlines shortLines in result We could write thie in a less readable manner main = interact $ unlines . filter ((&lt;10) . length) . lines interact can be used to make programs that are piped some contents into them and then dump some result out, or it can be used to make programs that appear to take a line of input from the user, give back some result and then take another line and so on. respondPalindromes contents = unlines (map (\\xs -&gt; if isPalindrome xs then "palindrome" else "not a palindrome") (lines contents)) where isPalindrome xs = xs == reverse xs main = interact respondPalindromes openFile has a type signature openFile :: FilePath -&gt; IOMode -&gt; IO Handle FilePath is a type synonym for String. IOMode is a type defined as data IOMode = ReadMode | WriteMode | AppendMode | ReadWriteMode The function returns an IO action that will open the specified file in the specified mode. If we bind that action to something we get a Handle. A value of type Handle represents where the file is. hGetContents takes a Handle and returns an IO String, an IO action that holds as its results the contents of the file. Files handles must be closed with hClose, which returns an IO action that closes the file. withFile has a type signature withFile :: FilePath -&gt; IOMode -&gt; (Handle -&gt; IO a) -&gt; IO a. It takes a path to a file, an IOMode and a function that takes a handle and returns some IO actions. It returns an IO action that will open the file, do something with it and then close it. import System.IO main = do withFile "test.txt" ReadMode (\\handle -&gt; do contents &lt;- hGetContents handle putStr contents) An alternate withFile could be written as withFile\' :: FilePath -&gt; IOMode -&gt; (Handle -&gt; IO a) -&gt; IO a withFile\' path mode f = do handle &lt;- openFile path mode result &lt;- f handle hClose handle return result hGetLine, hPutStr, hPutStrLn, hGetChar, work like their counterparts without the h, except that they take a handle as a parameter and operate on that specific file instead of operating on standard input or output. readFile has a type signature readFile :: FilePath -&gt; IO String. It lazily loads a file as a string. As there is no handle, it does not have to be closed manually. writeFile has a type signature of writeFile :: FilePath -&gt; String -&gt; IO (). It takes a path to a file and a string to write to that file and returns an IO action that will do the writing. If a file exists already, its contents will be erased. appendFile has a type signature just like writeFile, but it does not erase the pre-existing file. hFlush takes a handle and returns an IO action that will flush the buffer of the file associated with the handle. This causes any items buffered for output to be immediately sent to the operating system openTempFile Takes a path to a temporary directory and a template name for a file and opens a temporary file. Calling openTempFile "." "temp" will open a temporary file in the current directory with the name \u201ctemp\u201d plus some random characters. removeFile takes a path and deletes it renameFile renames a file at a path Command line arguments The System.Environment module as IO actions for dealing with arguments. getArgs has type getArgs :: IO [String]. getProgName has a type of getProgName :: IO String import System.Environment import Data.List main = do args &lt;- getArgs progName &lt;- getProgName putStrLn "The arguments are: " mapM putStrLn args putStrLn "The program name is: " putStrLn progName $ ./arg-test first second third "multi word argument" The arguments are: first second third multi word arguments The program name is: arg-test TODO We can now write a program to manage tasks. View tasks Add tasks Delete tasks import System.Environment import System.Directory import System.IO import Data.List dispatch :: [(String, [String] -&gt; IO ())] dispatch = [ ("add", add) , ("view", view) , ("remove", remove) ] We now need to define main, add, view, and remove. main = do (command:args) &lt;- getArgs let (Just action) = lookup command dispatch action args First we get the arguments, and split them into the command and its arguments. We then look up our command in the dispatch list, and call it with the arguments. add :: [String] -&gt; IO () add [fileName, todoItem] = appendFile fileName (todoItem ++ "\\n") view :: [String] -&gt; IO () view [fileName] = do contents &lt;- readFile fileName let todoTasks = lines contents numberedTasks = zipWith (\\n line -&gt; show n ++ " - " ++ line) [0..] todoTasks putStr $ unlines numberedTasks remove :: [String] -&gt; IO () remove [fileName, numberString] = do handle &lt;- openFile fileName ReadMode (tempNam, tempHandle) &lt;- openTempFile "." "temp" contents &lt;- hGetContents handle let number = read numberString todoTasks = lines contents newTodoItems = delete (todoTasks !! number) todoTasks hPutStr tempHandle $ unlines newTodoItems hClose handle hClose tempHandle removeFile fileName rename tempName fileName We opened the file, added a temporary file, deleted the line with the index, wrote the result to a temporary file, removed the original file, and renamed the temporary file to the original file name. Randomness The System.Random module has all the functions needed for randomness. random has type random :: (RandomGen g, Random a) =&gt; g -&gt; (a, g) The RandomGen typeclass is for types that can act as sources of randomness. The Random typeclass is for things that can take random values. System.Random exports a random generator called StdGen. To manually make a random generator, use the mkStdGen function, which takes an Int. &gt; random (mkStdGen 100) :: (Int, StdGen) &gt; (-1352021624,651872571 1655838864) The first component of the tuple is our random number, whereas the second component is a textual representation of our new random generator. We use the type annotation to get different types. &gt; random (mkStdGen 949488) :: (Float, StdGen) &gt; (0.8938442,1597344447 1655838864) &gt; random (mkStdGen 949488) :: (Bool, StdGen) &gt; (False,1485632275 40692) &gt; random (mkStdGen 949488) :: (Integer, StdGen) &gt; (1691547873,1597344447 1655838864) We use the returned generator to produce new random values. threeCoins :: StdGen -&gt; (Bool, Bool, Bool) threeCoins gen = let (first, newGen) = random gen (second, newGen\') = random newGen (third, newGen\'\') = random newGen\' in (first, second, third) randoms takes a generator and returns an infinite sequence of values based on that generator It could be written as randoms\' :: (RandomGen g, Random a) =&gt; g -&gt; [a] randoms\' gen = let (value, newGen) = random gen in value:randoms\' newGen We could generate a finite stream of random numbers as follows finiteRandoms :: (RandomGen g, Random a, Num n) =&gt; n -&gt; g -&gt; ([a], g) finiteRandoms 0 gen = ([], gen) finiteRandoms n gen = let (value, newGen) = random gen (restOfList, finalGen) = finiteRandoms (n-1) newGen in (value:restOfList, finalGen) randomR creates a random value within a given range, it has type signature randomR :: (RandomGen g, Random a) :: (a, a) -&gt; g -&gt; (a, g) randomRs produces a stream of random values defined within a range In order to generate different random numbers each time the program is run, we use getStdGen which has a type of IO StdGen. It asks the system for a good random number generator and stores that in a \u201cglobal generator\u201d. Another method is newStdGen, which splits the current generator into two generators, updating the global generator with one of them and encapsulating the other as its result. ByteStrings Processing files as strings tends to be slow. ByteStrings are similar to lists, except that each element is one byte, and laziness is handled differently. Strict ByteStrings reside in Data.ByteString and they are not lazy. There is less overhead because there are no thunks, but they use more memory which might not be necessary. Lazy ByteStrings reside in Data.ByteString.Lazy. They are lazy, but not as lazy as lists. In a list there are as many thunks as there are elements. ByteStrings are stored in chunks of 64K, each of which have thunk. pack has type signature pack :: [Word8] -&gt; ByteString. It takes a list of bytes of type Word8 and returns a ByteString unpack converts a ByteString to a list of bytes fromChunks takes a list of strict ByteStrings and converts them to a lazy ByteString toChunks takes a lazy ByteString and converts it into a list of strict ones The ByteString version of : is called cons. It takes a byte and a ByteString and puts the byte at its beginning. It is lazy and will make a new chunk even if the first chunk in the ByteString is not full. cons\' is strict and will not make a new chunk unless necessary. empty makes an empty ByteString The ByteString module has other functions analogous to those in Data.List. Exceptions Despite having expressive types that support failed computations, Haskell still has support for exceptions because they make more sense in IO contexts. Pure code can throw exceptions, but they can only be caught in the IO part of the code. This is because you do not know when (or if) anything will be evaluated in pure code, because it is lazy and does not have a well-defined order of execution, whereas IO code does. IO exceptions IO exceptions are exceptions that are caused when there is an error while communicating outside of the program. When opening a file we can use doesFileExist from System.Directory before opening the file. To handle IO exceptions we can use the catch function from System.IO.Error which has type signature catch :: IO a -&gt; (IOError -&gt; IO a) -&gt; IO a. The first parameter is an IO action, the second is a handler function which handles the IOError. import System.Environment import System.IO import System.IO.Error main = toTry `catch` handler toTry :: IO () toTry = do (fileName:_) &lt;- getArgs contents &lt;- readFile fileName putStrLn $ "The file has " ++ show (length (lines contents)) ++ " lines." handler :: IOError -&gt; IO () handler e = putStrLn "Error reading file" There are several predicates that act on IOError isAlreadyExistsError isDoesNotExistError isAlreadyInUseError isFullError isEOFError isIllegalOperation isPermissionError isUserError System.IO.Error also exports functions that enable us to ask our exceptions for some attributes. Each function starts with ioe, and can be found here. Functionally solving problem s Reverse Polish notation calculator We want to take a string as a parameter and produce a numeric value as a result solveRPN :: (Num a) =&gt; String -&gt; a. Take the RPN string \u201c10 4 3 + 2 * -\u201c. We push 10 to the stack [10] We push 4 to the stack [10, 4] We push 3 to the stack [10, 4, 3] We reach \u2018+\u2019 so we pop the top two items from the stack, apply the operator and push the result to the stack [10, 7] We push 2 to the stack [10, 7, 2] We reach \u2018*\u2019 so we pop the top two items from the stack, apply the operator and push the result to the stack [10, 14] We reach the \u2018-\u2018 so we pop the top two items from the stack, apply the operator and push the result to the stack [-4] As we are effectively traversing a list form left to right and building up a result, we can apply a fold. The function may look like import Data.List solveRPN :: (Num a) =&gt; String -&gt; a solveRPN expression = head (foldl foldingFunction [] (words expression)) where foldingFunction stack item = ... The accumulator is our stack, which is initially empty. We are folding over the input string split into words. solveRPN :: (Num a, Read a) =&gt; String -&gt; a solveRPN = head . foldl foldingFunction [] . words where foldingFunction (x:y:ys) "*" = (x * y):ys foldingFunction (x:y:ys) "+" = (x + y):ys foldingFunction (x:y:ys) "-" = (y - x):ys foldingFunction xs numberString = read numberString:xs This function can be easily modified to support more operators. Pathfinding There are two main roads and a number of regional roads crossing between them. It takes a fixed amount of time to travel from one point to another. A-50-A1--5-A2-40-A3-10- | | | 30 20 25 | | | B-10-B1-90-B2--2-B3--8- The input for this case can be represented as 50 10 30 5 90 20 40 2 25 10 8 0 The input file can be read in threes. Finding the shortest path to the first crossroad is trivial. We can see that it is faster to move from B to B1 and then to A1 than to travel from A to A1. We now know that the fastest path to A1 is 40, and the fastest path to B1 is 10. We can now consider A2 and B2. A2 can be reached either by moving forward from A1, or moving forward from B1 and then crossing over. It takes 40 to get to A1, and then 5 from A1 to A2, for a total of 45 which is less than the total of 110 from B to B1 to B2 to A2. Considering B2, it takes 65 to travel from A1 to A2 to B2, and 100 to travel from B to B1 to A2. We can repeat this process until we reach the end. Once we get to the end the faster route is the optimal path. We need to represent the road system with Haskell\u2019s data types. data Section = Section { getA :: Int, getB :: Int, getC :: Int} deriving (Show) type RoadSystem = [Section] Section is a simple algebraic data type that holds three integers for the lengths of its three road parts. Our road system can now be represented as follows system :: RoadSystem system = [Section 50 10 30, Section 5 90 20, Section 40 2 25, Section 10 8 0] data Label = A | B | C deriving (Show) type Path = [(Label, Int)] We will create a function with a type declaration optimalPath :: RoadSystem -&gt; Path. We will walk over the list with the sections from left to right and keep the optimal path on A and optimal path on B as we go along. We will accumulate the best path as we walk over the list, left to right. We repeatedly check the optimal step. Consider Section 50 10 30. We conclude that the new optimal path to A1 is [(B, 10),(C, 30)] and the optimal path to B1 is [(B, 10)]. Considering this step as a function it has a type signature (Path, Path) -&gt; Section -&gt; (Path, Path). roadStep :: (Path, Path) -&gt; Section -&gt; (Path, Path) roadStep (pathA, pathB) (Section a b c) = let priceA = sum $ map snd pathA priceB = sum $ map snd pathB forwardPriceToA = priceA + a crossPriceToA = priceB + b + c forwardPriceToB = priceB + b crossPriceToB = priceA + a + c newPathToA = if forwardPriceToA &lt;= crossPriceToA then (A,a):pathA else (C,c):(B,b):pathB newPathToB = if forwardPriceToB &lt;= crossPriceToB then (B,b):pathB else (C,c):(A,a):pathA in (newPathToA, newPathToB) optimalPath :: RoadSystem -&gt; Path optimalPath roadSystem = let (bestAPath, bestBPath) = foldl roadStep ([],[]) roadSystem in if sum (map snd bestAPath) &lt;= sum (map snd bestBPath) then reverse bestAPath else reverse bestBPath Functors, Applicative Functors, and Monoids IO is an instance of Functor. When we fmap a function over an IO action, we want to get back an IO action that does the same thing, but has our function applied over its result value. instance Functor IO where fmap f action = do result &lt;- action return (f result) The result of mapping over an IO action will be an IO action, so we use the do syntax to glue two actions and make a new one. We bind the value of action and then return f result, where return simply creates an IO action to present the result. main = do line &lt;- getLine let line\' = reverse line putStrLn $ "Reversed " ++ line\' Can be written with fmap as main = do line &lt;- fmap reverse getLIne putStrLn $ "Reversed" ++ line In the same way that we can apply a function to some value residing inside a Maybe, we can apply a function to something residing inside an IO. Another common instance of Functor is (-&gt;) r. The function type r -&gt; a can be written as (-&gt;) r a, so (-&gt;) r is a partial application, a type constructor which only takes one parameter and can therefore be an instance of Functor. In Control.Monad.Instances we can see the implementation of functions as Functors. instance Functor ((-&gt;) r) where fmap f g = (\\x -&gt; f (g x)) Considering fmap\u2019s type, fmap :: (a -&gt; b) -&gt; f a -&gt; f b, and replacing each of the f\u2019s we have fmap :: (a -&gt; b) -&gt; ((-&gt;) r a) -&gt; ((-&gt;) r b), and writing in infix we finally have fmap :: (a -&gt; b) -&gt; (r -&gt; a) -&gt; (r-&gt; b). Mapping a function over a function has to produce a function. This is function composition again. We pipe the output of r -&gt; a into a -&gt; b giving a function from r -&gt; b. This could be written as follows instance Functor ((-&gt;) r) where fmap = (.) We can call fmap as an infix function, making its resemblance to . clear. If we take a function a -&gt;b and return f a -&gt; f b this is called lifting a function. &gt; :t fmap (*2) &gt; fmap (*2) :: (Num a, Functor f) =&gt; f a -&gt; f a &gt; :t fmap (replicate 3) &gt; fmap (replicate 3) :: (Functor f) =&gt; f a -&gt; f a The expression fmap (*2) is a function that takes a functor f over numbers and returns a functor over numbers. That functor could be a list, a Maybe, or any other functor type. Applicative functors Applicative functors are represented by the Applicative typeclass found in Control.Applicative. &gt; :t fmap (++) (Just "string") &gt; fmap (++) (Just "string") :: Maybe ([Char] -&gt; [Char]) &gt; :t fmap compare (Just \'a\') &gt; fmap compare (Just \'a\') :: Maybe (Char -&gt; Ordering) &gt; :t fmap compare "List of characters." &gt; fmap compare "List of characters." :: [Char -&gt; Ordering] &gt; :t fmap (\\x y z -&gt; x + y / z) [3,4,5,6] &gt; fmap (\\x y z -&gt; x + y / z) [3,4,5,6] :: (Fractional a) =&gt; [a -&gt; a -&gt; a] If we map compare, which has a type of (Ord a) =&gt; a -&gt; a -&gt; Ordering over a list of characters, we get a list of functions of type Char -&gt; Ordering, because the funtion compare gets partially applied with the characters in the list. It is not a list of (Ord a) =&gt; a -&gt; Ordering function, because the first a that was applied was a Char so the second a must be of the same type. By mapping \u201cmultiple parameter\u201d functions over functors, we get functors which contain functions inside them. We can map functions that takes these functions as a parameter over them, because whatever is inside a functor will be given to the function that we\u2019re mapping over as its parameter. &gt; let a = fmap (*) [1,2,3,4] &gt; :t a &gt; a :: [Integer -&gt; Integer] &gt; fmap (\\f -&gt; f 9) a &gt; [9,18,27,36] If we have a functor value of Just (3 *) and another functor value of Just 5, and we wish to apply the function in the first Just to the value in the second, we would normally be stuck, as regular functors just support mapping regular functions over existing functors. We could pattern match against the Just constructor to get the function out, but we want a more general and abstract way of doing that. This is where Applicative is used. It provides two methods, pure, and &lt;*&gt;, without a default implementation for either of them. class (Functor f) =&gt; Applicative f where pure :: a -&gt; f a (&lt;*&gt;) :: f (a -&gt; b) -&gt; f a -&gt; f b The first line starts the definition of Applicative and introduces a class constant. It states that for a type constructor to be part of Applicative, it must first be part of Functor. The first method defined is pure. It plays the role of our applicative functor instance here. pure should take a value of any type and return an applicative functor with that value \u201cinside\u201d it. The &lt;*&gt; function has a similar type declaration to fmap. Whereas fmap takes a function and a functor and applies the function inside the functor, &lt;*&gt; takes a functor that has a function in it and another functor and \u201cextracts\u201d the function from the first functor and then maps it over the second one. instance Applicative Maybe where pure = Just Nothing &lt;*&gt; _ = Nothing (Just f) &lt;*&gt; something = fmap f something From the class definition we see that the f plays the role of the applicative functor should take one concrete type as a parameter, so we write instance Applicative Maybe where instead of instance Applicative (Maybe a) where. First, pure is defined. It is written as pure = Just because value constructors like Just are normal functions. We could also write pure x = Just x. Next, &lt;*&gt; is defined. We cannot extract a function from Nothing, so we pattern match and return nothing. If the first parameter is not a Nothing, then it is a Just with some function inside it. The function is extracted and fmap-ed over the second parameter. &gt; Just (+3) &lt;*&gt; Just 9 &gt; Just 12 &gt; pure (+4) &lt;*&gt; Just 10 &gt; Just 14 &gt; Just (++"string") &lt;*&gt; Nothing &gt; Nothing &gt; Nothing &lt;*&gt; Just "string" &gt; Nothing pure can be used when dealing with Maybe values in an applicative context, otherwise we can just use Just. With normal functors, a function can be mapped over a functor and then the result cannot be extracted in any general way, even if the result is a partially applied function. Applicative functors alow you to operate on several functors with a single function &gt; pure (+) &lt;*&gt; Just 3 &lt;*&gt; Just 5 &gt; Just 8 &gt; pure (+) &lt;*&gt; Just 3 &lt;*&gt; Nothing &gt; Nothing &lt;*&gt; is left associative, which means that pure (+) &lt;*&gt; Just 3 &lt;*&gt; Just 5 is the same as (pure (+) &lt;*&gt; Just 3) &lt;*&gt; Just 5. First the (+) function is put in a functor, which in this case is just a Maybe value, giving Just (+) &lt;*&gt; Just 3, the result of which is Just (3+), a partial application. Finally, the rest of the calculation is carried out to give Just 8. Applicative functors allows us to take a function that expects parameters that are not necessarily wrapped in functors and use that function to operate on several values that are in functor contexts. This is even more useful when we consider that pure f &lt;*&gt; x is equal to fmap f x, one of the applicative laws. pure puts a value in a default context. If we just put a function in a default context and then extract and apply it to a value inside another applicative functor, we did the same as mapping that function over that applicative functor. Control.Applicative therefore exports a function called &lt;$&gt;, which is just fmap as an infix operator. (&lt;$&gt;) :: (Functor f) =&gt; (a -&gt; b) -&gt; f a -&gt; f b f &lt;$&gt; x = fmap f x Using &lt;$&gt; the applicative style looks much cleaner. For regular values we might write f x y z, and for functors we write f &lt;$&gt; &lt;*&gt; x &lt;*&gt; y &lt;*&gt; z. &gt; (++) &lt;$&gt; Just "one" &lt;*&gt; Just "two" &gt; Just "onetwo" First (++), which has a type of [a] -&gt; [a] -&gt; [a], gets mapped over Just "one", resulting in a value of Just ("one"++) with a type of Maybe ([Char] -&gt; [Char]). Now the function is extracted form the Just and mapped over Just "two", resulting in Just "onetwo". List is also an instance of Applicative instance Applicative [] where pure x = [x] fs &lt;*&gt; xs = [f x | f &lt;- fx, x &lt;- xs] The minimal context for lists is []. pure takes a value and puts it in a singleton list, the minimal context for a single value. Considering &lt;*&gt; for the list type we have &lt;*&gt; :: [a -&gt; b] -&gt; [a] -&gt; b. This is written as a list comprehension which draws from both lists, applying the function to the values until one or both lists are emptied. &gt; [(*0), (+100), (^2)] &lt;*&gt; [1,2,3] &gt; [0,0,0,101,102,103,1,4,9] If we have a list of functions that takes two parameters, we can apply those functions between two lists &gt; [(+), (*)] &lt;*&gt; [1,2] &lt;*&gt; [3,4] &gt; [4,5,5,6,3,4,6,8] Or we can use a normal function &gt; (++) &lt;$&gt; ["abc", "def", "ghi"] &lt;*&gt; ["?", "!", "."] &gt; ["abc?", "abc!", "abc.", "def?", "def!", "def.", "ghi?", "ghi!", "ghi."] Another instance of Applicative is IO. instance Applicative IO where pure = return a &lt;*&gt; b = do f &lt;- a x &lt;- b return (f x) Since pure should place a value in a minimal context, it is just return. If &lt;*&gt; were specialised for IO it would have type (&lt;*&gt;) :: IO (a -&gt; b) -&gt; IO a -&gt; IO b. It would take an IO action that yeilds a function as its result and another IO action and create a new IO action from those that, when performed, first performs the first one to get the function and then performs the second one to get the value, and then it would yield that function applied to the return value as its result. instance Applicative ((-&gt;) r) where pure x = (\\_ -&gt; x) f &lt;*&gt; g = \\x -&gt; f x (g x) pure takes a value and creates a function that ignores its parameter and always returns that value. Calling &lt;*&gt; with two applictive functors results in an applicative functor, so if we use it on two functions, we get back a function. (+) &lt;$&gt; (+3) &lt;*&gt; (*100) makes a function that will use + on the results of (+3) and (*100) and return that. Another instance of Applicative is ZipList, which resides in Control.Applicative. Rather than applying each function to each value in a pair of lists, we might want to apply its function to the respective position in the second list. The ZipList a type was introduced because one type cannot have more than one instance. ZipList takes a single parameter, a list. instance Applicative ZipList where pure x = ZipList (repeat x) ZipList fs &lt;*&gt; ZipList xs = ZipList (zipWith (\\f x -&gt; f x) fx xs) &lt;*&gt; takes the parameters of the two ZipLists, performs a zipWith on them, and creates a new ZipList with the resulting list. ZipList a does not have a Show instance, so we have to use getZipList to extract the list. Control.Applicative defines a function liftA2 with a type of liftA2 :: (Applicative f) =&gt; (a-&gt;b-&gt;c) -&gt; f a -&gt; f b -&gt; f c, which is defined as liftA2 :: (Applicative f) =&gt; (a -&gt; b -&gt; c) -&gt; f a -&gt; f b -&gt; f c liftA2 f a b = f &lt;$&gt; a &lt;*&gt; b It applies a function between two applicatives, hiding the applicative style. We can say that liftA2 takes a normal binary function and promotes it to a function that operators on two functors. Applicative functor laws pure id &lt;*&gt; v = v pure (.) &lt;*&gt; u &lt;*&gt; v &lt;*&gt; w = u &lt;*&gt; (v &lt;*&gt; w) pure f &lt;*&gt; pure x = pure (f x) u &lt;*&gt; pure y = pure ($ y) &lt;*&gt; u The newtype keyword The newtype keyword is used when we want to take a type and wrap it in something to present it as another type. ZipList is defined as follows newtype ZipList a = ZipList { getZipList :: [a] } Instead of data, newtype is used. newtype is faster than data, as it does not have the overhead of wrapping and unwrapping when the program is running. When newtype is used, Haskell knows that you are just wrapping an existing type into a new type and can get rid of the wrapping and unwrapping. newtype can only have one value constructor and that value constructor can only have one field. We can use the deriving keyword with newtype to derive instances for Eq, Ord, Enum, Bounded, Show, and Read if the type that we are wrapping belongs to that type class to begin with. Using newtype to make type class instances We may want to make our types instances of certain typeclasses, but the type parameters may not match up for what we want to do. Suppose we want to make the tuple an instance of Functor such that when we fmap a function over the tuple, it gets applied to the first component of the tuple. fmap (+3) (1, 1) = (4, 1). To get around this we can newtype our tuple such that the second type parameter represents the type of the first component in the tuple newtype Pair b a = Pair { getPair :: (a, b) } Now we make it an instance of Functor instance Functor (Pair c) where fmap f (Pair (x, y)) = Pair (f x, y) We can pattern match on types defined with newtype. newtype laziness Consider the following type data BoolData = BoolData { getBoolData :: Bool } It has one value constructor, which has one field with type Bool. Now we define a function which takes a BoolData as an argument but ignores it. testFunction :: BoolData -&gt; String testFunction (BoolData _) = "string" Now we pass it undefined &gt; testFunction undefined &gt; Exception: Prelude.undefined Because types defined with the data keyword can have multiple value constructors, Haskell has to evaluate it when checking that it conforms to the (BoolData _) pattern. Instead of data, we now use newtype. &gt; testFunction undefined &gt; "string" When we use newtype, Haskell can internally represent the values of the new type in the same way as the original values. It does not have to add a wrapper around them, instead it only has to be aware of the values being of different types. Because Haskell knows that types made with the newtype keyword can only have one constructor, it does not have to evaluate the value passed to the function to make sure that it conforms to the pattern. Monoids Consider * which is a function that takes two numbers, and ++. For *, there is the value 1 which can be placed on either side of the operator such that the result is equal to the other parameter. For ++, there is [] which will achieve the same thing. We can see that * and 1, and ++ and [] share some properties The function takes two parameters The parameters and the returned value have the same type There exists such a value that doesn\u2019t change other values when used with the binary function There is another, less obvious, property which is shared between the functions. When we have three or more values and we want to use the binary function to reduce them to a single resultant value, the order in which we apply the binary function to the values does not matter. &gt; (3 * 2) * (8 * 5) &gt; 240 &gt; 3 * 2 * 8 * 5 &gt; 240 &gt; "abc" ++ ("def" ++ "ghi") &gt; "abcdefghi" &gt; "abc" ++ "def" ++ "ghi" &gt; "abcdefghi" This property is called associativity. A monoid, defined in Data.Monoid is when you have an associative binary function and a value that acts as an identity with respect to that function. class Monoid m where mempty :: m mappend :: m -&gt; m -&gt; m mconcat :: [m] -&gt; m mconcat = foldr mappend mempty Only concrete types can be made instance of Monoid, because the m in the type class definition does not take any type parameters. The first function is mempty. As it does not take any parameters it is not really a function, it is instead a polymorphic constant. mempty represents the identify value for a particular monoid. mappend is the binary function. It takes two values of the same type and produces a return value of that type. mconcat takes a list of monoid values and reduces them to a single value by doing mappend between the list\u2019s elements. It has default implementation which takes mempty as a starting value and folds right through the list. Monoid laws mempty `mappend` x = x x `mappend` mempty = x (x `mappend` y) `mappend` z = x `mappend` (y `mappend` z) The first two laws state that mempty has to act as the identity with repect to mappend and the third says that mappend has to be associative. Lists are monoids instance Monoid [a] where mempty = [] mappend = (++) Lists are an instance of the Monoid type class regardless of the type of the elements they hold. Other monoids Numbers can also be monoids with the + function and an identify value of 0. The Data.Monoid module exports two types for product and sum newtype Product a = Product { getProduct :: a } deriving (Eq, Ord, Read, Show, Bounded) instance Num a =&gt; Monoid (Product a) where mempty = Product 1 Product x `mappend` Product y = Product (x * y) Another type which can act like a monoid in two distinct but equally valid ways is Bool. The first is through the || function with an identity value of False. The second is through the &amp;&amp; function with an identify value of True. instance Monoid Ordering where mempty = EQ LT `mappend` _ = LT EQ `mappend` y = y GT `mappend` _ = GT instance Monoid a =&gt; Monoid (Maybe a) where mempty = Nothing Nothing `mappend` m = m m `mappend` Nothing = m Just m1 `mappend` Just m2 = Just (m1 `mappend` m2) Using monoids to fold data structures Because there are so many data structures that work nicely with folds, the Foldable type class was introduced. &gt; :t foldr &gt; foldr :: (a -&gt; b -&gt; b) -&gt; b -&gt; [a] -&gt; b &gt; :t Foldable.foldr &gt; Foldable.foldr :: (Foldable.Foldable t) =&gt; (a -&gt; b -&gt; b) -&gt; b -&gt; t a -&gt; b Whereas foldr takes a list and folds it up, the foldr in Data.Foldable accepts any type that can be folded up. &gt; F.foldl (+) 2 (Just 9) &gt; 11 &gt; F.foldr (||) False (Just True) &gt; True The Tree type defined earlier is data Tree a = Empty | Node a (Tree a) (Tree a) deriving (Show, Read, Eq) One way to to make Tree an instance of Foldable is to implement the type constructor,however an easier way is to implement the foldMap function. foldMap :: (Monoid m, Foldable t) =&gt; (a -&gt; m) -&gt; t a -&gt; m The first parameter is a function that takes a value of the type that our Foldable structure contains, denoted a, and returns a monoid vlaue. Its second parameter is a foldable structure that contains a value of type a. It maps that function over the foldable structure, thus producing a foldable structure that contains monoid values. Then, by doing mappend betwen those monoid values it joins them all into a single monoid value. instance F.Foldable Tree where foldMap f Empty = mempty foldMap (f Node x l r) = F.foldMap f l `mappend` f x `mappend` F.foldMap f r We are providing a function which takes an element of the tree and returns a monoid value. The function recursively traverses the tree and uses mappend to join the monoids together. Monads Monads are an extension of applicative functors. Suppose you have a value with a context, m a. How do you apply to it a function that takes a normal a and returns a value with a context. That is, applyting a function of type a -&gt; m b to a value of type m b. (&gt;&gt;=) :: (Monad m) =&gt; m a -&gt; (a -&gt; m b) -&gt; m b Monads are applicative functors that support the &gt;&gt;= function, called bind. Maybe Maybe is a monad. In this case &gt;&gt;= would take a Maybe a value and a function of type a -&gt; Maybe b and somehow apply the function to the Maybe a. Suppose we have a function \\x -&gt; Just (x+1) which takes a number, adds 1 to it, and wraps it in a Just. Now consider how we might feed a Maybe value to this function. If the Maybe is a Just value, we can take the value from the Just and apply the function to it. If the value is Nothing, then we say the result is nothing. applyMaybe :: Maybe a -&gt; (a -&gt; Maybe a) -&gt; Maybe b applyMaybe Nothing f = Nothing applyMaybe (Just x) f = f x The Monad type class class Monad m where return :: a -&gt; m (&gt;&gt;=) :: m a -&gt; (a -&gt; m b) -&gt; m b (&gt;&gt;) :: m a -&gt; m b -&gt; m b x &gt;&gt; y = x &gt;&gt;= \\_ -&gt; y fail :: String -&gt; m a fail msg = error msg The first function defined is return. It is the same as pure, taking a value and wrapping it in a minimal default context to hold the value. The second function is bind. It takes a monadic value and feeds it to a value that takes a normal value and returns a monadic value. The third function is &gt;&gt;. It is rarely implemented because it has a default implementation. The fourth function is fail. It is never used explicitly in code. Instead it is used by Haskell to enable failure in a special syntactic construct for monads. It ignores its input and returns a predetermined monadic value. instance Monad Maybe where return x = Just x Nothing &gt;&gt;= f = Nothing Just x &gt;&gt;= f = f x fail _ = Nothing We can use &gt;&gt;= repeatedly to handle computations of several Maybe a values. do notation do notation can also be used for any monad. Its principle is the same, combining together monadic values in sequence. Consider the following expression &gt; Just 3 &gt;&gt;= (\\x -&gt; Just "!" &gt;&gt;= (\\y -&gt; Just (show x ++ y))) &gt; Just "3!" In the outermost lambda, we feed Just "!" to the lambda \\y -&gt; Just (show x ++ y). Inside this lambda, y becomes "!". x is still 3 because we got it from the outer lambda. This is similar to the expression &gt; let x = y; y = "!" in show x ++ y &gt; "3!" The main differnce is that the values in the former are monadic, they have a failure context, and any of them can therefore be replaced with a failure value. The first example may be written as a function foo :: Maybe String foo = Just 3 &gt;&gt;= (\\x -&gt; Just "!" &gt;&gt;= (\\y -&gt; Just (show x ++ y))) this can instead be written foo :: Maybe String foo = do x &lt;- Just 3 y &lt;- Just "!" Just (show x ++ y) We have the ability to temporarily extract things from Maybe values without having to check if the Maybe values are Just or Nothing at each step. If any of the values are Nothing, the whole do expression will result in Nothing. In a do expression, every line is a monadic value. To inspect its result we use &lt;-. The list monad The list can be viewed as one value that is actually many values at the same time. &gt; (*) &lt;$&gt; [1,2,3] &lt;*&gt; [10,100,1000] &gt; [10,100,1000,20,200,2000,30,300,3000] The context of non-determinism translates very well to monads. instance Monad [] where return x = [x] xs &gt;&gt;= f = concat (map f xs) fail _ = [] As usual, return packages a value in the minimal context. &gt;&gt;= maps the function over the values in the list. Each of these calls will preserve the original context (a list), giving a list of lists, which are then concatenated back to a single list. &gt; map (\\x -&gt; [x,-x]) [3,4,5] &gt; [[3,-3],[4,-4],[5,-5]] Non determinism also supports failure. The empty list, [], is equivalent to Nothing. &gt; [] &gt;&gt;= \\x -&gt; ["bad","mad","rad"] &gt; [] &gt; [1,2,3] &gt;&gt;= \\x -&gt; [] &gt; [] We can also chain results in the same way as we did with Maybe values. When non-deterministic values are interacting, their computation can be viewed as a tree where every possible result in a list represents a separate batch. MonadPlus MonadPlus is the type class for monads that can also act as monoids. class Monad m =&gt; MonadPlus where mzero :: m a mplus :: m a -&gt; m a -&gt; m a mzero is synonymous with mempty in the Monoid typeclass and mplus corresponds to mappend. instance MonadPlus [] where mzero = [] mplus = (++) For lists, mzero represents a non-deterministic computation that has no results at all. mplus joins two non-deterministic values into one. guard :: (MonadPls m) =&gt; Bool -&gt; m () guard True = return () guard False = mzero The guard function takes a boolan value and if it is True, takes a () and puts it in a minimal default context that still succeeds. Otherwise, it makes a failed monadic value. &gt; guard (5 &gt; 2) :: Maybe () &gt; Just () &gt; guard (1 &gt; 2) :: Maybe () &gt; Nothing &gt; guard (5 &gt; 2) :: [()] &gt; [()] &gt; guard (1 &gt; 2) :: [()] &gt; [] guard can be used to filter out non-deterministic computations &gt; [ x | x &lt;- [1..50], \'7\' `elem` show x ] &gt; [7,17,27,37,47] &gt; [1..50] &gt;&gt;= (\\x -&gt; guard (\'7\' `elem` show x) &gt;&gt; return x) &gt; [7,17,27,37,47] The result using guard is the same as that from the list comprehension. &gt; guard (5 &gt; 2) &gt;&gt; return "string" :: [String] &gt; ["string"] &gt; guard (1 &gt; 2) &gt;&gt; return "string" :: [String] &gt; [] If guard succeeds, the result contained within it is an empty tuple. We use &gt;&gt; to ignore that empty tuple and present something else as the result. If guard fails, then so will the return later on, because feeding an empty list to a function with &gt;&gt;= always result in an empty list. The guard basically works as follows: If the boolean is False, produce a failure value Otherwise, produce a successful value with a dummy result of () inside it sevens :: [Int] sevens = do x &lt;- [1..50] guard (\'7\' `elem` show x) return x Without the return as the final line in the do statement, the resulting list would contain empty tuples.',
tags:"Notes Haskell Functional",url:"/Haskell-Notes"},{title:"Statistics Notes",text:"Short notes on the AQA statistics A level. Split into topics for each module and topic. SS02 Time series analysis Seasonal variation When asked for the type of variation Seasonal variation If the variations from the fit line appear to follow a pattern Random variation If they don\u2019t Moving averages and seasonal effects Moving averages For Centered moving average The average of the current moving average and the surrounding moving averages The seasonal effect is the average of the values of the difference between the actual values and the centered moving average. Take the centered moving average and subtract it from the actual value for each item in a group. Then calculate the average of these values. Estimation from seasonal effects Once the seasonal effects has been calculated the fit line can be used to find a value for a given time, and the seasonal effect can then be applied to this value to produce an estimate Sampling Simple random samples Assign a range of values to the data Choose random values from the number table, starting from a random position Each item has the same probability of being chosen. If the data is in sections, each section may not be represented. May not give correct representations of strata. Stratified random sampling There may often be factors which divide up the population into groups (strata), and we may expect the measurement of interest to vary among the different groups. This can be accounted for when we select a sample from the population in order that we obtain a sample that is representative of the population. We generally require that the proportion of each stratum in the sample should be the same as in the population. Stratified sampling techniques are generally used when the population is heterogeneous, or dissimilar, where certain homogeneous sub populations can be isolated. Some reasons for using stratified sampling over simple random sampling are: The cost per observation may be reduced Estimates of the population parameters may be wanted for each sub-population Increased accuracy at a given cost Cluster, quota, and systematic sampling Cluster sampling The data is is divided into separate groups. Then a simple random sample of clusters is selected from the population. The population is divided into groups, called clusters The researcher randomly selects clusters to include in the sample The number of observations within each cluster is known, and . One-stage sampling All of the elements within selected clusters are included in the sample Two-stage sampling A subset of elements within selected clusters are randomly selected for inclusion in the sample Sometimes, the cost per sample point is less for cluster sampling than for other sampling methods. Given a fixed budget, the researcher may be able to use a bigger sample with cluster sampling than with the other methods. When the increased sample size is sufficient to offset the loss in precision, cluster sampling may be the best choice. Application: Select a cluster grouping as a sampling frame Mark each cluster with a unique number Choose a sample of clusters applying probability sampling Quota sampling Quota sampling requires, that representative individuals are chosen from a specific subgroup Advantages: Primary collection can be done in a short time The application of quota sampling can save costs and time Quota sampling is not dependent on the presence of the sampling frames. Disadvantages: It is not possible to calculate the sampling error Other important characteristics may be disproportionately represented in the final sample group There is a potential for researcher bis and the quality of work may suffer due to researcher incompetency Systematic sampling A sampling method in which the first position in the data set is randomly chosen, and every position after this is also chosen Advantages: Allows the researcher to add a degree of system or process into the random selection Known and equal probability of selection The assurance that the population will be evenly sampled. Simple random sampling allows a clustered selection of subjects Disadvantages: The process of selection can interact with a hidden periodic trait within the population The process can also hide a periodic trait Discrete probability distributions Expectations and variance Poisson (Same as MS02) Interpretation of data Pie charts Line diagrams Box and whisker plots Frequency diagrams Scatter diagrams Histograms not required Hypothesis testing Tests for means Errors Type I error: Rejecting a true null hypothesis Type II error: Accepting a false null hypothesis If it says test. State the fucking hypotheses! Tests Test Details Case to reject \xa0 SS02 \xa0 \xa0 \xa0 Z/T test Determines whether two population means are different TV &gt; CV \xa0 SS03 \xa0 \xa0 \xa0 Contingency tables A test for independence CV &gt; TV \xa0 Sign test Test for difference in medians TV &lt; CV \xa0 Wilcoxon Test for difference in mean or median TV &lt; CV \xa0 Mann-Whitney Test for equality of population TV &lt; CV \xa0 Kruskal-Wallis Test for equality of population of two or more samples TV &gt; CV \xa0 Correlation coefficient Test for existence of correlation between two random variables TV &gt; SL \xa0 SS04 \xa0 \xa0 \xa0 Poisson Test for change in a Poisson variable TV &lt; SL \xa0 Proportion Test whether sample proportion represents the population TV &lt; SL \xa0 SS05 \xa0 \xa0 \xa0 Variance Tests a sample for a given population variance TV &gt; CV(Upper) or TV &lt; CV(Lower) \xa0 Variance equality of samples (F) Test for equality of the variances of the populations of two samples of two normally distributed random variables TV &gt; CV \xa0 Difference in mean (Two sample Z) Test for the difference in the means of two independent populations |TV| &gt; |CV| \xa0 Difference in mean (Two sample T) Test for the difference in the means of two independent populations with unknown variances |TV| &gt; |CV| \xa0 Goodness of fit Test for the fit of a sample to a particular distributio n TV &gt; CV \xa0 SS06 \xa0 \xa0 \xa0 Paired comparisons Analysis of the difference between pairs of values sampled from two normal populations TV &gt; CV \xa0 Analysis of variance An extension of F tests with more than 2 populations TV &gt; CV \xa0 Two way analysis of variance An analysis of variance which accounts for a second factor TV &gt; CV \xa0 Latin squares \xa0 \xa0 \xa0 SS03 Contingency tables State hypotheses (In context) i. : No assocation ii : Assocation Calculate the expected values. If any value is less than 5, merge the rows or columns Calculate the text statistic Find the critical value for degrees of freedom. This can either be done from the table or with If text , reject in context Yates\u2019 correction For a 2 by 2 table, Yates\u2019 correction is used. Rather than the corrected formula is Distribution free methods Test For Use case Sign test Median When Wilcoxon cannot be used as data is not symmetrical or is non-numeric Wilcoxon signed-rank test Median or Mean When a z or t test cannot be used Mann-Whitney U test Equality of populations of two samples There are two samples Kruskal-Wallis test Equality of populations of two or more samples There are more than two samples Sign test The sign test checks for a difference in the median value by comparing each pair. It does not require a symmetric distribution and could be used on non-numeric data so long as the data can be assigned to two groups (e.g. boolean values of opinions) State hypotheses i. that population medians are equal ii. : that population medians are not equal or Find the differences between each pair, ignoring any equal values Count the number of positive differences and the number of negative differences Find the value of Compare the value above with the significance level. If it is less, reject Wilcoxon Signed-rank test The Wilcoxon test is similar to the sign test except that it ranks the differences ignoring their signs. State the hypotheses i. Population average difference (in mean or median) of 0 ii. Population average difference not 0 Rank the absolutes of the differences, giving each rank the sign of its respective difference Calculate and , the sums of the positive and negative ranks respectively. Let Find the critical value, from the table Compare to , rejecting if is smaller Mann-Whitney U-test The Mann-Whitney U test tests whether two samples were taken from the same population. It is used when a t test cannot be applied as the data is not normal State the hypotheses i. The samples are from the same population, ii. The samples are from different populations, Rank the entire dataset and calculate the sum of the ranks for each set Calculate the test statistic for each set where is the sum of the ranks of the set and is the size of the set. Let Find the critical value for the significance level and the size of each data set If is less than the critical value, reject Kruskal-Wallis test The Kruskal-Wallis test is a non-parametric version of the ANOVA test. It determines a difference between samples State the hypotheses i. All samples are from the same population ii. Samples are from different populations Rank the entire dataset and calculate the sum of the ranks of each set Calculate the test statistic where is the sum of all samples sizes, and and are the rank sums and sizes of each sample Find the degrees of freedom, the number of samples minus one Calculate the critical value for the given significance level either from the tables or with If the test statistic is larger than the critical value, reject Correlation Spearman\u2019s Rank Correlation Coefficient Spearman\u2019s rank correlation coefficient is used when the data is ranked. The value is given by where is the difference between the rank of a pair of values, and is the (equal) size of each dataset Testing with the correlation coefficient A test can be carried out in order to determine whether there is or is not a correlation between two random variables. Assuming that the correlation coefficient, , is already known. State the hypotheses i. (independent) ii. (not-independent) Find the critical value from the table If the correlation coefficient is greater than the critical value, reject SS04 Linear combinations of independent normal variables If the letters and are variables and the letters and are constants then A linear combination of independent, normal variables will itself be normally distributed Given a normal distribution , if an event is given which is times then this new event has a distribution . The standard deviation of the new event is then . Given two normal distributions , and the normally distributed random variable has the distribution . Approximating distributions The purpose of making an approximation is: To reduce the amount of calculation To allow tables to be used where they otherwise could not To calculate confidence intervals The binomial distribution may be approximated by the Poisson distribution if and The conditions for the approximations are rules of theu,b. They are not shar dividing lines between good approximations and bad approximations The binomial distribution may be approximated by the normal distribution if and The Poisson distribution may be approximated by the normal distribution if Confidence intervals An estimate of a population standard deviation calculated from a random sample of size has degrees of freedom If is the mean of a random sample of size from a normal distribution with mean a confidence interval for is given by Further confidence intervals If is an observation from a Poisson distribution with mean then an approximate confidence interval for is given by , provided that is reasonably large, say If is an observation from a binomial distribution with parameters then an approximate confidence interval for is given by , provided is reasonably large, say Further hypothesis testing for means To carry out a hypothesis test for a mean based on a sample from a normal distribution with an unknown standard deviation: The test statistic is where Hypothesis tests for proportions and for the mean of a Poisson distribution To test hypotheses about a binomial population proportion, , either: a. Determine the cumulative binomial probability of State that the mean remains the same, and that it exhibits the expected change. Then find the probability that this value occurs, and reject if the probability is higher than the level of the test. b. use The hypotheses are then dealt with like a regular normal hypothesis test. To test hypotheses about a Poisson population mean , either a. Determine the cumulative Poisson probability of , or b. use SS05 Continuous probability distributions The random variables having probability density function where and are constants, it is said to follow a rectangular distribution The mean of is and the variance of is The exponential distribution has probability density function The exponential distribution with parameter has mean and standard deviation is known as the cumulative distribution function and is usually denoted For the exponential distribution with parameter , If and are two constants and , the probability that takes a value between and is The intervals between successive events from a Poisson distribution with mean are distributed according to the exponential distribution with parameter Estimation If denotes the variance estimate from a random sample of size from a normal population with variance of , then The distribution is not symmetric so both lower and upper percentage points need to be read from tables A confidence interval for a normal population variance, , is given by and Confidence limits for a normal population standard deviation, are found by taking the square root of those calculated for the population variance Hypothesis testing: one sample tests To test hypotheses about a normal population variance, or standard deviation , use To test hypotheses about a normal population with mean, , use Hypothesis testing: two-sample tests To test hypotheses about the equality of two normal population variances, or standard deviations, use To test hypotheses about the equality of (or given differece in) two normal population means, based upon independent random samples and known population variances use Note that for and the requirement for normal populations canbe relaxed and/or sample variances can be used as estimates of the population variances To test hypotheses about the equality of (or given difference in) two normal population means, based upon independent random samples and unknown but equal population variances use where Testing for goodness of fit may be approximated by a distribution provided that The s are frequenceies, The s are at least five, The classes form a sample space that is, every possible observation fits into one and only one class The number of degrees of freedom is the number of classes, minus the number of independent pieces of information derived from the s in order to calculate the s If there are classes and any necessary parameters are estimated from the data the number of degrees of is for a Poisson, binomial, or exponential distribution, and for a normal distribution SS06 Experimental design Experimental error is the effect of factors other than those controlled by the experimenter In a paired comparison, experimental error is reduced by applying both treatments to the same subjects or in the same conditions The purpose of randomisation is to eliminate bias Blocking is used to reduce experimental error by applying treatments (usually more than two) to the same subjects or in the same conditions If a new treatement is applied to an experimental group, a control group, which receives no treatment or the standard treatment, is needed to act as a measure of the effect of not applying the new treatment A placebo is a pill or treatment which contains no active ingredient In a blind trial subjects do not know whether they are receiving the treatment or a placebo In a double blind trial neither the subject nor the person administering the treatment knows whether a placebo or an active drug is being given Analysis of paired comparisons If and denote the mean and standard deviation, respectively, of a random sample of differences that can be assumed to be normally distributed with mean then Analysis of variance (ANOVA) The assumptions for the three models considered, one and two factor ANOVAs, and Latin square designs, are that: a. The observations are obtained independently and randomly from populations at each factor level (combination) b. These populations are (approximately) normally distributed with common variance $\\sigma^2$ c. When two or more factors are involved, there is no interaction between them One way ANOVA table Source of variation Sum of squares Degrees of freedom Mean square F ratio Between samples Within samples \xa0 Total \xa0 \xa0 Two way ANOVA table Source of variation Sum of squares Degrees of freedom Mean square F ratio Between rows Between columns \xa0 Error \xa0 Total \xa0 \xa0 Provided in the formulae booklet Statistical process control Statistical process control may be used when a large number of similar items are being produced. Its purpose is to give a signal when the process mean has moved away from the target value or when item-to-item variability has increased For control charts for means: Sample mean between warning limits- No action Sample mean between arning and action limits- Take another sample immediately. If new sample mean outside warning limits take action Sample mean outside action limits- Take action The warning limits are set at , and the action limits at , where is the target value, is the short-term standard deviation, and is the sample size Variability may be controlled by plotting the sample ranges or standard deviations on control charts. The limits for these charts are found by multiplying the process short-term standard deviation found by factors in the control charts for variability (Table 12) When the standard deviation must be estimated from a number of small samples the average sample range can be calculated and a factor from table 12 applied. Alternatively can be calculated for each sample and the formula evaluated If the tolerance width exceeds six standard deviations the process should be able to meet the tolerances consistently, provided the mean is kept on target For charts for proportion non-conforming providing is reasonably large: The warning limits are The action limits are Acceptance sampling Acceptance sampling may be applied to large batches of similar items. It is the process of deciding whether or not the batch is acceptable by testing a small sample of the items The operating characteristic for an acceptance sampling by attributes plan is a graph of probability of acceptance against proportion non-conforming in the batch The probabilities may be found from the binomial distribution provided the sample is random and the sample size is small compared to the batch In double sampling, the number of non-conforming items in the first sample will determine whether a decision is made immediately or whether it is delayed until a second sample has been inspected For acceptance sampling by variables the operating characteristic is a graph of probability of acceptance against batch mean MS03 Bayes\u2019 theorem Example Event P(A) P(B) C 0.3 0.8 D 0.5 0.1 E 0.2 0.4 After event A, event B occured. Find the probability that event E occured. Let F be the probability that event B occured. Linear combinations of random variables Covariance is a measure of the joint variability of two random variables. The covariance can be used to find the product moment correlation coefficient of two random variables: The variance can also be computed as Distributional approximations Mean and variance of binomial and Poisson distributions Proof of for binomial Proof of for binomial",tags:"Notes Statistics",url:"/Statistics-Notes"}]},tipuesearch_stop_words=["a","about","above","after","again","against","all","am","an","and","any","are","aren't","as","at","be","because","been","before","being","below","between","both","but","by","can't","cannot","could","couldn't","did","didn't","do","does","doesn't","doing","don't","down","during","each","few","for","from","further","had","hadn't","has","hasn't","have","haven't","having","he","he'd","he'll","he's","her","here","here's","hers","herself","him","himself","his","how","how's","i","i'd","i'll","i'm","i've","if","in","into","is","isn't","it","it's","its","itself","let's","me","more","most","mustn't","my","myself","no","nor","not","of","off","on","once","only","or","other","ought","our","ours","ourselves","out","over","own","same","shan't","she","she'd","she'll","she's","should","shouldn't","so","some","such","than","that","that's","the","their","theirs","them","themselves","then","there","there's","these","they","they'd","they'll","they're","they've","this","those","through","to","too","under","until","up","very","was","wasn't","we","we'd","we'll","we're","we've","were","weren't","what","what's","when","when's","where","where's","which","while","who","who's","whom","why","why's","with","won't","would","wouldn't","you","you'd","you'll","you're","you've","your","yours","yourself","yourselves"],tipuesearch_replace={words:[{word:"tip",replace_with:"tipue"},{word:"javscript",replace_with:"javascript"},{word:"jqeury",replace_with:"jquery"}]},tipuesearch_weight={weight:[{url:"http://www.tipue.com",score:20},{url:"http://www.tipue.com/search",score:30},{url:"http://www.tipue.com/is",score:10}]},tipuesearch_stem={words:[{word:"e-mail",stem:"email"},{word:"javascript",stem:"jquery"},{word:"javascript",stem:"js"}]},tipuesearch_related={searches:[{search:"tipue",related:"Tipue Search"},{search:"tipue",before:"Tipue Search",related:"Getting Started"},{search:"tipue",before:"Tipue",related:"jQuery"},{search:"tipue",before:"Tipue",related:"Blog"}]},tipuesearch_string_1="No title",tipuesearch_string_2="Showing results for",tipuesearch_string_3="Search instead for",tipuesearch_string_4="1 result",tipuesearch_string_5="results",tipuesearch_string_6="Back",tipuesearch_string_7="More",tipuesearch_string_8="Nothing found.",tipuesearch_string_9="Common words are largely ignored.",tipuesearch_string_10="Search too short",tipuesearch_string_11="Should be one character or more.",tipuesearch_string_12="Should be",tipuesearch_string_13="characters or more.",tipuesearch_string_14="seconds",tipuesearch_string_15="Searches related to",startTimer=(new Date).getTime();defer(function(){!function(e){e.fn.tipuesearch=function(t){var a=e.extend({contentLocation:"tipuesearch/tipuesearch_content.json",contextBuffer:60,contextLength:60,contextStart:90,debug:!1,descriptiveWords:25,highlightTerms:!0,liveContent:"*",liveDescription:"*",minimumLength:3,mode:"static",newWindow:!1,show:9,showContext:!0,showRelated:!0,showTime:!0,showTitleCount:!0,showURL:!0,wholeWords:!0},t);return this.each(function(){function t(e){var t=location.search,a=new RegExp("[?|&]"+e+"=([^&;]+?)(&|#|;|$)").exec(t)||[,""],n=a[1].replace(/\+/g,"%20");try{n=decodeURIComponent(n)}catch(e){n=unescape(n)}return n||null}function n(t,r){var l="",c=!1,u=!1,h=!0,d=0;found=[];var p=e("#tipue_search_input").val(),f=p.toLowerCase();f=e.trim(f),(f.match('^"')&&f.match('"$')||f.match("^'")&&f.match("'$"))&&(h=!1);var g=f.split(" ");if(h){f="";for(var m=0;m<g.length;m++){for(var y=!0,w=0;w<tipuesearch_stop_words.length;w++)g[m]==tipuesearch_stop_words[w]&&(y=!1,u=!0);y&&(f=f+" "+g[m])}f=e.trim(f),g=f.split(" ")}else f=f.substring(1,f.length-1);if(f.length>=a.minimumLength){if(h){if(r){for(var v=f,m=0;m<g.length;m++)for(var w=0;w<tipuesearch_replace.words.length;w++)g[m]==tipuesearch_replace.words[w].word&&(f=f.replace(g[m],tipuesearch_replace.words[w].replace_with),c=!0);g=f.split(" ")}for(var b=f,m=0;m<g.length;m++)for(var w=0;w<tipuesearch_stem.words.length;w++)g[m]==tipuesearch_stem.words[w].word&&(b=b+" "+tipuesearch_stem.words[w].stem);g=b.split(" ");for(var m=0;m<i.pages.length;m++){for(var x=0,T=i.pages[m].text,w=0;w<g.length&&("/"!=i.pages[m].url&&"/tags"!=i.pages[m].url);w++){if(a.wholeWords)var k=new RegExp("\\b"+g[w]+"\\b","gi");else var k=new RegExp(g[w],"gi");if(-1!=i.pages[m].title.search(k)){var S=i.pages[m].title.match(k).length;x+=20*S}if(-1!=i.pages[m].text.search(k)){var S=i.pages[m].text.match(k).length;x+=20*S}if(-1!=i.pages[m].tags.search(k)){var S=i.pages[m].tags.match(k).length;x+=10*S}if(-1!=i.pages[m].url.search(k)&&(x+=20),0!=x)for(var I=0;I<tipuesearch_weight.weight.length;I++)i.pages[m].url==tipuesearch_weight.weight[I].url&&(x+=tipuesearch_weight.weight[I].score);g[w].match("^-")&&(k=new RegExp(g[w].substring(1),"i"),-1==i.pages[m].title.search(k)&&-1==i.pages[m].text.search(k)&&-1==i.pages[m].tags.search(k)||(x=0))}0!=x&&(found.push({score:x,title:i.pages[m].title,desc:T,url:i.pages[m].url}),d++)}}else for(var m=0;m<i.pages.length;m++){var x=0,T=i.pages[m].text,k=new RegExp(f,"gi");if(-1!=i.pages[m].title.search(k)){var S=i.pages[m].title.match(k).length;x+=20*S}if(-1!=i.pages[m].text.search(k)){var S=i.pages[m].text.match(k).length;x+=20*S}if(-1!=i.pages[m].tags.search(k)){var S=i.pages[m].tags.match(k).length;x+=10*S}if(-1!=i.pages[m].url.search(k)&&(x+=20),0!=x)for(var I=0;I<tipuesearch_weight.weight.length;I++)i.pages[m].url==tipuesearch_weight.weight[I].url&&(x+=tipuesearch_weight.weight[I].score);0!=x&&(found.push({score:x,title:i.pages[m].title,desc:T,url:i.pages[m].url}),d++)}if(0!=d){if(a.showTitleCount&&0==o){var C=document.title;document.title="("+d+") "+C,o++}if(c&&(l+='<div id="tipue_search_warning">'+tipuesearch_string_2+" "+f+". "+tipuesearch_string_3+' <a id="tipue_search_replaced">'+v+"</a></div>"),1==d?l+='<div id="tipue_search_results_count">'+tipuesearch_string_4:(c_c=d.toString().replace(/\B(?=(\d{3})+(?!\d))/g,","),l+='<div id="tipue_search_results_count">'+c_c+" "+tipuesearch_string_5),a.showTime){l+=" ("+(((new Date).getTime()-startTimer)/1e3).toFixed(2)+" "+tipuesearch_string_14+")",a.showTime=!1}l+="</div>",found.sort(function(e,t){return t.score-e.score});for(var F=0,m=0;m<found.length;m++){if(F>=t&&F<a.show+t){if(l+='<a class="tipue_search_content_title" href="'+found[m].url+'"'+s+">"+found[m].title+"</a>",a.debug&&(l+='<div class="tipue_search_content_debug">Score: '+found[m].score+"</div>"),a.showURL){var A=found[m].url.toLowerCase();0==A.indexOf("http://")&&(A=A.slice(7)),l+='<div class="tipue_search_content_url"><a href="'+found[m].url+'"'+s+">"+A+"</a></div>"}if(found[m].desc){var N=found[m].desc;if(a.showContext){g=f.split(" ");var E=found[m].desc.toLowerCase().indexOf(g[0]);if(E>a.contextStart){var _=N.substr(E-a.contextBuffer),O=_.indexOf(" ");_=N.substr(E-a.contextBuffer+O),_=e.trim(_),_.length>a.contextLength&&(N="... "+_)}}if(h){g=f.split(" ");for(var w=0;w<g.length;w++)if(a.highlightTerms){var L=new RegExp("("+g[w]+")","gi");N=N.replace(L,"<h0011>$1<h0012>")}}else if(a.highlightTerms){var L=new RegExp("("+f+")","gi");N=N.replace(L,'<span class="tipue_search_content_bold">$1</span>')}var M="",W=N.split(" ");if(W.length<a.descriptiveWords)M=N;else for(var w=0;w<a.descriptiveWords;w++)M+=W[w]+" ";M=e.trim(M),"."!=M.charAt(M.length-1)&&(M+=" ..."),M=M.replace(/h0011/g,'span class="tipue_search_content_bold"'),M=M.replace(/h0012/g,"/span"),l+='<div class="tipue_search_content_text">'+M+"</div>"}}F++}if(a.showRelated&&h){w=0;for(var m=0;m<tipuesearch_related.searches.length;m++)f==tipuesearch_related.searches[m].search&&(c&&(p=f),w||(l+='<div class="tipue_search_related_title">'+tipuesearch_string_15+' <span class="tipue_search_related_bold">'+p+'</span></div><div class="tipue_search_related_cols">'),l+='<div class="tipue_search_related_text"><a class="tipue_search_related" id="'+tipuesearch_related.searches[m].related+'">',tipuesearch_related.searches[m].before&&(l+='<span class="tipue_search_related_before">'+tipuesearch_related.searches[m].before+"</span> "),l+=tipuesearch_related.searches[m].related,tipuesearch_related.searches[m].after&&(l+=' <span class="tipue_search_related_after">'+tipuesearch_related.searches[m].after+"</span>"),l+="</a></div>",w++);w&&(l+="</div>")}if(d>a.show){var q=Math.ceil(d/a.show),P=t/a.show;if(l+='<nav><div id="tipue_search_foot"><ul id="tipue_search_foot_boxes">',t>0&&(l+='<li role="navigation"><a class="tipue_search_foot_box" accesskey="b" id="'+(t-a.show)+"_"+r+'">'+tipuesearch_string_6+"</a></li>"),P<=2){var B=q;q>3&&(B=3);for(var w=0;w<B;w++)l+=w==P?'<li class="current" role="navigation">'+(w+1)+"</li>":'<li role="navigation"><a class="tipue_search_foot_box" id="'+w*a.show+"_"+r+'">'+(w+1)+"</a></li>"}else{var B=P+2;B>q&&(B=q);for(var w=P-1;w<B;w++)l+=w==P?'<li class="current" role="navigation">'+(w+1)+"</li>":'<li role="navigation"><a class="tipue_search_foot_box" id="'+w*a.show+"_"+r+'">'+(w+1)+"</a></li>"}P+1!=q&&(l+='<li role="navigation"><a class="tipue_search_foot_box" accesskey="m" id="'+(t+a.show)+"_"+r+'">'+tipuesearch_string_7+"</a></li>"),l+="</ul></div></nav>"}}else l+='<div id="tipue_search_warning">'+tipuesearch_string_8+"</div>"}else u?l+='<div id="tipue_search_warning">'+tipuesearch_string_8+". "+tipuesearch_string_9+"</div>":(l+='<div id="tipue_search_warning">'+tipuesearch_string_10+"</div>",1==a.minimumLength?l+='<div id="tipue_search_warning">'+tipuesearch_string_11+"</div>":l+='<div id="tipue_search_warning">'+tipuesearch_string_12+" "+a.minimumLength+" "+tipuesearch_string_13+"</div>");e("#tipue_search_content").html(l),e("html, body").animate({scrollTop:e("#tipue_search_content").offset().top+e("#tipue_search_content").height()-e(window).height()}),e("#tipue_search_replaced").click(function(){n(0,!1)}),e(".tipue_search_related").click(function(){e("#tipue_search_input").val(e(this).attr("id")),n(0,!0)}),e(".tipue_search_foot_box").click(function(){var t=e(this).attr("id"),a=t.split("_");n(parseInt(a[0]),a[1])})}var i={pages:[]};e.ajaxSetup({async:!1});var o=0;if("live"==a.mode)for(var r=0;r<tipuesearch_pages.length;r++)e.get(tipuesearch_pages[r]).done(function(t){var n=e(a.liveContent,t).text();n=n.replace(/\s+/g," ");var o=e(a.liveDescription,t).text();o=o.replace(/\s+/g," ");var s=t.toLowerCase().indexOf("<title>"),l=t.toLowerCase().indexOf("</title>",s+7);if(-1!=s&&-1!=l)var c=t.slice(s+7,l);else var c=tipuesearch_string_1;i.pages.push({title:c,text:o,tags:n,url:tipuesearch_pages[r]})});"json"==a.mode&&e.getJSON(a.contentLocation).done(function(t){i=e.extend({},t)}),"static"==a.mode&&(i=e.extend({},tipuesearch));var s="";a.newWindow&&(s=' target="_blank"'),t("q")&&(e("#tipue_search_input").val(t("q")),n(0,!0)),e("#search_form").submit(function(e){e.preventDefault()}),e(this).keyup(function(e){"13"==e.keyCode&&n(0,!0)})})}}(jQuery)}),$(document).ready(function(){$("#tipue_search_input").tipuesearch({wholeWords:!1,showURL:!1})});</script> </div> </body> </html>