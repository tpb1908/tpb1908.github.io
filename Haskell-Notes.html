<!DOCTYPE html> <html> <head> <meta charset="UTF-8"/> <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1"> <meta name="generator" content="Jekyll"> <title>Haskell Notes</title> <meta name="description" content="A minimal, responsive, ready to use blog template, built with Jekyll."> <style type="text/css">*{-webkit-box-sizing:border-box;-moz-box-sizing:border-box;box-sizing:border-box}html,body,h1,h2,h3,h4,h5,h6,p,ul,ol,li,img{margin:0;padding:0;border:0}html{background-color:#fff;font-size:16px;line-height:1.8;color:#333}@media(min-width:940px){html{font-size:18px}}body{max-width:1000px;margin:0 auto;padding:0 10px}a{color:#333;text-decoration:none;font-weight:700}a:hover,a:focus{color:#262626}.f-right{float:right}.f-left{float:left}.clear{clear:both}.parent{display:flex}.inner{align-self:center}.justify-center{justify-content:center}.justify-spaceBetween{justify-content:space-between}.w100{width:100%}.h100{height:100%}.wh100{width:100%;height:100%}.absolute{position:absolute}.relative{position:relative}.top{top:0}.bottom{bottom:0}.right{right:0}.left{left:0}body{font-family:"Roboto","Helvetica Neue","Helvetica","Arial",sans-serif;font-style:normal;font-weight:400;font-size:16px;color:#333}p,ul,ol{font-size:1em;line-height:1.8em;margin-bottom:1.5em}h1{font-size:2.25em;line-height:1.8em;padding:.33335em 0}h2{font-size:1.5em;line-height:1.8em;padding:1em 0 0 0}h3,h4,h5,h6{font-size:1.125em;line-height:1.8em;padding:.66667em 0}blockquote{font-style:italic;margin:1.5em;-webkit-border-radius:4px;-moz-border-radius:4px;-ms-border-radius:4px;border-radius:4px;background-color:#f2f2f2;padding:0 1.5em}blockquote p,blockquote ul,blockquote ol{padding:1.5em 0}@media(min-width:940px){p,ul,ol{font-size:1em;line-height:1.8em;margin-bottom:1.3334em}h1{font-size:2.6667em;line-height:1.8em;padding:.25em 0}h2{font-size:2em;line-height:1.8em;padding:.66667em 0 0 0}h3,h4,h5,h6{font-size:1.3334em;line-height:1.8em;padding:.5em 0}blockquote{font-style:italic;margin:1.3334em;-webkit-border-radius:4px;-moz-border-radius:4px;-ms-border-radius:4px;border-radius:4px;background-color:#f2f2f2;padding:0 1.33334em}blockquote p,blockquote ul,blockquote ol{padding:1.33334em 0}}#nav a,#nav-left a{display:block;color:#333;padding:.33334em 0;font-size:1.5em;font-weight:400}@media(min-width:940px){#nav a,#nav-left a{font-size:1em}}#nav a:hover,#nav-left a:hover{background-color:rgba(13,13,13,0.6)}#nav span,#nav-left span{font-weight:200}#nav{width:14rem;position:fixed;background-color:#fff;top:0;bottom:0;right:-14rem;color:#fff;opacity:.95;-webkit-transition:all .3s ease-in;-moz-transition:all .3s ease-in;-ms-transition:all .3s ease-in;transition:all .3s ease-in;z-index:1;padding:72px 0;text-align:center}#nav-left{width:14rem;position:fixed;background-color:#fff;top:0;bottom:0;left:-14rem;color:#fff;opacity:.95;-webkit-transition:all .3s ease-in;-moz-transition:all .3s ease-in;-ms-transition:all .3s ease-in;transition:all .3s ease-in;z-index:1;padding:72px 0;text-align:center}#nav.menu-open{-webkit-transform:translateX(-14rem);-moz-transform:translateX(-14rem);-ms-transform:translateX(-14rem);transform:translateX(-14rem);width:100%;z-index:100}@media(min-width:940px){#nav.menu-open{width:30%}}#nav-left.menu-open-left{-webkit-transform:translateX(14rem);-moz-transform:translateX(14rem);-ms-transform:translateX(14rem);transform:translateX(14rem);width:100%;z-index:100}@media(min-width:940px){#nav-left.menu-open-left{width:30%}}@media(max-width:940px){#nav-links{display:none}}#nav-links a{padding-left:10px;color:#333;font-weight:300}#nav-list:after{display:block;content:'';width:5rem;height:1px;margin:23px auto;background-color:#333}#nav-menu{display:block;position:fixed;top:35px;right:25px;z-index:10;height:24px;z-index:500}@media(min-width:940px){#nav-menu{display:none}}#nav-menu-left{display:block;position:fixed;top:35px;left:25px;z-index:10;height:24px;z-index:500}@media(min-width:940px){#nav-menu-left{display:none}}#menu{height:4px;width:1.5em;background-color:#333;margin-top:8px}#menu:after,#menu:before{content:"";display:block;position:relative;height:4px;width:1.5em;background-color:#333;transition:all .3s ease-in}#menu:before{top:-8px}#menu:after{top:4px}#menu.btn-close{background:0}#menu.btn-close:before{top:0;-webkit-transform:rotate(-45deg);-moz-transform:rotate(-45deg);-ms-transform:rotate(-45deg);transform:rotate(-45deg);background-color:#333}#menu.btn-close:after{top:-4px;-webkit-transform:rotate(45deg);-moz-transform:rotate(45deg);-ms-transform:rotate(45deg);transform:rotate(45deg);background-color:#333}.fixed{position:fixed;width:100%}@media(min-width:940px){.fixed{position:static}}#container{margin:0 auto}#header{border-bottom:1px solid rgba(0,0,0,0.14);text-align:center;margin-bottom:3em;height:5em;position:relative}#header a{text-decoration:none;display:inline-block}#header div{margin:0 auto}#header h1{font-size:2em;padding-bottom:0}#header h1 span{color:rgba(0,0,0,0.6);font-weight:300}#posts li{list-style-type:none}#post-page{margin-bottom:1.5em}@media(min-width:940px){#post-page{margin-bottom:1.3334em}}.post+.post:before{display:block;content:'';width:5rem;height:1px;margin:23px auto;background-color:#e6e6e6}
.by-line{display:block;color:#737373;line-height:1.8em;font-weight:200}@media(min-width:940px){.by-line{display:block;color:#737373;line-height:1.8em;font-weight:200}}table,th,td{border:1px solid #dfe2e5;border-collapse:collapse;padding:6px 13px;padding-top:6px;padding-right:13px;padding-bottom:6px;padding-left:13px;margin-top:13px;margin-bottom:13px}.table-wrapper{overflow-x:auto;word-break:normal;word-break:keep-all}.MathJax_Display{overflow-x:auto;overflow-y:hidden}.post-info{margin-bottom:1.5em}.post-info>*{display:inline}img{max-width:100%;display:block;margin:0 auto;margin-bottom:24px;-webkit-border-radius:4px;-moz-border-radius:4px;-ms-border-radius:4px;border-radius:4px}img[title="Monochrome"]{box-shadow:0 2px 6px #ddd}code{color:#8c8c8c}.content ul,.content ol{line-height:1.8em;padding-left:1.5em}@media(min-width:940px){.content ul,.content ol{line-height:1.8em}}#page ul,#page ol{padding-left:1.5em}.pagination{text-align:center;margin:2.666668em}.pagination span{background-color:#f2f2f2;color:#333}.pagination a:hover{background-color:#404040}.page-item{background-color:#4d4d4d;color:#fff;padding:4px 8px;font-weight:400;padding:.5em 1em;-webkit-border-radius:4px;-moz-border-radius:4px;-ms-border-radius:4px;border-radius:4px}footer{background-color:#fff;color:#333;text-align:center;padding:.6667em 0}pre{overflow:auto;word-wrap:normal;white-space:pre;margin-left:1em}.highlight .cm{color:#998;font-style:italic}.highlight .cp{color:#999;font-weight:bold}.highlight .c1{color:#998;font-style:italic}.highlight .cs{color:#999;font-weight:bold;font-style:italic}.highlight .c,.highlight .cd{color:#998;font-style:italic}.highlight .err{color:#a61717;background-color:#e3d2d2}.highlight .gd{color:#000;background-color:#fdd}.highlight .ge{color:#000;font-style:italic}.highlight .gr{color:#a00}.highlight .gh{color:#999}.highlight .gi{color:#000;background-color:#dfd}.highlight .go{color:#888}.highlight .gp{color:#555}.highlight .gs{font-weight:bold}.highlight .gu{color:#aaa}.highlight .gt{color:#a00}.highlight .kc{color:#000;font-weight:bold}.highlight .kd{color:#000;font-weight:bold}.highlight .kn{color:#000;font-weight:bold}.highlight .kp{color:#000;font-weight:bold}.highlight .kr{color:#d73a49}.highlight .kt{color:#005cc5}.highlight .k,.highlight .kv{color:#000;font-weight:bold}.highlight .mf{color:#099}.highlight .mh{color:#099}.highlight .il{color:#099}.highlight .mi{color:#005cc5}.highlight .mo{color:#099}.highlight .m,.highlight .mb,.highlight .mx{color:#099}.highlight .sb{color:#d14}.highlight .sc{color:#d14}.highlight .sd{color:#d14}.highlight .s2{color:#d14}.highlight .se{color:#d14}.highlight .sh{color:#d14}.highlight .si{color:#d14}.highlight .sx{color:#d14}.highlight .sr{color:#009926}.highlight .s1{color:#d14}.highlight .ss{color:#990073}.highlight .s{color:#032f62}.highlight .na{color:#008080}.highlight .bp{color:#999}.highlight .nb{color:#0086b3}.highlight .nc{color:#458;font-weight:bold}.highlight .no{color:#008080}.highlight .nd{color:#3c5d5d;font-weight:bold}.highlight .ni{color:#800080}.highlight .ne{color:#900;font-weight:bold}.highlight .nf{color:#900;font-weight:bold}.highlight .nl{color:#900;font-weight:bold}.highlight .nn{color:#555}.highlight .nt{color:#000080}.highlight .vc{color:#008080}.highlight .vg{color:#008080}.highlight .vi{color:#008080}.highlight .nv{color:#008080}.highlight .ow{color:#000;font-weight:bold}.highlight .o{color:#d73a49}.highlight .w{color:#bbb}.highlight{background-color:#f8f8f8}.dropdown{position:fixed;z-index:10;bottom:1%;right:5%}.dropdown .img{width:24px;height:24px}.dropdown-content{display:none;background-color:#f9f9f9;min-width:160px;box-shadow:0 8px 16px 0 rgba(0,0,0,0.2);padding:12px 16px;z-index:1000;overflow:auto;max-height:80vh;overflow-x:hidden;overflow-y:auto}.dropdown-content ::-webkit-scrollbar{display:none}.dropdown-content ul>li>a{font-weight:700}.dropdown-content ul>li>ul>li>a{font-weight:500}#toc ul{list-style-type:none}#toc ul>li{margin-left:10px}#tipue_search_input,#tipue_search_foot_boxes{font:300 14px/1 Roboto,sans-serif}#tipue_search_results_count,#tipue_search_warning,.tipue_search_content_url,.tipue_search_content_debug,.tipue_search_related_text{font:300 14px/1.7 Roboto,sans-serif}.tipue_search_content_title{color:#000;font:100 26px/1.7 Roboto,sans-serif}.tipue_search_content_text,.tipue_search_related_title{font:300 15px/1.7 Roboto,sans-serif}.tipue_search_content_bold,.tipue_search_related_bold{font-weight:400}#tipue_search_input{color:#000;max-width:210px;padding:17px;border:1px solid rgba(0,0,0,0.6);border-radius:0;-moz-appearance:none;-webkit-appearance:none;box-shadow:none;outline:0;margin:0}.tipue_search_icon{width:24px;height:24px}.tipue_search_left{float:left;padding:15px 9px 0 0}.tipue_search_right{float:left}#tipue_search_content{max-width:750px;padding-top:15px;margin:0}#tipue_search_results_count{color:#000}#tipue_search_warning{color:#fff;margin:7px 0}#tipue_search_warning a{color:#5396ea;text-decoration:none}
#tipue_search_warning a:hover{color:#555}.tipue_search_related_title{color:#fff;margin:26px 0 7px 0}.tipue_search_related_cols{-webkit-columns:230px 2;-moz-columns:230px 2;columns:230px 2}#tipue_search_foot{margin:51px 0 21px 0}#tipue_search_foot_boxes{padding:0;margin:0;cursor:pointer}#tipue_search_foot_boxes li{list-style:none;margin:0;padding:0;display:inline}#tipue_search_foot_boxes li a{padding:10px 17px 11px 17px;background-color:#fff;border:1px solid #e3e3e3;border-radius:1px;color:#333;margin-right:7px;text-decoration:none;text-align:center}#tipue_search_foot_boxes li.current{padding:10px 17px 11px 17px;background:#f6f6f6;border:1px solid #e3e3e3;border-radius:1px;color:#333;margin-right:7px;text-align:center}#tipue_search_foot_boxes li a:hover{background:#f6f6f6}</style> <link href="/atom.xml" type="application/atom+xml" rel="alternate" title="ATOM Feed"/> <link rel="shortcut icon" type="image/png" href="img/favicon.png"> </head> <body> <div id="wrap"> <nav id="nav"> <div id="nav-list"> <a href="/">Home</a> <a href="/about" title="About">About</a> <a href="https://github.com/tpb1908/Notes">Project on Github</a> </div> <footer> <span>version 1.0.0</span> </footer> </nav> <a id="nav-menu"> <div id="menu"></div> </a> <header id="header" class="parent justify-spaceBetween"> <div class="inner w100 relative"> <span class="f-left"> <a href="/"> <h1> <span>Theo's</span> notes </h1> </a> </span> <span id="nav-links" class="absolute right bottom"> <a href="/about" title="About">About</a> <a href="https://github.com/tpb1908/Notes">Project on Github</a> </span> </div> </header> <div id="container"> <main> <article id="post-page"> <h2>Haskell Notes</h2> <div class="post-info"> <time datetime="2017-08-06T00:00:00+01:00" class="by-line">06 Aug 2017</time> <span>&middot;</span> <p> <a href="tags#notes"> Notes </a> <a href="tags#haskell"> Haskell </a> <a href="tags#functional"> Functional </a> </p> </div> <div class="content"> <p>This is a collection of notes on Haskell, primarily condensed from <a href="http://learnyouahaskell.com">learnyouahaskell</a></p> <h2 id="purely-functional-languages">Purely functional languages</h2> <p>In a purely functional language, functions can have no side effects.</p> <p>This means that if a function is called twice with the same parameters, it is guaranteed to return the same result. This is called referential transparency and allows the compiler to reason about program behaviour, as well as proof that a function is correct.</p> <h2 id="lazy-evaluation">Lazy evaluation</h2> <p>Functions will not be called and calculations will not be performed until a result is required. Programs can be thought of as a series of transformations on data. This allows structures such as infinite lists, which are only evaluated when required.</p> <p><strong>Example:</strong> <script type="math/tex">\text{List of } \mathbb{N}</script></p> <p>An infinite list of natural numbers can be generated as follows</p> <div class="language-haskell highlighter-rouge"><pre class="highlight"><code><span class="o">&gt;</span> <span class="kr">let</span> <span class="n">naturals</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">:</span> <span class="n">map</span> <span class="p">(</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="n">naturals</span>
</code></pre> </div> <p>When we want to use these values we can write</p> <div class="language-haskell highlighter-rouge"><pre class="highlight"><code><span class="o">&gt;</span> <span class="n">take</span> <span class="mi">10</span> <span class="n">naturals</span>
<span class="o">&gt;</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="mi">7</span><span class="p">,</span><span class="mi">8</span><span class="p">,</span><span class="mi">9</span><span class="p">,</span><span class="mi">10</span><span class="p">]</span>
</code></pre> </div> <p>We could more succinctly use the notation for a range</p> <div class="language-haskell highlighter-rouge"><pre class="highlight"><code><span class="o">&gt;</span> <span class="kr">let</span> <span class="n">naturals</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="o">..</span><span class="p">]</span>
</code></pre> </div> <p>This gives the same infinite range as before.</p> <h2 id="static-typing">Static typing</h2> <p>Haskell is a statically typed language, meaning that when it is compiled the compiler knows the type of every value.</p> <h2 id="type-inference">Type inference</h2> <p>Haskell, along with many other languages, use a system of type inference.</p> <p>This means that when writing <code class="highlighter-rouge">a = 2 + 3</code> it is not necessary to inform the compiler that <code class="highlighter-rouge">a</code> is a numeric value.</p> <p>If a function takes two parameters and adds them together, their types do not need to be stated explicitly. The function will can be executed with any two parameters that act like numbers.</p> <h1 id="basic-syntax">Basic syntax</h1> <h2 id="examples-arithmetic">Examples: Arithmetic</h2> <div class="language-haskell highlighter-rouge"><pre class="highlight"><code><span class="o">&gt;</span> <span class="mi">3</span> <span class="o">+</span> <span class="mi">16</span>
<span class="o">&gt;</span> <span class="mi">19</span>
<span class="o">&gt;</span> <span class="mi">27</span> <span class="o">*</span> <span class="mi">53</span>
<span class="o">&gt;</span> <span class="mi">1431</span>
<span class="o">&gt;</span> <span class="mi">1314</span> <span class="o">-</span> <span class="mi">133</span>
<span class="o">&gt;</span> <span class="mi">1181</span>
<span class="o">&gt;</span> <span class="mi">7</span> <span class="o">/</span> <span class="mi">2</span>
<span class="o">&gt;</span> <span class="mf">3.5</span>
</code></pre> </div> <p>When multiple operators are used on the same line, operator precedence and parentheses are respected.</p> <p><strong>Negation</strong></p> <p>When value are negated, they must be surrounded by parentheses.</p> <div class="language-haskell highlighter-rouge"><pre class="highlight"><code><span class="o">&gt;</span> <span class="mi">5</span> <span class="o">*</span> <span class="o">-</span><span class="mi">3</span>
</code></pre> </div> <p>The expression above will give a <code class="highlighter-rouge">Precedence parsing error</code>.</p> <p>Instead <code class="highlighter-rouge">5 * (-3)</code> should be written</p> <h2 id="examples-boolean-algebra">Examples: Boolean algebra</h2> <div class=table-wrapper><table> <thead> <tr> <th>Operator</th> <th>Symbol</th> </tr> </thead> <tbody> <tr> <td>And</td> <td>&amp;&amp;</td> </tr> <tr> <td>Or</td> <td>||</td> </tr> <tr> <td>Not</td> <td>not</td> </tr> <tr> <td>Equality</td> <td>==</td> </tr> <tr> <td>Inequality</td> <td>/=</td> </tr> </tbody> </table></div> <div class="language-haskell highlighter-rouge"><pre class="highlight"><code><span class="o">&gt;</span> <span class="kt">True</span> <span class="o">&amp;&amp;</span> <span class="kt">False</span>
<span class="o">&gt;</span> <span class="kt">False</span>
<span class="o">&gt;</span> <span class="kt">True</span> <span class="o">&amp;&amp;</span> <span class="n">not</span> <span class="kt">False</span>
<span class="o">&gt;</span> <span class="kt">True</span>
<span class="o">&gt;</span> <span class="kt">False</span> <span class="o">||</span> <span class="kt">True</span>
<span class="o">&gt;</span> <span class="kt">True</span>
<span class="o">&gt;</span> <span class="n">not</span> <span class="p">(</span><span class="kt">True</span> <span class="o">&amp;&amp;</span> <span class="kt">True</span><span class="p">)</span>
<span class="o">&gt;</span> <span class="kt">False</span>
<span class="o">&gt;</span> <span class="kt">True</span> <span class="o">==</span> <span class="kt">False</span>
<span class="o">&gt;</span> <span class="kt">False</span>
<span class="o">&gt;</span> <span class="mi">5</span> <span class="o">==</span> <span class="mi">5</span>
<span class="o">&gt;</span> <span class="kt">True</span>
<span class="o">&gt;</span> <span class="mi">1</span> <span class="o">==</span> <span class="mi">0</span>
<span class="o">&gt;</span> <span class="kt">False</span>
<span class="o">&gt;</span> <span class="mi">5</span> <span class="o">/=</span> <span class="mi">5</span>
<span class="o">&gt;</span> <span class="kt">False</span>
<span class="o">&gt;</span> <span class="mi">5</span> <span class="o">/=</span> <span class="mi">4</span>
<span class="o">&gt;</span> <span class="s">"string"</span> <span class="o">==</span> <span class="s">"string"</span>
<span class="o">&gt;</span> <span class="kt">True</span>
</code></pre> </div> <h2 id="functions">Functions</h2> <p>All of the operations performed so far have been functions, specifically <strong>infix</strong> functions.</p> <p>Functions are usually <strong>prefix</strong> functions, which take their arguments after the function name. Infix functions are different in that the arguments surround the function name.</p> <p><strong>Example:</strong> The successor function</p> <div class="language-haskell highlighter-rouge"><pre class="highlight"><code><span class="o">&gt;</span> <span class="n">succ</span> <span class="mi">9</span>
<span class="o">&gt;</span> <span class="mi">10</span>
</code></pre> </div> <p>The successor function takes anything which has a defined successor, and returns that successor.</p> <p>The min and max functions both take two parameters</p> <div class="language-haskell highlighter-rouge"><pre class="highlight"><code><span class="o">&gt;</span> <span class="n">min</span> <span class="mi">10</span> <span class="mi">11</span>
<span class="o">&gt;</span> <span class="mi">10</span>
<span class="o">&gt;</span> <span class="n">max</span> <span class="mi">100</span> <span class="mi">1000</span>
<span class="o">&gt;</span> <span class="mi">1000</span>
<span class="o">&gt;</span> <span class="n">min</span> <span class="mf">1.5</span> <span class="mf">1.4</span>
<span class="o">&gt;</span> <span class="mf">1.4</span>
</code></pre> </div> <p>Function application as seen above has the highest precedence</p> <p>This means that the following statements are equivalent</p> <div class="language-haskell highlighter-rouge"><pre class="highlight"><code><span class="o">&gt;</span> <span class="n">succ</span> <span class="mi">9</span> <span class="o">+</span> <span class="n">max</span> <span class="mi">5</span> <span class="mi">4</span> <span class="o">+</span> <span class="mi">1</span>
</code></pre> </div> <div class="language-haskell highlighter-rouge"><pre class="highlight"><code><span class="o">&gt;</span> <span class="p">(</span><span class="n">succ</span> <span class="mi">9</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="n">max</span> <span class="mi">5</span> <span class="mi">4</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span>
</code></pre> </div> <p>Suppose we want the successor to the product of two numbers, <code class="highlighter-rouge">a</code>, and <code class="highlighter-rouge">b</code>. As <code class="highlighter-rouge">succ</code> has the highest precedence writing <code class="highlighter-rouge">succ a * b</code> would first evaluate <code class="highlighter-rouge">succ a</code> and then evaluate its product with <code class="highlighter-rouge">b</code>. Instead we must right <code class="highlighter-rouge">succ (a * b)</code>.</p> <h3 id="writing-functions-as-infix">Writing functions as infix</h3> <p>If a function takes two parameters, it can be called as an infix function by surrounding it with backticks. <code class="highlighter-rouge">div</code> takes two integers and performs integral division.</p> <div class="language-haskell highlighter-rouge"><pre class="highlight"><code><span class="o">&gt;</span> <span class="mi">92</span> <span class="p">`</span><span class="n">div</span><span class="p">`</span> <span class="mi">9</span>
<span class="o">&gt;</span> <span class="mi">10</span>
</code></pre> </div> <h3 id="function-call-syntax">Function call syntax</h3> <p>Many other languages require parentheses to denote function application.</p> <p>In Haskell, spaces are used instead.</p> <h3 id="function-definition">Function definition</h3> <div class="language-haskell highlighter-rouge"><pre class="highlight"><code><span class="n">doubleValue</span> <span class="n">x</span> <span class="o">=</span> <span class="n">x</span> <span class="o">+</span> <span class="n">x</span>
</code></pre> </div> <p>The function above consists of a function name, followed by parameters separated by spaces. After the <code class="highlighter-rouge">=</code> the function body is defined.</p> <p>This function will work on any numeric type.</p> <div class="language-haskell highlighter-rouge"><pre class="highlight"><code><span class="o">&gt;</span> <span class="n">doubleValue</span> <span class="mi">2</span>
<span class="o">&gt;</span> <span class="mi">4</span>
<span class="o">&gt;</span> <span class="n">doubleValue</span> <span class="mf">2.5</span>
<span class="o">&gt;</span> <span class="mi">5</span>
</code></pre> </div> <div class="language-haskell highlighter-rouge"><pre class="highlight"><code><span class="n">doubleSum</span> <span class="n">x</span> <span class="n">y</span> <span class="o">=</span> <span class="n">x</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">+</span> <span class="n">y</span> <span class="o">*</span> <span class="mi">2</span>
</code></pre> </div> <p>This function takes two numeric parameters, doubles each of them, and returns the sum of the two doubled values.</p> <div class="language-haskell highlighter-rouge"><pre class="highlight"><code><span class="o">&gt;</span> <span class="n">doubleSum</span> <span class="mi">2</span> <span class="mi">3</span>
<span class="o">&gt;</span> <span class="mi">10</span>
<span class="o">&gt;</span> <span class="n">doubleSum</span> <span class="mf">5.5</span> <span class="mi">7</span>
<span class="o">&gt;</span> <span class="mf">25.0</span>
</code></pre> </div> <p>The function can take two numeric types, one of which is floating point and the other an integer. This will result in the integer type being converted to a floating point value.</p> <p>The function could also be defined in terms of the first function, <code class="highlighter-rouge">doubleValue</code>.</p> <div class="language-haskell highlighter-rouge"><pre class="highlight"><code><span class="n">doubleSum</span> <span class="n">x</span> <span class="n">y</span> <span class="o">=</span> <span class="n">doubleValue</span> <span class="n">x</span> <span class="o">+</span> <span class="n">doubleValue</span> <span class="n">y</span>
</code></pre> </div> <p>Function definitions do not have to be in any particular order, <code class="highlighter-rouge">doubleSum</code> could be defined before <code class="highlighter-rouge">doubleValue</code>.</p> <h3 id="conditional-expressions">Conditional expressions</h3> <div class="language-haskell highlighter-rouge"><pre class="highlight"><code><span class="n">doubleSmallNumber</span> <span class="n">x</span> <span class="o">=</span> <span class="kr">if</span> <span class="n">x</span> <span class="o">&gt;</span> <span class="mi">100</span>
                      <span class="kr">then</span> <span class="n">x</span>
                      <span class="kr">else</span> <span class="n">x</span> <span class="o">*</span> <span class="mi">2</span>
</code></pre> </div> <p>The function <code class="highlighter-rouge">doubleSmallNumber</code> doubles the parameter <code class="highlighter-rouge">x</code> if <code class="highlighter-rouge">x&lt;=100</code>, otherwise it returns the original value of <code class="highlighter-rouge">x</code>.</p> <p>An if statement in Haskell is an expression, a piece of code which returns a value. Because the else is mandatory, an if statement will always return some value.</p> <p>If we wanted to add one to the return value in <code class="highlighter-rouge">doubleSmallNumber</code> we could write</p> <div class="language-haskell highlighter-rouge"><pre class="highlight"><code><span class="n">doubleSmallNumber'</span> <span class="n">x</span> <span class="o">=</span> <span class="p">(</span><span class="kr">if</span> <span class="n">x</span> <span class="o">&gt;</span> <span class="mi">100</span> <span class="kr">then</span> <span class="n">x</span> <span class="kr">else</span> <span class="n">x</span> <span class="o">*</span> <span class="mi">2</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span>
</code></pre> </div> <h3 id="function-naming">Function naming</h3> <p>The function above <code class="highlighter-rouge">doubleSmallNumber'</code> has a <code class="highlighter-rouge">'</code> character as its last character. This is a valid character in Haskell function names and is often used to denote a stricter, non-lazy version of a function, or a slightly modified version.</p> <p>Haskell functions cannot begin with uppercase characters.</p> <p>When a function does not take any parameters, it is called a <strong>definition</strong> or a <strong>name</strong>.</p> <h2 id="lists">Lists</h2> <p>Lists are defined as comma separated lists of values within a set of square brackets <code class="highlighter-rouge">[]</code>.</p> <p>A string is just syntax for a list of characters. As strings are backed by lists of characters, we can apply list functions to them.</p> <h3 id="string-and-list-concatenation">String and list concatenation</h3> <p>Strings are concatenated with the <code class="highlighter-rouge">++</code> operator.</p> <div class="language-haskell highlighter-rouge"><pre class="highlight"><code><span class="o">&gt;</span> <span class="s">"hello"</span> <span class="o">++</span> <span class="s">" "</span> <span class="o">++</span> <span class="s">"world"</span>
<span class="o">&gt;</span> <span class="s">"hello world"</span>
</code></pre> </div> <p>This operator is used more widely for list concatenation.</p> <div class="language-haskell highlighter-rouge"><pre class="highlight"><code><span class="o">&gt;</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">]</span> <span class="o">++</span> <span class="p">[</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">]</span>
<span class="o">&gt;</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">]</span>
</code></pre> </div> <p>When two lists are added together, even when a singleton is added to the end of a list, Haskell has to walk through the whole list on the left side of the <code class="highlighter-rouge">++</code> operator which can be slow when dealing with large lists.</p> <p>Prepending to a list is effectively instantaneous.</p> <p>It is done with the <code class="highlighter-rouge">:</code> operator.</p> <div class="language-haskell highlighter-rouge"><pre class="highlight"><code><span class="o">&gt;</span> <span class="sc">'A'</span> <span class="o">:</span> <span class="s">"BC"</span>
<span class="o">&gt;</span> <span class="s">"ABC"</span>
<span class="o">&gt;</span> <span class="mi">5</span> <span class="o">:</span> <span class="p">[</span><span class="mi">4</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span>
<span class="o">&gt;</span> <span class="p">[</span><span class="mi">5</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span>
</code></pre> </div> <p>Note that <code class="highlighter-rouge">++</code> takes two lists. This means that any singleton value being appended to a list must be a list containing one item, such as <code class="highlighter-rouge">[5]</code>, rather than just <code class="highlighter-rouge">5</code>.</p> <p>A list definition such as <code class="highlighter-rouge">[1,2,3]</code> is actually just syntactic sugar for <code class="highlighter-rouge">1:2:3:[]</code>, where <code class="highlighter-rouge">[]</code> is an empty list.</p> <h3 id="list-indexing">List indexing</h3> <p>As with any sensible language, Haskell lists are indexed from 0.</p> <p>The <code class="highlighter-rouge">!!</code> operator is used to read an element from a list at a given index.</p> <div class="language-haskell highlighter-rouge"><pre class="highlight"><code><span class="o">&gt;</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">]</span> <span class="o">!!</span> <span class="mi">2</span>
<span class="o">&gt;</span> <span class="mi">3</span>
<span class="o">&gt;</span> <span class="s">"hello"</span> <span class="o">!!</span> <span class="mi">1</span>
<span class="o">&gt;</span> <span class="sc">'e'</span>
</code></pre> </div> <p>Attempting to access an index which does not exist will raise an error.</p> <h3 id="nested-lists">Nested lists</h3> <p>Lists can be infinitely nested within memory constraints.</p> <div class="language-haskell highlighter-rouge"><pre class="highlight"><code><span class="o">&gt;</span> <span class="kr">let</span> <span class="n">b</span> <span class="o">=</span> <span class="p">[[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">],[</span><span class="mi">5</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">],[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">],[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">]]</span>
<span class="o">&gt;</span> <span class="n">b</span>
<span class="o">&gt;</span> <span class="p">[[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">],[</span><span class="mi">5</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">],[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">],[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">]]</span>
<span class="o">&gt;</span> <span class="n">b</span> <span class="o">++</span> <span class="p">[[</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">]]</span>
<span class="o">&gt;</span> <span class="p">[[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">],[</span><span class="mi">5</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">],[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">],[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">],[</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">]]</span>
<span class="o">&gt;</span> <span class="p">[</span><span class="mi">6</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="mi">6</span><span class="p">]</span><span class="o">:</span><span class="n">b</span>
<span class="o">&gt;</span> <span class="p">[[</span><span class="mi">6</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="mi">6</span><span class="p">],[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">],[</span><span class="mi">5</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">],[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">],[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">]]</span>
<span class="o">&gt;</span> <span class="n">b</span> <span class="o">!!</span> <span class="mi">2</span>
<span class="o">&gt;</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">]</span>
</code></pre> </div> <p>The nested lists can be of different dimensions, but they must be of the same type.</p> <h3 id="list-comparisons">List comparisons</h3> <p>Lists can be compared if there is a method for comparing their contents. When using <code class="highlighter-rouge">&lt;, &lt;=, &gt;, &gt;=</code> to compare lists, their elements are compared in lexicographical order. First the head elements are compared, if they are equal the next elements are compared and so forth, until two elements are not equal, or one of the lists ends.</p> <div class="language-haskell highlighter-rouge"><pre class="highlight"><code><span class="o">&gt;</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span> <span class="o">==</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span>
<span class="o">&gt;</span> <span class="kt">True</span>
<span class="o">&gt;</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span> <span class="o">&gt;</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">10</span><span class="p">,</span><span class="mi">100</span><span class="p">]</span>
<span class="o">&gt;</span> <span class="kt">True</span>
<span class="o">&gt;</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span> <span class="o">&gt;</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">]</span>
<span class="o">&gt;</span> <span class="kt">True</span>
</code></pre> </div> <h3 id="list-operations">List operations</h3> <p><strong>head</strong> takes a list as a parameter and returns its head, the first element</p> <div class="language-haskell highlighter-rouge"><pre class="highlight"><code><span class="o">&gt;</span> <span class="n">head</span> <span class="p">[</span><span class="mi">10</span><span class="p">,</span><span class="mi">9</span><span class="p">,</span><span class="mi">8</span><span class="p">]</span>
<span class="o">&gt;</span> <span class="mi">10</span>
</code></pre> </div> <p><strong>tail</strong> takes a list as a parameter and returns its tail, the elements past the first</p> <div class="language-haskell highlighter-rouge"><pre class="highlight"><code><span class="o">&gt;</span> <span class="n">tail</span> <span class="p">[</span><span class="mi">10</span><span class="p">,</span><span class="mi">9</span><span class="p">,</span><span class="mi">8</span><span class="p">]</span>
<span class="o">&gt;</span> <span class="p">[</span><span class="mi">9</span><span class="p">,</span><span class="mi">8</span><span class="p">]</span>
</code></pre> </div> <p><strong>last</strong> takes a list as a parameter and returns its last element</p> <div class="language-haskell highlighter-rouge"><pre class="highlight"><code><span class="o">&gt;</span> <span class="n">last</span> <span class="p">[</span><span class="mi">10</span><span class="p">,</span><span class="mi">9</span><span class="p">,</span><span class="mi">8</span><span class="p">]</span>
<span class="o">&gt;</span> <span class="mi">8</span>
</code></pre> </div> <p><strong>init</strong> takes a list as a parameter and returns the elements before the last</p> <div class="language-haskell highlighter-rouge"><pre class="highlight"><code><span class="o">&gt;</span> <span class="n">init</span> <span class="p">[</span><span class="mi">10</span><span class="p">,</span><span class="mi">9</span><span class="p">,</span><span class="mi">8</span><span class="p">]</span>
<span class="o">&gt;</span> <span class="p">[</span><span class="mi">10</span><span class="p">,</span><span class="mi">9</span><span class="p">]</span>
</code></pre> </div> <p>The functions above will raise an exception if applied to an empty list.</p> <p><strong>length</strong> takes a list as a parameter and returns its length, the number of elements</p> <div class="language-haskell highlighter-rouge"><pre class="highlight"><code><span class="o">&gt;</span> <span class="n">length</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">]</span>
<span class="o">&gt;</span> <span class="mi">5</span>
</code></pre> </div> <p><strong>null</strong> takes a list as a parameter and returns <code class="highlighter-rouge">True</code> if the list is empty, and <code class="highlighter-rouge">False</code> otherwise</p> <div class="language-haskell highlighter-rouge"><pre class="highlight"><code><span class="o">&gt;</span> <span class="n">null</span> <span class="kt">[]</span>
<span class="o">&gt;</span> <span class="kt">True</span>
<span class="o">&gt;</span> <span class="n">null</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">]</span>
<span class="o">&gt;</span> <span class="kt">False</span>
</code></pre> </div> <p><strong>reverse</strong> takes a list as a parameter returns the reversed list</p> <div class="language-haskell highlighter-rouge"><pre class="highlight"><code><span class="o">&gt;</span> <span class="n">reverse</span> <span class="p">[</span><span class="mi">5</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span>
<span class="o">&gt;</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">]</span>
</code></pre> </div> <p><strong>take</strong> takes an integer and a list as parameters and extracts that many elements from the list, returning them</p> <p>If we try to take more elements than there are in the list, it just returns the list without raising an exception.</p> <div class="language-haskell highlighter-rouge"><pre class="highlight"><code><span class="o">&gt;</span> <span class="n">take</span> <span class="mi">3</span> <span class="p">[</span><span class="mi">5</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span>
<span class="o">&gt;</span> <span class="p">[</span><span class="mi">5</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">3</span><span class="p">]</span>
<span class="o">&gt;</span> <span class="n">take</span> <span class="mi">1</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span><span class="mi">9</span><span class="p">,</span><span class="mi">3</span><span class="p">]</span>
<span class="o">&gt;</span> <span class="p">[</span><span class="mi">3</span><span class="p">]</span>
<span class="o">&gt;</span> <span class="n">take</span> <span class="mi">5</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span>
<span class="o">&gt;</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span>
<span class="o">&gt;</span> <span class="n">take</span> <span class="mi">0</span> <span class="p">[</span><span class="mi">6</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">4</span><span class="p">]</span>
<span class="o">&gt;</span> <span class="kt">[]</span>
</code></pre> </div> <p><strong>drop</strong> takes an integer and list as parameters, and drops that many elements from the start of the list</p> <div class="language-haskell highlighter-rouge"><pre class="highlight"><code><span class="o">&gt;</span> <span class="n">drop</span> <span class="mi">3</span> <span class="p">[</span><span class="mi">8</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">]</span>
<span class="o">&gt;</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">]</span>
<span class="o">&gt;</span> <span class="n">drop</span> <span class="mi">0</span> <span class="p">[</span><span class="mi">4</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span>
<span class="o">&gt;</span> <span class="p">[</span><span class="mi">4</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span>
<span class="o">&gt;</span> <span class="n">drop</span> <span class="mi">100</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">]</span>
<span class="o">&gt;</span> <span class="kt">[]</span>
</code></pre> </div> <p><strong>maximum</strong> takes an orderable list as a parameter and returns the largest element</p> <p><strong>minimum</strong> takes an orderable list as a parameter and returns the smallest element</p> <div class="language-haskell highlighter-rouge"><pre class="highlight"><code><span class="o">&gt;</span> <span class="n">minimum</span> <span class="p">[</span><span class="mi">8</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">]</span>
<span class="o">&gt;</span> <span class="mi">1</span>
<span class="o">&gt;</span> <span class="n">maximum</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">9</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">]</span>
<span class="o">&gt;</span> <span class="mi">9</span>
</code></pre> </div> <p><strong>sum</strong> takes a list of numbers as a parameter and returns their sum</p> <div class="language-haskell highlighter-rouge"><pre class="highlight"><code><span class="o">&gt;</span> <span class="n">sum</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">]</span>
<span class="o">&gt;</span> <span class="mi">15</span>
</code></pre> </div> <p><strong>product</strong> takes a list of numbers as a parameter and returns their product</p> <div class="language-haskell highlighter-rouge"><pre class="highlight"><code><span class="o">&gt;</span> <span class="n">product</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">]</span>
<span class="o">&gt;</span> <span class="mi">24</span>
</code></pre> </div> <p><strong>elem</strong> takes an instance of type <code class="highlighter-rouge">T</code> and a list of type <code class="highlighter-rouge">T</code> as parameters and returns true if the instance is contained within the list</p> <p><code class="highlighter-rouge">elem</code> is usually called as an infix function because it is easier to read.</p> <div class="language-haskell highlighter-rouge"><pre class="highlight"><code><span class="o">&gt;</span> <span class="mi">4</span> <span class="p">`</span><span class="n">elem</span><span class="p">`</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">]</span>
<span class="o">&gt;</span> <span class="kt">True</span>
<span class="o">&gt;</span> <span class="mi">10</span> <span class="p">`</span><span class="n">elem</span><span class="p">`</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">]</span>
<span class="o">&gt;</span> <span class="kt">False</span>
</code></pre> </div> <h3 id="ranges">Ranges</h3> <p>Ranges are a method for making lists that are arithmetic sequences of elements that can be enumerated, such as numbers and characters.</p> <div class="language-haskell highlighter-rouge"><pre class="highlight"><code><span class="o">&gt;</span> <span class="p">[</span><span class="mi">1</span><span class="o">..</span><span class="mi">20</span><span class="p">]</span>
<span class="o">&gt;</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="mi">7</span><span class="p">,</span><span class="mi">8</span><span class="p">,</span><span class="mi">9</span><span class="p">,</span><span class="mi">10</span><span class="p">,</span><span class="mi">11</span><span class="p">,</span><span class="mi">12</span><span class="p">,</span><span class="mi">13</span><span class="p">,</span><span class="mi">14</span><span class="p">,</span><span class="mi">15</span><span class="p">,</span><span class="mi">16</span><span class="p">,</span><span class="mi">17</span><span class="p">,</span><span class="mi">18</span><span class="p">,</span><span class="mi">19</span><span class="p">,</span><span class="mi">20</span><span class="p">]</span>
<span class="o">&gt;</span> <span class="p">[</span><span class="sc">'a'</span><span class="o">..</span><span class="sc">'z'</span><span class="p">]</span>
<span class="o">&gt;</span> <span class="p">[</span><span class="sc">'a'</span><span class="p">,</span><span class="sc">'b'</span><span class="p">,</span><span class="sc">'c'</span><span class="p">,</span><span class="sc">'d'</span><span class="p">,</span><span class="sc">'e'</span><span class="p">,</span><span class="sc">'g'</span><span class="p">,</span><span class="sc">'h'</span><span class="p">,</span><span class="sc">'j'</span><span class="p">,</span><span class="sc">'k'</span><span class="p">,</span><span class="sc">'l'</span><span class="p">,</span><span class="sc">'m'</span><span class="p">,</span><span class="sc">'n'</span><span class="p">,</span><span class="sc">'o'</span><span class="p">,</span><span class="sc">'p'</span><span class="p">,</span><span class="sc">'q'</span><span class="p">,</span><span class="sc">'r'</span><span class="p">,</span><span class="sc">'s'</span><span class="p">,</span><span class="sc">'t'</span><span class="p">,</span><span class="sc">'u'</span><span class="p">,</span><span class="sc">'v'</span><span class="p">,</span><span class="sc">'w'</span><span class="p">,</span><span class="sc">'x'</span><span class="p">,</span><span class="sc">'y'</span><span class="p">,</span><span class="sc">'z'</span><span class="p">]</span>
</code></pre> </div> <p>The step for a range can also be specified.</p> <div class="language-haskell highlighter-rouge"><pre class="highlight"><code><span class="o">&gt;</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">4</span><span class="o">..</span><span class="mi">20</span><span class="p">]</span>
<span class="o">&gt;</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="mi">8</span><span class="p">,</span><span class="mi">10</span><span class="p">,</span><span class="mi">12</span><span class="p">,</span><span class="mi">14</span><span class="p">,</span><span class="mi">16</span><span class="p">,</span><span class="mi">18</span><span class="p">,</span><span class="mi">20</span><span class="p">]</span>
</code></pre> </div> <p>To make a list of numbers in descending order from <code class="highlighter-rouge">m</code> to <code class="highlighter-rouge">n</code> you have to write</p> <div class="language-haskell highlighter-rouge"><pre class="highlight"><code><span class="o">&gt;</span> <span class="p">[</span><span class="n">m</span><span class="p">,</span><span class="n">m</span><span class="o">-</span><span class="mi">1</span><span class="o">..</span><span class="n">n</span><span class="p">]</span>
</code></pre> </div> <h3 id="production-of-infinite-lists">Production of infinite lists</h3> <p>Infinite lists can be produced by neglecting to specify an upper bound for a range.</p> <p><strong>cycle</strong> takes a list as a parameter and cycles it into an infinite list.</p> <div class="language-haskell highlighter-rouge"><pre class="highlight"><code><span class="o">&gt;</span> <span class="n">take</span> <span class="mi">10</span> <span class="p">(</span><span class="n">cycle</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span>
<span class="o">&gt;</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">]</span>
</code></pre> </div> <p><strong>repeat</strong> takes an element as a parameter and produces an infinite list of just that element</p> <div class="language-haskell highlighter-rouge"><pre class="highlight"><code><span class="o">&gt;</span> <span class="n">take</span> <span class="mi">10</span> <span class="p">(</span><span class="n">repeat</span> <span class="mi">6</span><span class="p">)</span>
<span class="o">&gt;</span> <span class="p">[</span><span class="mi">6</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="mi">6</span><span class="p">]</span>
</code></pre> </div> <p>If you want some number of the same element in a list it is simpler to use <code class="highlighter-rouge">replicate</code></p> <p><strong>replicate</strong> takes a number and an element a returns a list containing that many of the element</p> <div class="language-haskell highlighter-rouge"><pre class="highlight"><code><span class="o">&gt;</span> <span class="n">replicate</span> <span class="mi">5</span> <span class="mi">6</span>
<span class="o">&gt;</span> <span class="p">[</span><span class="mi">5</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">5</span><span class="p">]</span>
</code></pre> </div> <h3 id="list-comprehension">List comprehension</h3> <p>Set comprehensions are often used for building specific sets from general sets.</p> <script type="math/tex; mode=display">S = \left\{2 \times x  \mid x \in \mathbb{N},\ x \leq 10 \right\}</script> <p>The part before the pipe is called the output function, <script type="math/tex">x</script> is the variable, <script type="math/tex">\mathbb{N}</script> is the input set and <script type="math/tex">x \leq 10</script> is the the predicate.</p> <p>The set <script type="math/tex">S</script> contains the doubles of all the values that satisfy the predicate.</p> <p>In Haskell we could write <code class="highlighter-rouge">take 10 [2,4,..]</code> but this would produce doubles of the first 10 natural numbers.</p> <p>A list comprehension should be used instead.</p> <div class="language-haskell highlighter-rouge"><pre class="highlight"><code><span class="o">&gt;</span> <span class="p">[</span><span class="n">x</span><span class="o">*</span><span class="mi">2</span> <span class="o">|</span> <span class="n">x</span> <span class="o">&lt;-</span> <span class="p">[</span><span class="mi">1</span><span class="o">..</span><span class="mi">10</span><span class="p">]]</span>
<span class="o">&gt;</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="mi">8</span><span class="p">,</span><span class="mi">10</span><span class="p">,</span><span class="mi">12</span><span class="p">,</span><span class="mi">14</span><span class="p">,</span><span class="mi">16</span><span class="p">,</span><span class="mi">18</span><span class="p">,</span><span class="mi">20</span><span class="p">]</span>
</code></pre> </div> <p>We can also add a predicate to the comprehension</p> <div class="language-haskell highlighter-rouge"><pre class="highlight"><code><span class="o">&gt;</span> <span class="p">[</span><span class="n">x</span><span class="o">*</span><span class="mi">2</span> <span class="o">|</span> <span class="n">x</span> <span class="o">&lt;-</span> <span class="p">[</span><span class="mi">1</span><span class="o">..</span><span class="mi">10</span><span class="p">],</span> <span class="n">x</span><span class="o">*</span><span class="mi">2</span> <span class="o">&gt;=</span> <span class="mi">12</span><span class="p">]</span>
<span class="o">&gt;</span> <span class="p">[</span><span class="mi">12</span><span class="p">,</span><span class="mi">14</span><span class="p">,</span><span class="mi">16</span><span class="p">,</span><span class="mi">18</span><span class="p">,</span><span class="mi">20</span><span class="p">]</span>
</code></pre> </div> <p>Suppose we want to all the numbers from 50 to 100 whose remainder when divided by the number 7 is 3.</p> <div class="language-haskell highlighter-rouge"><pre class="highlight"><code><span class="o">&gt;</span> <span class="p">[</span><span class="n">x</span> <span class="o">|</span> <span class="n">x</span> <span class="o">&lt;-</span> <span class="p">[</span><span class="mi">50</span><span class="p">,</span><span class="mi">100</span><span class="p">],</span> <span class="n">x</span> <span class="p">`</span><span class="n">mod</span><span class="p">`</span> <span class="mi">7</span> <span class="o">==</span><span class="mi">3</span><span class="p">]</span>
<span class="o">&gt;</span> <span class="p">[</span><span class="mi">52</span><span class="p">,</span><span class="mi">59</span><span class="p">,</span><span class="mi">66</span><span class="p">,</span><span class="mi">73</span><span class="p">,</span><span class="mi">80</span><span class="p">,</span><span class="mi">87</span><span class="p">,</span><span class="mi">94</span><span class="p">]</span>
</code></pre> </div> <p>This process is called filtering. We took a list and filtered it by the predicate.</p> <p>Now suppose we want to replace each odd number greater than 10 the string <code class="highlighter-rouge">"BANG!"</code> and each odd number less than 10 with <code class="highlighter-rouge">"BOOM!"</code>. If a number isn’t odd, we throw it out of our list. For convenience we can place out comprehension inside a function so that we can reuse it.</p> <div class="language-haskell highlighter-rouge"><pre class="highlight"><code><span class="o">&gt;</span> <span class="kr">let</span> <span class="n">boomBang</span> <span class="n">xs</span> <span class="o">=</span> <span class="p">[</span><span class="kr">if</span> <span class="n">x</span> <span class="o">&lt;</span> <span class="mi">10</span> <span class="kr">then</span> <span class="s">"BOOM!"</span> <span class="kr">else</span> <span class="s">"BANG!"</span> <span class="o">|</span> <span class="n">x</span> <span class="o">&lt;-</span> <span class="n">xs</span><span class="p">,</span> <span class="n">odd</span> <span class="n">x</span><span class="p">]</span>
<span class="o">&gt;</span> <span class="n">boomBang</span> <span class="p">[</span><span class="mi">7</span><span class="o">..</span><span class="mi">13</span><span class="p">]</span>
<span class="o">&gt;</span> <span class="p">[</span><span class="s">"BOOM!"</span><span class="p">,</span> <span class="s">"BOOM!"</span><span class="p">,</span> <span class="s">"BANG!"</span><span class="p">,</span> <span class="s">"BANG!"</span><span class="p">]</span>
</code></pre> </div> <p>We can include several predicates. A comprehension for numbers from 10 to 20 that are not 13, 15, or 19 can be written as.</p> <div class="language-haskell highlighter-rouge"><pre class="highlight"><code><span class="o">&gt;</span> <span class="p">[</span><span class="n">x</span> <span class="o">|</span> <span class="n">x</span> <span class="o">&lt;-</span> <span class="p">[</span><span class="mi">10</span><span class="o">..</span><span class="mi">20</span><span class="p">],</span> <span class="n">x</span> <span class="o">/=</span> <span class="mi">13</span><span class="p">,</span> <span class="n">x</span> <span class="o">/=</span> <span class="mi">15</span><span class="p">,</span> <span class="n">x</span> <span class="o">/=</span> <span class="mi">19</span><span class="p">]</span>
<span class="o">&gt;</span> <span class="p">[</span><span class="mi">10</span><span class="p">,</span><span class="mi">11</span><span class="p">,</span><span class="mi">12</span><span class="p">,</span><span class="mi">14</span><span class="p">,</span><span class="mi">16</span><span class="p">,</span><span class="mi">17</span><span class="p">,</span><span class="mi">18</span><span class="p">,</span><span class="mi">20</span><span class="p">]</span>
</code></pre> </div> <p>Not only can we have multiple predicates in list comprehensions, we can also draw from multiple lists. A list produced by a comprehension that draws from two lists of lengths <code class="highlighter-rouge">n</code> and <code class="highlighter-rouge">m</code> respectively will have a length of <code class="highlighter-rouge">n*m</code>.</p> <p>If we have two lists, <code class="highlighter-rouge">[2,5,10]</code> and <code class="highlighter-rouge">[8,10,11]</code> and we wish to find the products of all the possible combinations between numbers in those lists, we can write</p> <div class="language-haskell highlighter-rouge"><pre class="highlight"><code><span class="o">&gt;</span> <span class="p">[</span><span class="n">x</span><span class="o">*</span><span class="n">y</span> <span class="o">|</span> <span class="n">x</span> <span class="o">&lt;-</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">10</span><span class="p">],</span> <span class="n">y</span> <span class="o">&lt;-</span> <span class="p">[</span><span class="mi">8</span><span class="p">,</span><span class="mi">10</span><span class="p">,</span><span class="mi">10</span><span class="p">]]</span>
<span class="o">&gt;</span> <span class="p">[</span><span class="mi">16</span><span class="p">,</span><span class="mi">20</span><span class="p">,</span><span class="mi">22</span><span class="p">,</span><span class="mi">40</span><span class="p">,</span><span class="mi">50</span><span class="p">,</span><span class="mi">55</span><span class="p">,</span><span class="mi">80</span><span class="p">,</span><span class="mi">100</span><span class="p">,</span><span class="mi">110</span><span class="p">]</span>
</code></pre> </div> <p>Now suppose that we want all possible products which are greater than 50</p> <div class="language-haskell highlighter-rouge"><pre class="highlight"><code><span class="o">&gt;</span> <span class="p">[</span><span class="n">x</span><span class="o">*</span><span class="n">y</span> <span class="o">|</span> <span class="n">x</span> <span class="o">&lt;-</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">10</span><span class="p">],</span> <span class="n">y</span> <span class="o">&lt;-</span> <span class="p">[</span><span class="mi">8</span><span class="p">,</span><span class="mi">10</span><span class="p">,</span><span class="mi">10</span><span class="p">],</span> <span class="n">x</span> <span class="o">*</span> <span class="n">y</span> <span class="o">&gt;</span> <span class="mi">50</span><span class="p">]</span>
<span class="o">&gt;</span> <span class="p">[</span><span class="mi">55</span><span class="p">,</span><span class="mi">80</span><span class="p">,</span><span class="mi">100</span><span class="p">,</span><span class="mi">110</span><span class="p">]</span>
</code></pre> </div> <div class="language-haskell highlighter-rouge"><pre class="highlight"><code><span class="o">&gt;</span> <span class="kr">let</span> <span class="n">nouns</span> <span class="o">=</span> <span class="p">[</span><span class="s">"hobo"</span><span class="p">,</span><span class="s">"frog"</span><span class="p">,</span><span class="s">"pope"</span><span class="p">]</span>  
<span class="o">&gt;</span> <span class="kr">let</span> <span class="n">adjectives</span> <span class="o">=</span> <span class="p">[</span><span class="s">"lazy"</span><span class="p">,</span><span class="s">"grouchy"</span><span class="p">,</span><span class="s">"scheming"</span><span class="p">]</span>  
<span class="o">&gt;</span> <span class="p">[</span><span class="n">adjective</span> <span class="o">++</span> <span class="s">" "</span> <span class="o">++</span> <span class="n">noun</span> <span class="o">|</span> <span class="n">adjective</span> <span class="o">&lt;-</span> <span class="n">adjectives</span><span class="p">,</span> <span class="n">noun</span> <span class="o">&lt;-</span> <span class="n">nouns</span><span class="p">]</span>  
<span class="o">&gt;</span> <span class="p">[</span><span class="s">"lazy hobo"</span><span class="p">,</span><span class="s">"lazy frog"</span><span class="p">,</span><span class="s">"lazy pope"</span><span class="p">,</span><span class="s">"grouchy hobo"</span><span class="p">,</span><span class="s">"grouchy frog"</span><span class="p">,</span>  
<span class="s">"grouchy pope"</span><span class="p">,</span><span class="s">"scheming hobo"</span><span class="p">,</span><span class="s">"scheming frog"</span><span class="p">,</span><span class="s">"scheming pope"</span><span class="p">]</span>   
</code></pre> </div> <p>We could use list comprehension to write a bad version of the length function.</p> <div class="language-haskell highlighter-rouge"><pre class="highlight"><code><span class="o">&gt;</span> <span class="n">length</span><span class="p">`</span> <span class="n">xs</span> <span class="o">=</span> <span class="n">sum</span> <span class="p">[</span><span class="mi">1</span> <span class="o">|</span> <span class="kr">_</span> <span class="o">&lt;-</span> <span class="n">xs</span><span class="p">]</span>
</code></pre> </div> <p>This function replaces every element of the list with <code class="highlighter-rouge">1</code>s and finds their sum. The underscore character, <code class="highlighter-rouge">_</code>, is used to denote a variable which is not used.</p> <h4 id="nested-list-comprehensions">Nested list comprehensions</h4> <div class="language-haskell highlighter-rouge"><pre class="highlight"><code><span class="o">&gt;</span> <span class="kr">let</span> <span class="n">xxs</span> <span class="o">=</span> <span class="p">[[</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">],[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="mi">7</span><span class="p">,</span><span class="mi">8</span><span class="p">,</span><span class="mi">9</span><span class="p">]</span><span class="o">.</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">6</span><span class="p">]]</span>
<span class="o">&gt;</span> <span class="p">[[</span><span class="n">x</span> <span class="o">|</span> <span class="n">x</span> <span class="o">&lt;-</span> <span class="n">xs</span><span class="p">,</span> <span class="n">even</span> <span class="n">x</span><span class="p">]</span> <span class="o">|</span> <span class="n">xs</span> <span class="o">&lt;-</span> <span class="n">xxs</span><span class="p">]</span>
<span class="o">&gt;</span> <span class="p">[[</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">4</span><span class="p">],[</span><span class="mi">2</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="mi">8</span><span class="p">],</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">6</span><span class="p">]]</span>
</code></pre> </div> <p>The comprehension shown above applies a comprehension to each of the lists, within the outer list, filtering them to only even values.</p> <h2 id="tuples">Tuples</h2> <p>Tuples are similar to lists, providing a way to store several values in a single value. Tuples are used when the number of values you want to combine is known, and its type depends on how many components it has along with the type of the components. They are denoted with parentheses around a comma separated list of values.</p> <p>Unlike lists, tuples do not have to be homogeneous, meaning that they can contain several types.</p> <div class="language-haskell highlighter-rouge"><pre class="highlight"><code><span class="o">&gt;</span> <span class="c1">--List of tuples of the same type</span>
<span class="o">&gt;</span> <span class="p">[(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">),(</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">),(</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">)]</span>
<span class="o">&gt;</span> <span class="c1">--List of tuples of varying types -&gt; Error</span>
<span class="o">&gt;</span> <span class="p">[(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">),(</span><span class="mi">3</span><span class="p">,</span><span class="s">"4"</span><span class="p">),(</span><span class="sc">'5'</span><span class="p">,</span><span class="mi">6</span><span class="p">)]</span>
</code></pre> </div> <p>Tuples can contain lists.</p> <p>Tuples are much more rigid. A general function cannot be written to append an element to a tuple.</p> <p>There is no singleton tuple. This is because a singleton tuple would just be the value it contains and therefore provide no use.</p> <h3 id="tuple-operations">Tuple operations</h3> <p><strong>fst</strong> takes a pair and returns its first component</p> <div class="language-haskell highlighter-rouge"><pre class="highlight"><code><span class="o">&gt;</span> <span class="n">fst</span> <span class="p">(</span><span class="mi">8</span><span class="p">,</span><span class="mi">11</span><span class="p">)</span>
<span class="o">&gt;</span> <span class="mi">8</span>
</code></pre> </div> <p><strong>snd</strong> takes a pair and returns its second component</p> <p>These functions only work on pairs. They will not work on triples, 4-tuples, 5-tuples etc.</p> <p><strong>zip</strong> takes two lists and produces a list of pairs</p> <div class="language-haskell highlighter-rouge"><pre class="highlight"><code><span class="o">&gt;</span> <span class="n">zip</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">]</span> <span class="p">[</span><span class="mi">5</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span>
<span class="o">&gt;</span> <span class="p">[(</span><span class="mi">1</span><span class="p">,</span><span class="mi">5</span><span class="p">),(</span><span class="mi">2</span><span class="p">,</span><span class="mi">4</span><span class="p">),(</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">),(</span><span class="mi">4</span><span class="p">,</span><span class="mi">2</span><span class="p">),(</span><span class="mi">5</span><span class="p">,</span><span class="mi">1</span><span class="p">)]</span>
<span class="o">&gt;</span> <span class="n">zip</span> <span class="p">[</span><span class="mi">1</span><span class="o">..</span><span class="mi">5</span><span class="p">]</span> <span class="p">[</span><span class="s">"five"</span><span class="p">,</span> <span class="s">"four"</span><span class="p">,</span> <span class="s">"three"</span><span class="p">,</span> <span class="s">"two"</span><span class="p">,</span> <span class="s">"one"</span><span class="p">]</span>
<span class="o">&gt;</span> <span class="p">[(</span><span class="mi">1</span><span class="p">,</span> <span class="s">"five"</span><span class="p">),</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="s">"four"</span><span class="p">),</span> <span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="s">"three"</span><span class="p">),</span> <span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="s">"two"</span><span class="p">),</span> <span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="s">"one"</span><span class="p">)]</span>
</code></pre> </div> <p>If the lengths of the lists do not match the longer list is cut off and ignored past the length of the shorter list.</p> <p>We can apply <code class="highlighter-rouge">zip</code> to pairings of finite and infinite lists, or two infinite lists</p> <div class="language-haskell highlighter-rouge"><pre class="highlight"><code><span class="o">&gt;</span> <span class="n">take</span> <span class="mi">10</span> <span class="p">(</span><span class="n">zip</span> <span class="p">[</span><span class="mi">1</span><span class="o">..</span><span class="p">]</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="o">..</span><span class="p">])</span>
<span class="o">&gt;</span> <span class="p">[(</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">),(</span><span class="mi">2</span><span class="p">,</span><span class="mi">0</span><span class="p">),(</span><span class="mi">3</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">),(</span><span class="mi">4</span><span class="p">,</span><span class="o">-</span><span class="mi">2</span><span class="p">),(</span><span class="mi">5</span><span class="p">,</span><span class="o">-</span><span class="mi">3</span><span class="p">),(</span><span class="mi">6</span><span class="p">,</span><span class="o">-</span><span class="mi">4</span><span class="p">),(</span><span class="mi">7</span><span class="p">,</span><span class="o">-</span><span class="mi">5</span><span class="p">),(</span><span class="mi">8</span><span class="p">,</span><span class="o">-</span><span class="mi">6</span><span class="p">),(</span><span class="mi">9</span><span class="p">,</span><span class="o">-</span><span class="mi">7</span><span class="p">),(</span><span class="mi">10</span><span class="p">,</span><span class="o">-</span><span class="mi">8</span><span class="p">)]</span>
</code></pre> </div> <h2 id="types-and-typeclasses">Types and typeclasses</h2> <p>The <code class="highlighter-rouge">:t</code> command can be used to determine the type of an expression.</p> <div class="language-haskell highlighter-rouge"><pre class="highlight"><code><span class="o">&gt;</span> <span class="o">:</span><span class="n">t</span> <span class="sc">'a'</span>
<span class="o">&gt;</span> <span class="sc">'a'</span> <span class="o">::</span> <span class="kt">Char</span>
<span class="o">&gt;</span> <span class="o">:</span><span class="n">t</span> <span class="kt">True</span>
<span class="o">&gt;</span> <span class="kt">True</span> <span class="o">::</span> <span class="kt">Bool</span>
<span class="o">&gt;</span> <span class="o">:</span><span class="n">t</span> <span class="p">(</span><span class="kt">True</span><span class="p">,</span> <span class="sc">'a'</span><span class="p">)</span>
<span class="o">&gt;</span> <span class="p">(</span><span class="kt">True</span><span class="p">,</span> <span class="sc">'a'</span><span class="p">)</span> <span class="o">::</span> <span class="p">(</span><span class="kt">Bool</span><span class="p">,</span> <span class="kt">Char</span><span class="p">)</span>
<span class="o">&gt;</span> <span class="o">:</span><span class="n">t</span> <span class="mi">4</span> <span class="o">==</span> <span class="mi">5</span>
<span class="o">&gt;</span> <span class="mi">4</span> <span class="o">==</span> <span class="mi">5</span> <span class="o">::</span> <span class="kt">Bool</span>
</code></pre> </div> <p><code class="highlighter-rouge">::</code> should be read as ‘has type of’. Explicit types are always denoted with the first letter in capital case.</p> <p>Functions also have types. When writing functions, we can give an explicit type declaration.</p> <div class="language-haskell highlighter-rouge"><pre class="highlight"><code><span class="n">removeNonUpercase</span> <span class="o">::</span> <span class="p">[</span><span class="kt">Char</span><span class="p">]</span> <span class="o">-&gt;</span> <span class="p">[</span><span class="kt">Char</span><span class="p">]</span>
<span class="n">removeNonUpercase</span> <span class="n">st</span> <span class="o">=</span> <span class="p">[</span> <span class="n">c</span> <span class="o">|</span> <span class="n">c</span> <span class="o">&lt;-</span> <span class="n">st</span><span class="p">,</span> <span class="n">c</span> <span class="p">`</span><span class="n">elem</span><span class="p">`</span> <span class="p">[</span><span class="sc">'A'</span><span class="o">..</span><span class="sc">'Z'</span><span class="p">]]</span>
</code></pre> </div> <p><code class="highlighter-rouge">removeNonUpercase</code> has a type of <code class="highlighter-rouge">[Char] -&gt; [Char]</code> as it maps a string to a string. We don’t have to give this function a type decleration because the compiler can infer it, however it is still good practice to do so.</p> <div class="language-haskell highlighter-rouge"><pre class="highlight"><code><span class="n">addThree</span> <span class="o">::</span> <span class="kt">Int</span> <span class="o">-&gt;</span> <span class="kt">Int</span> <span class="o">-&gt;</span> <span class="kt">Int</span> <span class="o">-&gt;</span> <span class="kt">Int</span>
<span class="n">addThree</span> <span class="n">x</span> <span class="n">y</span> <span class="n">z</span>  <span class="o">=</span> <span class="n">x</span> <span class="o">+</span> <span class="n">y</span> <span class="o">+</span> <span class="n">z</span>
</code></pre> </div> <p>The function above takes three parameters. The return type is the last item in the declaration and the parameters are the first three.</p> <h3 id="common-types">Common types</h3> <p><strong>Int</strong> A 32 or 64 bit signed integer</p> <p><strong>Integer</strong> A non-bounded integer</p> <p><strong>Float</strong> A real floating point value with single precision</p> <p><strong>Double</strong> A real floating point value with double precision</p> <p><strong>Bool</strong> A boolean type, <code class="highlighter-rouge">True</code> or <code class="highlighter-rouge">False</code></p> <p><strong>Char</strong> Represents a single character</p> <h3 id="type-variables">Type variables</h3> <p><code class="highlighter-rouge">head</code> takes a list of any type and returns the first element</p> <pre><code class="language-Haskell">&gt; :t head
&gt; head :: [a] -&gt; a
</code></pre> <p><code class="highlighter-rouge">a</code> is a type variable, meaning that it can be of any type. The type decleration of <code class="highlighter-rouge">head</code> means that it takes a list of some type <code class="highlighter-rouge">a</code> and returns a single instance of type <code class="highlighter-rouge">a</code>.</p> <p>This is much like generics in other languages.</p> <p>Functions that have type variables are called polymorphic functions.</p> <div class="language-haskell highlighter-rouge"><pre class="highlight"><code><span class="o">&gt;</span> <span class="o">:</span><span class="n">t</span> <span class="n">fst</span>
<span class="o">&gt;</span> <span class="n">fst</span> <span class="o">::</span> <span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">a</span>
</code></pre> </div> <p><code class="highlighter-rouge">fst</code> takes a tuple which conatins two types, and returns an element which is of the same type as the first item in the pair.</p> <p>Note that despite the differing names of <code class="highlighter-rouge">a</code> and <code class="highlighter-rouge">b</code> they can be the same type.</p> <h3 id="typeclasses">Typeclasses</h3> <p>A typeclass behaves similarly to an interface. If a type is part of a typeclass, it supports and implements the behaviour that the typeclass describes.</p> <div class="language-haskell highlighter-rouge"><pre class="highlight"><code><span class="o">&gt;</span> <span class="o">:</span><span class="n">t</span> <span class="p">(</span><span class="o">==</span><span class="p">)</span>
<span class="o">&gt;</span> <span class="p">(</span><span class="o">==</span><span class="p">)</span> <span class="o">::</span> <span class="p">(</span><span class="kt">Eq</span> <span class="n">a</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="n">a</span> <span class="o">-&gt;</span> <span class="n">a</span> <span class="o">-&gt;</span> <span class="o">-&gt;</span> <span class="kt">Bool</span>
</code></pre> </div> <p>The <code class="highlighter-rouge">=&gt;</code> symbol is called a class constraint. The euqality function takes any two values that are of the same type and returns a <code class="highlighter-rouge">Bool</code>. The class constraint is that the type of those two values must be a member of the <code class="highlighter-rouge">Eq</code> class.</p> <p>The <code class="highlighter-rouge">Eq</code> typeclass provides an interface for testing for equality. Any type where it makes sense to test for equality between two values of that type should be a member of the <code class="highlighter-rouge">Eq</code> class. All standard Haskell types except for IO and functions are part of the <code class="highlighter-rouge">Eq</code> typeclass.</p> <p>Consider the <code class="highlighter-rouge">elem</code> function which has a type of <code class="highlighter-rouge">(Eq a) =&gt; a -&gt; [a] -&gt; Bool</code> because it uses <code class="highlighter-rouge">==</code> over a list to check whether some value is contained.</p> <h4 id="common-typeclasses">Common Typeclasses</h4> <p><strong>Eq</strong> Used for types that support equality testing. Members must implement <code class="highlighter-rouge">==</code> and <code class="highlighter-rouge">/=</code></p> <p><strong>Ord</strong> Used for types which have ordering. <code class="highlighter-rouge">Ord</code> covers <code class="highlighter-rouge">&gt;, &lt;, &gt;=, </code> and <code class="highlighter-rouge">&lt;=</code></p> <p>The <code class="highlighter-rouge">compare</code> function takes two <code class="highlighter-rouge">Ord</code> members of the same type and returns an ordering. <code class="highlighter-rouge">Ordering</code> is a type that can be <code class="highlighter-rouge">GT</code>, <code class="highlighter-rouge">LT</code>, or <code class="highlighter-rouge">EQ</code>.</p> <p>To be a member of <code class="highlighter-rouge">Ord</code>, a type must first be a member of <code class="highlighter-rouge">Eq</code></p> <p><strong>Show</strong> Used for types that can be presented as strings. The most used function that deals with <code class="highlighter-rouge">Show</code> is <code class="highlighter-rouge">show</code>/ It takes a value whose type is a member of <code class="highlighter-rouge">Show</code> and presents it as a string.</p> <p><strong>Read</strong> The <code class="highlighter-rouge">read</code> function takes a string and returns a type which is a member of <code class="highlighter-rouge">Read</code></p> <div class="language-haskell highlighter-rouge"><pre class="highlight"><code><span class="o">&gt;</span> <span class="n">read</span> <span class="s">"True"</span> <span class="o">||</span> <span class="kt">False</span>
<span class="o">&gt;</span> <span class="kt">True</span>
<span class="o">&gt;</span> <span class="n">read</span> <span class="s">"8.2"</span> <span class="o">+</span> <span class="mf">3.8</span>
<span class="o">&gt;</span> <span class="mf">12.0</span>
<span class="o">&gt;</span> <span class="n">read</span> <span class="s">"[1,2,3,4]"</span> <span class="o">++</span> <span class="p">[</span><span class="mi">3</span><span class="p">]</span>
<span class="o">&gt;</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">3</span><span class="p">]</span>
</code></pre> </div> <p>If we try <code class="highlighter-rouge">read "4"</code> an exception will be raised.</p> <div class="language-haskell highlighter-rouge"><pre class="highlight"><code><span class="o">&lt;</span><span class="n">interactive</span><span class="o">&gt;:</span><span class="mi">1</span><span class="o">:</span><span class="mi">0</span><span class="o">:</span>  
    <span class="kt">Ambiguous</span> <span class="kr">type</span> <span class="n">variable</span> <span class="p">`</span><span class="n">a'</span> <span class="kr">in</span> <span class="n">the</span> <span class="n">constraint</span><span class="o">:</span>  
      <span class="p">`</span><span class="kt">Read</span> <span class="n">a'</span> <span class="n">arising</span> <span class="n">from</span> <span class="n">a</span> <span class="n">use</span> <span class="kr">of</span> <span class="p">`</span><span class="n">read'</span> <span class="n">at</span> <span class="o">&lt;</span><span class="n">interactive</span><span class="o">&gt;:</span><span class="mi">1</span><span class="o">:</span><span class="mi">0</span><span class="o">-</span><span class="mi">7</span>  
    <span class="kt">Probable</span> <span class="n">fix</span><span class="o">:</span> <span class="n">add</span> <span class="n">a</span> <span class="kr">type</span> <span class="n">signature</span> <span class="n">that</span> <span class="n">fixes</span> <span class="n">these</span> <span class="kr">type</span> <span class="n">variable</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
</code></pre> </div> <p>The return type cannot be determined. Previously our use of the return value could be used to determine its type.</p> <div class="language-haskell highlighter-rouge"><pre class="highlight"><code><span class="o">&gt;</span> <span class="o">:</span><span class="n">t</span> <span class="n">read</span>
<span class="o">&gt;</span> <span class="n">read</span> <span class="o">::</span> <span class="p">(</span><span class="kt">Read</span> <span class="n">a</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="kt">String</span> <span class="o">-&gt;</span> <span class="n">a</span>
</code></pre> </div> <p><code class="highlighter-rouge">read</code> returns a type that is part of <code class="highlighter-rouge">Read</code>, but if we do not use the value the type cannot be determined. We can use explicit type annotations to overcome this problem.</p> <div class="language-haskell highlighter-rouge"><pre class="highlight"><code><span class="o">&gt;</span> <span class="n">read</span> <span class="s">"5"</span> <span class="o">::</span> <span class="kt">Int</span>
<span class="o">&gt;</span> <span class="mi">5</span>
<span class="o">&gt;</span> <span class="n">read</span> <span class="s">"5"</span> <span class="o">::</span> <span class="kt">Float</span>
<span class="o">&gt;</span> <span class="mf">5.0</span>
<span class="o">&gt;</span> <span class="n">read</span> <span class="s">"(3, 'a')"</span> <span class="o">::</span> <span class="p">(</span><span class="kt">Int</span><span class="p">,</span> <span class="kt">Char</span><span class="p">)</span>
<span class="o">&gt;</span> <span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="sc">'a'</span><span class="p">)</span>
</code></pre> </div> <p>Most expressions provide sufficient detail that the compiler can infer what their type is by itself.</p> <p><strong>Enum</strong> Enum members are sequentially ordered types.</p> <p>The <code class="highlighter-rouge">Enum</code> typeclass can be used in list ranges. They also have defined successors and predecessors. <code class="highlighter-rouge">(), Bool, Char, Ordering, Int, Integer, Float</code>, and <code class="highlighter-rouge">Double</code> are in this class.</p> <div class="language-haskell highlighter-rouge"><pre class="highlight"><code><span class="o">&gt;</span> <span class="p">[</span><span class="sc">'a'</span><span class="o">..</span><span class="sc">'e'</span><span class="p">]</span>
<span class="o">&gt;</span> <span class="s">"abcde"</span>
<span class="o">&gt;</span> <span class="p">[</span><span class="kt">LT</span><span class="o">..</span><span class="kt">GT</span><span class="p">]</span>
<span class="o">&gt;</span> <span class="p">[</span><span class="kt">LT</span><span class="p">,</span> <span class="kt">EQ</span><span class="p">,</span> <span class="kt">GT</span><span class="p">]</span>
<span class="o">&gt;</span> <span class="n">succ</span> <span class="sc">'B'</span>
<span class="o">&gt;</span> <span class="sc">'C'</span>
</code></pre> </div> <p><strong>Bounded</strong> Members of this typeclass have an upper and lower bound.</p> <p>Both <code class="highlighter-rouge">minBound</code> and <code class="highlighter-rouge">maxBound</code> have a type of <code class="highlighter-rouge">(Bounded a) =&gt; a</code>. Tuples are part of <code class="highlighter-rouge">Bounded</code> if all of their components are.</p> <div class="language-haskell highlighter-rouge"><pre class="highlight"><code><span class="o">&gt;</span> <span class="n">minBound</span> <span class="o">::</span> <span class="kt">Int</span>
<span class="o">&gt;</span> <span class="o">-</span><span class="mi">2147483648</span>
<span class="o">&gt;</span> <span class="n">maxBound</span> <span class="o">::</span> <span class="kt">Bool</span>
<span class="o">&gt;</span> <span class="kt">True</span>
<span class="o">&gt;</span> <span class="n">maxBound</span> <span class="o">::</span> <span class="p">(</span><span class="kt">Bool</span><span class="p">,</span> <span class="kt">Int</span><span class="p">,</span> <span class="kt">Char</span><span class="p">)</span>
<span class="o">&gt;</span> <span class="p">(</span><span class="kt">True</span><span class="p">,</span> <span class="mi">2147483647</span><span class="p">,</span> <span class="sc">'</span><span class="se">\1114111</span><span class="sc">')</span><span class="err">
</span></code></pre> </div> <p><strong>Num</strong> Is a numeric typeclass. Its members have the property of being able to act like numbers.</p> <p>Whole numbers are polymorphic constants. They can act like any type that’s a member of the <code class="highlighter-rouge">Num</code> typeclass.</p> <p>If we examine the type of <code class="highlighter-rouge">*</code> we can see that it accepts all numbers.</p> <div class="language-haskell highlighter-rouge"><pre class="highlight"><code><span class="o">&gt;</span> <span class="o">:</span><span class="n">t</span> <span class="p">(</span><span class="o">*</span><span class="p">)</span>
<span class="o">&gt;</span> <span class="p">(</span><span class="o">*</span><span class="p">)</span> <span class="o">::</span> <span class="p">(</span><span class="kt">Num</span> <span class="n">a</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="n">a</span> <span class="o">-&gt;</span> <span class="n">a</span> <span class="o">-&gt;</span> <span class="n">a</span>
</code></pre> </div> <p>As <code class="highlighter-rouge">*</code> takes two numbers of the same type, <code class="highlighter-rouge">(5 :: Int) * (6 :: Integer)</code> will result in an error.</p> <p>To be part of <code class="highlighter-rouge">Num</code>, a type must also be part of <code class="highlighter-rouge">Show</code> and <code class="highlighter-rouge">Eq</code>.</p> <p><strong>Integral</strong> Is a numeric typeclass containing <code class="highlighter-rouge">Int</code> and <code class="highlighter-rouge">Integer</code></p> <p><strong>Floating</strong> Is a numeric typeclass containing <code class="highlighter-rouge">Float</code> and <code class="highlighter-rouge">Double</code></p> <p>The <code class="highlighter-rouge">fromIntegral</code> function has a type declaration of <code class="highlighter-rouge">fromInegral :: (Num b, Integral a) =&gt; a -&gt; b</code>. It takes an integral number and turns it into a more general number.</p> <h2 id="syntax-in-functions">Syntax in functions</h2> <h3 id="pattern-matching">Pattern matching</h3> <p>Pattern matching is the process of specifying patterns to which data should conform and then checking to see if it does, deconstructing the data according to those patterns.</p> <p>When defining functions, separate bodies can be defined for different patterns.</p> <div class="language-haskell highlighter-rouge"><pre class="highlight"><code><span class="n">factorial</span> <span class="o">::</span> <span class="p">(</span><span class="kt">Integral</span> <span class="n">a</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="n">a</span> <span class="o">-&gt;</span> <span class="n">a</span>
<span class="n">factorial</span> <span class="mi">0</span> <span class="o">=</span> <span class="mi">1</span>
<span class="n">factorial</span> <span class="n">n</span> <span class="o">=</span> <span class="n">n</span> <span class="o">*</span> <span class="n">factorial</span><span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
</code></pre> </div> <p>Pattern matching can fail.</p> <div class="language-haskell highlighter-rouge"><pre class="highlight"><code><span class="n">charName</span> <span class="o">::</span> <span class="kt">Char</span> <span class="o">-&gt;</span> <span class="kt">String</span>
<span class="n">charName</span> <span class="sc">'a'</span> <span class="o">=</span> <span class="s">"Albert"</span>
<span class="n">charName</span> <span class="sc">'b'</span> <span class="o">=</span> <span class="s">"Bert"</span>
<span class="n">charName</span> <span class="sc">'c'</span> <span class="o">=</span> <span class="s">"Cecil"</span>
</code></pre> </div> <p>When called with an unexpected input, and exception will be raised <code class="highlighter-rouge">Non-exhaustive patterns in function charName</code></p> <p>Pattern matching can also be used on tuples.</p> <div class="language-haskell highlighter-rouge"><pre class="highlight"><code><span class="n">addVectors</span> <span class="o">::</span> <span class="p">(</span><span class="kt">Num</span> <span class="n">a</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">a</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">a</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">a</span><span class="p">)</span>
<span class="n">addVectors</span> <span class="n">a</span> <span class="n">b</span> <span class="o">=</span> <span class="p">(</span><span class="n">fst</span> <span class="n">a</span> <span class="o">+</span> <span class="n">fst</span> <span class="n">b</span><span class="p">,</span> <span class="n">snd</span> <span class="n">a</span> <span class="o">+</span> <span class="n">snd</span> <span class="n">b</span><span class="p">)</span>
</code></pre> </div> <p>Using pattern matching we can instead write the function as</p> <div class="language-haskell highlighter-rouge"><pre class="highlight"><code><span class="n">addVectors</span> <span class="p">(</span><span class="n">x1</span><span class="p">,</span> <span class="n">y1</span><span class="p">)</span> <span class="p">(</span><span class="n">x2</span><span class="p">,</span> <span class="n">y2</span><span class="p">)</span> <span class="o">=</span> <span class="p">(</span><span class="n">x1</span> <span class="o">+</span> <span class="n">x2</span><span class="p">,</span> <span class="n">y1</span> <span class="o">+</span> <span class="n">y2</span><span class="p">)</span>
</code></pre> </div> <p>There are no provided functions to extract the components of triples, but they can be easily written.</p> <div class="language-haskell highlighter-rouge"><pre class="highlight"><code><span class="n">first</span> <span class="o">::</span> <span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">c</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">a</span>
<span class="n">first</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="kr">_</span><span class="p">,</span> <span class="kr">_</span><span class="p">)</span> <span class="o">=</span> <span class="n">x</span>

<span class="n">second</span> <span class="o">::</span> <span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">b</span>
<span class="n">second</span> <span class="p">(</span><span class="kr">_</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="kr">_</span><span class="p">)</span> <span class="o">=</span> <span class="n">y</span>

<span class="n">third</span> <span class="o">::</span> <span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">c</span>
<span class="n">third</span> <span class="p">(</span><span class="kr">_</span><span class="p">,</span> <span class="kr">_</span><span class="p">,</span> <span class="n">z</span><span class="p">)</span> <span class="o">=</span> <span class="n">z</span>
</code></pre> </div> <p>It is also possible to pattern match in list comprehensions.</p> <div class="language-haskell highlighter-rouge"><pre class="highlight"><code><span class="o">&gt;</span> <span class="kr">let</span> <span class="n">xs</span> <span class="o">=</span> <span class="p">[(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">),</span> <span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">),</span> <span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">1</span><span class="p">)]</span>
<span class="o">&gt;</span> <span class="p">[</span><span class="n">a</span><span class="o">+</span><span class="n">b</span> <span class="o">|</span> <span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span> <span class="o">&lt;-</span> <span class="n">xs</span><span class="p">]</span>
<span class="o">&gt;</span> <span class="p">[</span><span class="mi">4</span><span class="p">,</span><span class="mi">7</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="mi">8</span><span class="p">,</span><span class="mi">11</span><span class="p">,</span><span class="mi">4</span><span class="p">]</span>
</code></pre> </div> <p>If a pattern match fails, it will move to the next element.</p> <p>We can pattern match against a list to make our own implementation of <code class="highlighter-rouge">head</code></p> <div class="language-haskell highlighter-rouge"><pre class="highlight"><code><span class="n">head'</span> <span class="o">::</span> <span class="p">[</span><span class="n">a</span><span class="p">]</span> <span class="o">-&gt;</span> <span class="n">a</span>
<span class="n">head'</span> <span class="kt">[]</span> <span class="o">=</span> <span class="ne">error</span> <span class="s">"Empty list has no head"</span>
<span class="n">head'</span> <span class="p">(</span><span class="n">x</span><span class="o">:</span><span class="kr">_</span><span class="p">)</span> <span class="o">=</span> <span class="n">x</span>
</code></pre> </div> <div class="language-haskell highlighter-rouge"><pre class="highlight"><code><span class="n">tell</span> <span class="o">::</span> <span class="p">(</span><span class="kt">Show</span> <span class="n">a</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="n">a</span><span class="p">]</span> <span class="o">-&gt;</span> <span class="kt">String</span>
<span class="n">tell</span> <span class="kt">[]</span> <span class="o">=</span> <span class="s">"The list is empty"</span>
<span class="n">tell</span> <span class="p">(</span><span class="n">x</span><span class="o">:</span><span class="kt">[]</span><span class="p">)</span> <span class="o">=</span> <span class="s">"The list has one element: "</span> <span class="o">++</span> <span class="n">show</span> <span class="n">x</span>
<span class="n">tell</span> <span class="p">(</span><span class="n">x</span><span class="o">:</span><span class="n">y</span><span class="o">:</span><span class="kt">[]</span><span class="p">)</span> <span class="o">=</span> <span class="s">"The list has two elements: "</span> <span class="o">++</span> <span class="n">show</span> <span class="n">x</span> <span class="o">++</span> <span class="s">" and "</span> <span class="o">++</span> <span class="n">show</span> <span class="n">y</span>
<span class="n">tell</span> <span class="p">(</span><span class="n">x</span><span class="o">:</span><span class="n">y</span><span class="o">:</span><span class="kr">_</span><span class="p">)</span> <span class="o">=</span> <span class="s">"The list is long. The first two elements are "</span> <span class="o">++</span> <span class="n">show</span> <span class="n">x</span> <span class="o">++</span> <span class="s">" and "</span> <span class="o">++</span> <span class="n">show</span> <span class="n">y</span>
</code></pre> </div> <p>The <code class="highlighter-rouge">tell</code> function is safe because it handles the empty list, singleton list, two element list, and lists with more than two elements.</p> <p>We could rewrite <code class="highlighter-rouge">(x:[])</code> and <code class="highlighter-rouge">(x:y:[])</code> as <code class="highlighter-rouge">[x]</code> and <code class="highlighter-rouge">[x,y]</code> respectively. We cannot however rewrite <code class="highlighter-rouge">(x:y:_)</code> with square brackets because it matches any list of length 2 or more.</p> <p>We can implement a recursive length function using list comprehension</p> <div class="language-haskell highlighter-rouge"><pre class="highlight"><code><span class="n">length'</span> <span class="o">::</span> <span class="p">(</span><span class="kt">Num</span> <span class="n">b</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="n">a</span><span class="p">]</span> <span class="o">-&gt;</span> <span class="n">b</span>
<span class="n">length'</span> <span class="kt">[]</span> <span class="o">=</span> <span class="mi">0</span>
<span class="n">length'</span> <span class="p">(</span><span class="kr">_</span><span class="o">:</span><span class="n">xs</span><span class="p">)</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">+</span> <span class="n">length</span><span class="p">`</span> <span class="n">xs</span>
</code></pre> </div> <p>We first define the result of a known input, the empty list. This is known as the edge condition. In the second pattern we split the list into a head and a tail, and then state that the length is 1 plus the length of the tail.</p> <div class="language-haskell highlighter-rouge"><pre class="highlight"><code><span class="n">sum'</span> <span class="o">::</span> <span class="p">(</span><span class="kt">Num</span> <span class="n">a</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="n">a</span><span class="p">]</span> <span class="o">-&gt;</span> <span class="n">a</span>
<span class="n">sum'</span> <span class="kt">[]</span> <span class="o">=</span> <span class="mi">0</span>
<span class="n">sum'</span> <span class="p">(</span><span class="n">x</span><span class="o">:</span><span class="n">xs</span><span class="p">)</span> <span class="o">=</span> <span class="n">x</span> <span class="o">+</span> <span class="n">sum</span><span class="p">`</span> <span class="n">xs</span>
</code></pre> </div> <h3 id="patterns">Patterns</h3> <p>Patterns are a method of breaking something up according to a pattern and binding it to names whilst still keeping a refernce to the whole thing.</p> <p><code class="highlighter-rouge">xs@(x:y:ys)</code> will match exactly the same thing as <code class="highlighter-rouge">x:y:ys</code> but the whole list can be accessed via <code class="highlighter-rouge">xs</code> instead of repeatedly typing <code class="highlighter-rouge">x:y:ys</code> within the function body.</p> <div class="language-haskell highlighter-rouge"><pre class="highlight"><code><span class="n">capital</span> <span class="o">::</span> <span class="kt">String</span> <span class="o">-&gt;</span> <span class="kt">String</span>
<span class="n">capital</span> <span class="s">""</span> <span class="o">=</span> <span class="s">"Empty string"</span>
<span class="n">capital</span> <span class="n">all</span><span class="o">@</span><span class="p">(</span><span class="n">x</span><span class="o">:</span><span class="n">xs</span><span class="p">)</span> <span class="o">=</span> <span class="s">"The first letter of "</span> <span class="o">++</span> <span class="n">all</span> <span class="o">++</span> <span class="s">" is "</span> <span class="o">+</span> <span class="p">[</span><span class="n">x</span><span class="p">]</span>
</code></pre> </div> <p>Patterns can be used to avoid needless repetition.</p> <p>Note that <code class="highlighter-rouge">++</code> cannot be used in pattern matching.</p> <h3 id="guards">Guards</h3> <p>While patterns make sure a value conforms to some form and allow destructuring it, guards are a way of testing whether some property or properties of a value are true or false. Guards are much more readable that a statement when there are several conditions.</p> <div class="language-haskell highlighter-rouge"><pre class="highlight"><code><span class="n">bmi</span> <span class="o">::</span> <span class="p">(</span><span class="kt">RealFloat</span> <span class="n">a</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="n">a</span> <span class="o">-&gt;</span> <span class="kt">String</span>
<span class="n">bmi</span> <span class="n">i</span>
  <span class="o">|</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="mf">18.5</span> <span class="o">=</span> <span class="s">"Underweight"</span>
  <span class="o">|</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="mi">25</span> <span class="o">=</span> <span class="s">"Normal"</span>
  <span class="o">|</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="mi">30</span> <span class="s">"Fat"</span>
  <span class="o">|</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="s">"Land whale"</span>
</code></pre> </div> <p>Guards are indicated by pipes that follow a function’s name and its parameters. They are usually indented.</p> <p>A guard is basically a boolean expression. If it evaluates to <code class="highlighter-rouge">True</code>, the corresponding body is used. Otherwise, the next guard is evaluated.</p> <p>The last guard will often be <code class="highlighter-rouge">otherwise</code>. <code class="highlighter-rouge">otherwise</code> is simply an alias for <code class="highlighter-rouge">True</code>, and catches everything.</p> <p>If all the guards of a function evaluate to <code class="highlighter-rouge">False</code> and there is no <code class="highlighter-rouge">otherwise</code> guard, evaluation falls through to the next pattern. If no suitable guards or patterns are found, an error is thrown.</p> <p>Guards can also be written inline, although it is less readable.</p> <div class="language-haskell highlighter-rouge"><pre class="highlight"><code><span class="n">max'</span> <span class="o">::</span> <span class="p">(</span><span class="kt">Ord</span> <span class="n">a</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="n">a</span> <span class="o">-&gt;</span> <span class="n">a</span> <span class="o">-&gt;</span> <span class="n">a</span>
<span class="n">max'</span> <span class="n">a</span> <span class="n">b</span> <span class="o">|</span> <span class="n">a</span> <span class="o">&gt;</span> <span class="n">b</span> <span class="o">=</span> <span class="n">a</span> <span class="o">|</span> <span class="n">otherwise</span> <span class="o">=</span> <span class="n">b</span>
</code></pre> </div> <div class="language-haskell highlighter-rouge"><pre class="highlight"><code><span class="n">compare'</span> <span class="o">::</span> <span class="p">(</span><span class="kt">Ord</span> <span class="n">a</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="n">a</span> <span class="o">-&gt;</span> <span class="n">a</span> <span class="o">-&gt;</span> <span class="kt">Ordering</span>
<span class="n">a</span> <span class="p">`</span><span class="n">compare</span><span class="p">`</span> <span class="n">b</span>
  <span class="o">|</span> <span class="n">a</span> <span class="o">&gt;</span> <span class="n">b</span> <span class="o">=</span> <span class="kt">GT</span>
  <span class="o">|</span> <span class="n">a</span> <span class="o">==</span> <span class="n">b</span> <span class="o">=</span> <span class="kt">EQ</span>
  <span class="o">|</span> <span class="n">otherwise</span> <span class="o">=</span> <span class="kt">LT</span>
</code></pre> </div> <h3 id="where">where</h3> <p>Take note of the repetition in the function below</p> <div class="language-haskell highlighter-rouge"><pre class="highlight"><code><span class="n">bmi</span> <span class="o">::</span> <span class="p">(</span><span class="kt">RealFloat</span> <span class="n">a</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="n">a</span> <span class="o">-&gt;</span> <span class="n">a</span> <span class="o">-&gt;</span> <span class="kt">String</span>
<span class="n">bmi</span> <span class="n">weight</span> <span class="n">height</span>
  <span class="o">|</span> <span class="n">weight</span> <span class="o">/</span> <span class="n">height</span> <span class="o">^</span><span class="mi">2</span> <span class="o">&lt;=</span> <span class="mf">18.5</span> <span class="o">=</span> <span class="s">"Underweight"</span>
  <span class="o">|</span> <span class="n">weight</span> <span class="o">/</span> <span class="n">height</span> <span class="o">^</span><span class="mi">2</span> <span class="o">&lt;=</span> <span class="mi">25</span> <span class="o">=</span> <span class="s">"Normal"</span>
  <span class="o">|</span> <span class="n">weight</span> <span class="o">/</span> <span class="n">height</span> <span class="o">^</span><span class="mi">2</span> <span class="o">&lt;=</span> <span class="mi">30</span> <span class="o">=</span> <span class="s">"Overweight"</span>
  <span class="o">|</span> <span class="n">otherwise</span> <span class="o">=</span> <span class="s">"Land whale"</span>
</code></pre> </div> <p>Rather than repeating the bmi calculation, we can use the where keyword.</p> <div class="language-haskell highlighter-rouge"><pre class="highlight"><code><span class="n">bmi</span> <span class="n">weight</span> <span class="n">height</span>
  <span class="o">|</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="mf">18.5</span> <span class="o">=</span> <span class="s">"Underweight"</span>
  <span class="o">|</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="mi">25</span> <span class="o">=</span> <span class="s">"Normal"</span>
  <span class="o">|</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="mi">30</span> <span class="o">=</span> <span class="s">"Overweight"</span>
  <span class="o">|</span> <span class="n">otherwise</span> <span class="o">=</span> <span class="s">"Land whale"</span>
  <span class="kr">where</span> <span class="n">i</span> <span class="o">=</span> <span class="n">weight</span> <span class="o">/</span> <span class="n">height</span> <span class="o">^</span><span class="mi">2</span>
</code></pre> </div> <p>The value defined in <code class="highlighter-rouge">where</code> is visible across the guards. <code class="highlighter-rouge">where</code> bindings are not shared across function bodies of different patterns. If you want several patterns of one function to access a shared name, the name must be defined globally.</p> <p>We could also write a pattern match.</p> <div class="language-haskell highlighter-rouge"><pre class="highlight"><code><span class="kr">where</span> <span class="n">bmi</span> <span class="o">=</span> <span class="n">weight</span> <span class="o">/</span> <span class="n">height</span> <span class="o">^</span><span class="mi">2</span>
  <span class="p">(</span><span class="n">underweight</span><span class="p">,</span> <span class="n">normal</span><span class="p">,</span> <span class="n">overweight</span><span class="p">)</span> <span class="o">=</span> <span class="p">(</span><span class="mf">18.5</span><span class="p">,</span> <span class="mi">25</span><span class="p">,</span> <span class="mi">30</span><span class="p">)</span>
</code></pre> </div> <p>Another trivial function might five someone their initials</p> <div class="language-haskell highlighter-rouge"><pre class="highlight"><code><span class="n">initials</span> <span class="o">::</span> <span class="kt">String</span> <span class="o">-&gt;</span> <span class="kt">String</span> <span class="o">-&gt;</span> <span class="kt">String</span>
<span class="n">initials</span> <span class="n">firstname</span> <span class="n">lastname</span> <span class="o">=</span> <span class="p">[</span><span class="n">f</span><span class="p">]</span> <span class="o">++</span> <span class="s">". "</span> <span class="o">++</span> <span class="p">[</span><span class="n">l</span><span class="p">]</span> <span class="o">++</span> <span class="s">"."</span>
  <span class="kr">where</span> <span class="p">(</span><span class="n">f</span><span class="o">:</span><span class="kr">_</span><span class="p">)</span> <span class="o">=</span> <span class="n">firstname</span>
        <span class="p">(</span><span class="n">l</span><span class="o">:</span><span class="kr">_</span><span class="p">)</span> <span class="o">=</span> <span class="n">lastname</span>  
</code></pre> </div> <p>In the same way that we have defined constants in <code class="highlighter-rouge">where</code> blocks, we can also define functions.</p> <div class="language-haskell highlighter-rouge"><pre class="highlight"><code><span class="n">calcBmis</span> <span class="o">::</span> <span class="p">(</span><span class="kt">RealFloat</span> <span class="n">a</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">[(</span><span class="n">a</span><span class="p">,</span> <span class="n">a</span><span class="p">)]</span> <span class="o">-&gt;</span> <span class="p">[</span><span class="n">a</span><span class="p">]</span>
<span class="n">calcBmis</span> <span class="n">xs</span> <span class="o">=</span> <span class="p">[</span><span class="n">bmi</span> <span class="n">w</span> <span class="n">h</span> <span class="o">|</span> <span class="p">(</span><span class="n">w</span><span class="p">,</span> <span class="n">h</span><span class="p">)</span> <span class="o">&lt;-</span> <span class="n">xs</span><span class="p">]</span>
  <span class="kr">where</span> <span class="n">bmi</span> <span class="n">weight</span> <span class="n">height</span> <span class="o">=</span> <span class="n">weight</span> <span class="o">/</span> <span class="n">height</span> <span class="o">^</span><span class="mi">2</span>
</code></pre> </div> <h3 id="let-it-be">Let it be</h3> <p><code class="highlighter-rouge">let</code> bindings are very similar to <code class="highlighter-rouge">where</code> bindings. <code class="highlighter-rouge">let</code> bindings allow you to bind variables anywhere and are themselves expressions. They do not span across guards.</p> <div class="language-haskell highlighter-rouge"><pre class="highlight"><code><span class="n">cyclinder</span> <span class="o">::</span> <span class="p">(</span><span class="kt">RealFloat</span> <span class="n">a</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="n">a</span> <span class="o">-&gt;</span> <span class="n">a</span> <span class="o">-&gt;</span> <span class="n">a</span>
<span class="n">cylinder</span> <span class="n">r</span> <span class="n">h</span> <span class="o">=</span>
  <span class="kr">let</span> <span class="n">sideArea</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">pi</span> <span class="o">*</span> <span class="n">r</span> <span class="o">*</span> <span class="n">h</span>
      <span class="n">topArea</span> <span class="o">=</span> <span class="n">pi</span> <span class="o">*</span> <span class="n">r</span><span class="o">^</span><span class="mi">2</span>
  <span class="kr">in</span> <span class="n">sideArea</span> <span class="o">+</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">topArea</span>
</code></pre> </div> <p>A <code class="highlighter-rouge">let</code> binding is of the form <code class="highlighter-rouge">let &lt;bindings&gt; in &lt;expression&gt;</code>. The names defined in the binding are accessible in the expression.</p> <p>This is similar to splitting up a calculation in another language.</p> <div class="language-kotlin highlighter-rouge"><pre class="highlight"><code><span class="k">fun</span> <span class="nf">cylinder</span><span class="p">(</span><span class="n">r</span><span class="p">:</span> <span class="n">Int</span><span class="p">,</span> <span class="n">h</span><span class="p">:</span> <span class="n">Int</span><span class="p">):</span> <span class="n">Float</span> <span class="p">{</span>
  <span class="kd">val</span> <span class="py">sideArea</span> <span class="p">=</span> <span class="m">2</span> <span class="p">*</span> <span class="n">Math</span><span class="p">.</span><span class="n">PI</span> <span class="p">*</span> <span class="n">r</span> <span class="p">*</span> <span class="n">h</span>
  <span class="kd">val</span> <span class="py">topArea</span> <span class="p">=</span> <span class="n">Math</span><span class="p">.</span><span class="n">PI</span> <span class="p">*</span> <span class="n">r</span> <span class="p">*</span> <span class="n">r</span>
  <span class="k">return</span> <span class="n">sideArea</span> <span class="p">+</span> <span class="m">2</span> <span class="p">*</span> <span class="n">topArea</span>
<span class="p">}</span>
</code></pre> </div> <p>The difference between <code class="highlighter-rouge">where</code> and <code class="highlighter-rouge">let</code> bindings is that while <code class="highlighter-rouge">where</code> bindings are just syntactic constructs, <code class="highlighter-rouge">let</code> bindings are actually expressions.</p> <p><code class="highlighter-rouge">let</code> bindings can be used almost anywhere, in the same way as <code class="highlighter-rouge">if</code> statements.</p> <div class="language-haskell highlighter-rouge"><pre class="highlight"><code><span class="o">&gt;</span> <span class="mi">4</span> <span class="o">*</span> <span class="p">(</span><span class="kr">let</span> <span class="n">a</span> <span class="o">=</span> <span class="mi">9</span> <span class="kr">in</span> <span class="n">a</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="mi">2</span>
<span class="o">&gt;</span> <span class="mi">42</span>
<span class="o">&gt;</span> <span class="p">[</span><span class="kr">let</span> <span class="n">square</span> <span class="n">x</span> <span class="o">=</span> <span class="n">x</span> <span class="o">*</span> <span class="n">x</span> <span class="kr">in</span> <span class="p">(</span><span class="n">square</span> <span class="mi">5</span><span class="p">,</span> <span class="n">square</span> <span class="mi">3</span><span class="p">,</span> <span class="n">square</span> <span class="mi">2</span><span class="p">)]</span>
<span class="o">&gt;</span> <span class="p">[(</span><span class="mi">25</span><span class="p">,</span> <span class="mi">9</span><span class="p">,</span> <span class="mi">4</span><span class="p">)]</span>
</code></pre> </div> <p>If we want to bind several variables in line, we can separate them with semicolons.</p> <div class="language-haskell highlighter-rouge"><pre class="highlight"><code><span class="o">&gt;</span> <span class="p">(</span><span class="kr">let</span> <span class="n">a</span> <span class="o">=</span> <span class="mi">100</span><span class="p">;</span> <span class="n">b</span> <span class="o">=</span> <span class="mi">200</span><span class="p">;</span> <span class="n">c</span> <span class="o">=</span> <span class="mi">300</span> <span class="kr">in</span> <span class="n">a</span><span class="o">*</span><span class="n">b</span><span class="o">*</span><span class="n">c</span><span class="p">,</span> <span class="kr">let</span> <span class="n">foo</span><span class="o">=</span><span class="s">"Hey"</span><span class="p">;</span> <span class="n">bar</span> <span class="o">=</span> <span class="s">"there!"</span> <span class="kr">in</span> <span class="n">foo</span> <span class="o">++</span> <span class="n">bar</span><span class="p">)</span>
<span class="o">&gt;</span> <span class="p">(</span><span class="mi">6000000</span><span class="p">,</span> <span class="s">"Hey there!"</span><span class="p">)</span>
</code></pre> </div> <p><code class="highlighter-rouge">let</code> bindings are very useful for quickly dismantling a tuple into components and binding them to names.</p> <div class="language-haskell highlighter-rouge"><pre class="highlight"><code><span class="o">&gt;</span> <span class="p">(</span><span class="kr">let</span> <span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">,</span><span class="n">c</span><span class="p">)</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">)</span> <span class="kr">in</span> <span class="n">a</span><span class="o">+</span><span class="n">b</span><span class="o">+</span><span class="n">c</span><span class="p">)</span><span class="o">*</span><span class="mi">100</span>
<span class="o">&gt;</span> <span class="mi">600</span>
</code></pre> </div> <p><code class="highlighter-rouge">let</code> bindings can also be used inside list comprehensions.</p> <div class="language-haskell highlighter-rouge"><pre class="highlight"><code><span class="n">calcBmis</span> <span class="o">::</span> <span class="p">(</span><span class="kt">RealFloat</span> <span class="n">a</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">[(</span><span class="n">a</span><span class="p">,</span> <span class="n">a</span><span class="p">)]</span> <span class="o">-&gt;</span> <span class="p">[</span><span class="n">a</span><span class="p">]</span>
<span class="n">calcBmis</span> <span class="n">xs</span> <span class="o">=</span> <span class="p">[</span><span class="n">bmi</span> <span class="o">|</span> <span class="p">(</span><span class="n">w</span><span class="p">,</span> <span class="n">h</span><span class="p">)</span> <span class="o">&lt;-</span> <span class="n">xs</span><span class="p">,</span> <span class="kr">let</span> <span class="n">bmi</span> <span class="o">=</span> <span class="n">w</span> <span class="o">/</span><span class="n">h</span><span class="o">^</span><span class="mi">2</span><span class="p">]</span>
</code></pre> </div> <p>We use <code class="highlighter-rouge">let</code> in a similar way to a predicate, the difference being that we do not filter the list. The names defined in a <code class="highlighter-rouge">let</code> are visible to the output function and all predicates and secitons that come after the binding.</p> <div class="language-haskell highlighter-rouge"><pre class="highlight"><code><span class="n">listOverweight</span> <span class="o">::</span> <span class="p">(</span><span class="kt">RealFloat</span> <span class="n">a</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">[(</span><span class="n">a</span><span class="p">,</span> <span class="n">a</span><span class="p">)]</span> <span class="o">-&gt;</span> <span class="p">[</span><span class="n">a</span><span class="p">]</span>
<span class="n">listOverweight</span> <span class="n">xs</span> <span class="o">::</span> <span class="p">[</span><span class="n">bmi</span> <span class="o">|</span> <span class="p">(</span><span class="n">w</span><span class="p">,</span> <span class="n">h</span><span class="p">)</span> <span class="o">&lt;-</span> <span class="n">xs</span><span class="p">,</span> <span class="kr">let</span> <span class="n">bmi</span> <span class="o">=</span> <span class="n">w</span> <span class="o">/</span> <span class="n">h</span><span class="o">^</span><span class="mi">2</span><span class="p">,</span> <span class="n">bmi</span> <span class="o">&gt;=</span> <span class="mi">25</span><span class="p">]</span>
</code></pre> </div> <p>We ommited the <code class="highlighter-rouge">in</code> part of the binding because the scope of the names is already predefined. If we used <code class="highlighter-rouge">let in</code>, the names would only be visible to that predicate.</p> <h3 id="case-expressions">Case expressions</h3> <p>The syntax for a case expression is simple</p> <div class="language-haskell highlighter-rouge"><pre class="highlight"><code><span class="kr">case</span> <span class="n">expression</span> <span class="kr">of</span> <span class="n">pattern</span> <span class="o">-&gt;</span> <span class="n">result</span>
                   <span class="n">pattern</span> <span class="o">-&gt;</span> <span class="n">result</span>
                   <span class="n">pattern</span> <span class="o">-&gt;</span> <span class="n">result</span>
                   <span class="o">...</span>
</code></pre> </div> <p><code class="highlighter-rouge">expression</code> is matched against the patterns. The first pattern that matches the expression is used. If it falls through the whole <code class="highlighter-rouge">case</code> an exception occurs.</p> <p>Whereas pattern matching on function parameters can only be done when defining functions, case expressions can be used pretty much anywhere. They are useful for pattern matching against something in the middle of an expression.</p> <h2 id="recursion">Recursion</h2> <p>The <code class="highlighter-rouge">maximum</code> function takes a list of instances of the <code class="highlighter-rouge">Ord</code> typeclass, and returns the largest of them.</p> <p>In an imperative language you might define this function as so</p> <div class="language-kotlin highlighter-rouge"><pre class="highlight"><code><span class="k">fun</span> <span class="nf">maximum</span><span class="p">(</span><span class="n">items</span><span class="p">:</span> <span class="n">Array</span><span class="p">&lt;</span><span class="n">Int</span><span class="p">&gt;):</span> <span class="n">Int</span> <span class="p">{</span>
  <span class="kd">var</span> <span class="py">max</span> <span class="p">=</span> <span class="n">Integer</span><span class="p">.</span><span class="n">MIN_VALUE</span>
  <span class="n">items</span><span class="p">.</span><span class="n">forEach</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">it</span> <span class="p">&gt;</span> <span class="n">max</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">max</span> <span class="p">=</span> <span class="n">it</span>
    <span class="p">}</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="n">max</span>
<span class="p">}</span>
</code></pre> </div> <p>In Haskell we might instead write our <code class="highlighter-rouge">maximum</code> function as follows</p> <div class="language-haskell highlighter-rouge"><pre class="highlight"><code><span class="n">maximum'</span> <span class="o">::</span> <span class="p">(</span><span class="kt">Ord</span> <span class="n">a</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="n">a</span><span class="p">]</span> <span class="o">-&gt;</span> <span class="n">a</span>
<span class="n">maximum'</span> <span class="kt">[]</span> <span class="o">=</span> <span class="ne">error</span> <span class="s">"Empty list"</span>
<span class="n">maximum'</span> <span class="p">[</span><span class="n">x</span><span class="p">]</span> <span class="o">=</span> <span class="n">x</span>
<span class="n">maximum'</span> <span class="p">(</span><span class="n">x</span><span class="o">:</span><span class="n">xs</span><span class="p">)</span>
    <span class="o">|</span> <span class="n">x</span> <span class="o">&gt;</span> <span class="n">maxTail</span> <span class="o">=</span> <span class="n">x</span>
    <span class="o">|</span> <span class="n">otherwise</span> <span class="o">=</span> <span class="n">maxTail</span>
    <span class="kr">where</span> <span class="n">maxTail</span> <span class="o">=</span> <span class="n">maximum'</span> <span class="n">xs</span>
</code></pre> </div> <p>We split the list into a head and a tail, and then compare the head to the maximum of the tail.</p> <p>Consider <code class="highlighter-rouge">[2, 5, 1]</code>. We reach the <code class="highlighter-rouge">(x:xs)</code> branch with a head of <code class="highlighter-rouge">2</code> and a tail of <code class="highlighter-rouge">[5, 1]</code>. <code class="highlighter-rouge">maximum'</code> is called on <code class="highlighter-rouge">[5, 1]</code>, reaching the same branch with a head of <code class="highlighter-rouge">5</code> and a tail of <code class="highlighter-rouge">[1]</code>. <code class="highlighter-rouge">maximum'</code> is called once more on <code class="highlighter-rouge">[1]</code> which returns <code class="highlighter-rouge">1</code>. We now cascade back up the call stack, comparing the head <code class="highlighter-rouge">5</code> to <code class="highlighter-rouge">1</code>, giving <code class="highlighter-rouge">5</code> and then comparing <code class="highlighter-rouge">5</code> (<code class="highlighter-rouge">maxTail</code>) to <code class="highlighter-rouge">2</code> and returning <code class="highlighter-rouge">5</code>.</p> <p>The function could be written more elegantly using <code class="highlighter-rouge">max</code>.</p> <div class="language-haskell highlighter-rouge"><pre class="highlight"><code><span class="n">maximum'</span> <span class="o">::</span> <span class="p">(</span><span class="kt">Ord</span> <span class="n">a</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="n">a</span><span class="p">]</span> <span class="o">-&gt;</span> <span class="n">a</span>
<span class="n">maximum'</span> <span class="kt">[]</span> <span class="o">=</span> <span class="ne">error</span> <span class="s">"Empty list"</span>
<span class="n">maximum'</span> <span class="p">[</span><span class="n">x</span><span class="p">]</span> <span class="o">=</span> <span class="n">x</span>
<span class="n">maximum'</span> <span class="p">(</span><span class="n">x</span><span class="o">:</span><span class="n">xs</span><span class="p">)</span> <span class="o">-</span> <span class="n">max</span> <span class="n">x</span> <span class="p">(</span><span class="n">maximum'</span> <span class="n">xs</span><span class="p">)</span>
</code></pre> </div> <h3 id="recursive-function-examples">Recursive function Examples</h3> <p><strong>Repliate</strong></p> <div class="language-haskell highlighter-rouge"><pre class="highlight"><code><span class="n">replicate'</span> <span class="o">::</span> <span class="p">(</span><span class="kt">Num</span> <span class="n">i</span><span class="p">,</span> <span class="kt">Ord</span> <span class="n">i</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="n">i</span> <span class="o">-&gt;</span> <span class="n">a</span> <span class="o">-&gt;</span> <span class="p">[</span><span class="n">a</span><span class="p">]</span>
<span class="n">replicate'</span> <span class="n">n</span> <span class="n">x</span>
  <span class="o">|</span> <span class="n">n</span> <span class="o">&lt;=</span> <span class="mi">0</span> <span class="o">=</span> <span class="kt">[]</span>
  <span class="o">|</span> <span class="n">otherwise</span> <span class="n">x</span><span class="o">:</span><span class="n">replicate</span><span class="p">`</span> <span class="p">(</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="n">x</span>
</code></pre> </div> <p>As we are testing boolean expressions we used guards. As <code class="highlighter-rouge">Num</code> is not a subclass of <code class="highlighter-rouge">Ord</code> we have to specify both class constraints.</p> <p><strong>Take</strong></p> <div class="language-haskell highlighter-rouge"><pre class="highlight"><code><span class="n">take'</span> <span class="o">::</span> <span class="p">(</span><span class="kt">Num</span> <span class="n">i</span><span class="p">,</span> <span class="kt">Ord</span> <span class="n">i</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="n">i</span> <span class="o">-&gt;</span> <span class="p">[</span><span class="n">a</span><span class="p">]</span> <span class="o">-&gt;</span> <span class="p">[</span><span class="n">a</span><span class="p">]</span>
<span class="n">take</span><span class="p">`</span> <span class="n">n</span> <span class="kr">_</span>
  <span class="o">|</span> <span class="n">n</span> <span class="o">&lt;=</span> <span class="mi">0</span> <span class="o">=</span> <span class="kt">[]</span>
<span class="n">take</span><span class="p">`</span> <span class="kr">_</span> <span class="kt">[]</span> <span class="o">=</span> <span class="kt">[]</span>
<span class="n">take</span><span class="p">`</span> <span class="n">n</span> <span class="p">(</span><span class="n">x</span><span class="o">:</span><span class="n">xs</span><span class="p">)</span> <span class="o">=</span> <span class="n">x</span><span class="o">:</span><span class="n">take</span><span class="p">`</span> <span class="p">(</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="n">xs</span>
</code></pre> </div> <p>The first pattern deals with negative values, the second with empty lists, and the third with lists containing some number of items. As our guard has no <code class="highlighter-rouge">otherwise</code>, the the matching will fall through when <code class="highlighter-rouge">n &gt; 0</code>.</p> <p><strong>Reverse</strong></p> <div class="language-haskell highlighter-rouge"><pre class="highlight"><code><span class="n">reverse'</span> <span class="o">::</span> <span class="p">[</span><span class="n">a</span><span class="p">]</span> <span class="o">-&gt;</span> <span class="p">[</span><span class="n">a</span><span class="p">]</span>
<span class="n">reverse'</span> <span class="kt">[]</span> <span class="o">=</span> <span class="kt">[]</span>
<span class="n">reverse'</span> <span class="p">(</span><span class="n">x</span><span class="o">:</span><span class="n">xs</span><span class="p">)</span> <span class="o">=</span> <span class="n">reverse'</span> <span class="n">xs</span> <span class="o">++</span> <span class="p">[</span><span class="n">x</span><span class="p">]</span>
</code></pre> </div> <p><strong>Repeat</strong></p> <p><code class="highlighter-rouge">repeat</code> takes an element and returns an infinite list of that element.</p> <div class="language-haskell highlighter-rouge"><pre class="highlight"><code><span class="n">repeat'</span> <span class="o">::</span> <span class="n">a</span> <span class="o">-&gt;</span> <span class="p">[</span><span class="n">a</span><span class="p">]</span>
<span class="n">repeat'</span> <span class="n">x</span> <span class="o">=</span> <span class="n">x</span><span class="o">:</span><span class="n">repeat</span> <span class="n">x</span>
</code></pre> </div> <p><strong>Repeat</strong></p> <p><code class="highlighter-rouge">zip</code> takes two lists and zips them together to a list of pairs.</p> <div class="language-haskell highlighter-rouge"><pre class="highlight"><code><span class="n">zip'</span> <span class="o">::</span> <span class="p">[</span><span class="n">a</span><span class="p">]</span> <span class="o">-&gt;</span> <span class="p">[</span><span class="n">b</span><span class="p">]</span> <span class="o">-&gt;</span> <span class="p">[(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)]</span>
<span class="n">zip'</span> <span class="kr">_</span> <span class="kt">[]</span> <span class="o">=</span> <span class="kt">[]</span>
<span class="n">zip'</span> <span class="kt">[]</span> <span class="kr">_</span> <span class="o">=</span> <span class="kt">[]</span>
<span class="n">zip'</span> <span class="p">(</span><span class="n">x</span><span class="o">:</span><span class="n">xs</span><span class="p">)</span> <span class="p">(</span><span class="n">y</span><span class="o">:</span><span class="n">ys</span><span class="p">)</span> <span class="o">=</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">)</span><span class="o">:</span><span class="n">zip</span> <span class="n">xs</span> <span class="n">ys</span>
</code></pre> </div> <p><strong>Elem</strong></p> <div class="language-haskell highlighter-rouge"><pre class="highlight"><code><span class="n">elem'</span> <span class="o">::</span> <span class="n">a</span> <span class="o">-&gt;</span> <span class="p">[</span><span class="n">a</span><span class="p">]</span> <span class="o">-&gt;</span> <span class="kt">Bool</span>
<span class="n">elem'</span> <span class="n">a</span> <span class="kt">[]</span> <span class="o">=</span> <span class="kt">False</span>
<span class="n">elem'</span> <span class="n">a</span> <span class="p">(</span><span class="n">x</span><span class="o">:</span><span class="n">xs</span><span class="p">)</span>
  <span class="o">|</span> <span class="n">a</span> <span class="o">==</span> <span class="n">x</span> <span class="o">=</span> <span class="kt">True</span>
  <span class="o">|</span> <span class="n">otherwise</span> <span class="o">=</span> <span class="n">a</span> <span class="p">`</span><span class="n">elem</span><span class="p">`</span> <span class="n">xs</span>
</code></pre> </div> <h3 id="quick-sort">Quick sort</h3> <p>Implementing QuickSort is much easier in Haskell than in imperative languages.</p> <div class="language-haskell highlighter-rouge"><pre class="highlight"><code><span class="n">quicksort</span> <span class="o">::</span> <span class="p">(</span><span class="kt">Ord</span> <span class="n">a</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="n">a</span><span class="p">]</span> <span class="o">-&gt;</span> <span class="p">[</span><span class="n">a</span><span class="p">]</span>
<span class="n">quicksort</span> <span class="kt">[]</span> <span class="o">=</span> <span class="kt">[]</span>
<span class="n">quicksort</span> <span class="p">(</span><span class="n">x</span><span class="o">:</span><span class="n">xs</span><span class="p">)</span> <span class="o">=</span>
  <span class="kr">let</span> <span class="n">smallerSorted</span> <span class="o">=</span> <span class="n">quicksort</span> <span class="p">[</span><span class="n">a</span> <span class="o">|</span> <span class="n">a</span> <span class="o">&lt;-</span> <span class="n">xs</span><span class="p">,</span> <span class="n">a</span> <span class="o">&lt;=</span> <span class="n">x</span><span class="p">]</span>
      <span class="n">biggerSorted</span> <span class="o">=</span> <span class="n">quicksort</span> <span class="p">[</span><span class="n">a</span> <span class="o">|</span> <span class="n">a</span> <span class="o">&lt;-</span> <span class="n">xs</span><span class="p">,</span> <span class="n">a</span> <span class="o">&lt;=</span> <span class="n">x</span><span class="p">]</span>
  <span class="kr">in</span> <span class="n">smallerSorted</span> <span class="o">++</span> <span class="p">[</span><span class="n">x</span><span class="p">]</span> <span class="o">++</span> <span class="n">biggerSorted</span>
</code></pre> </div> <p>This Quicksort implementation uses the head as a pivot for the sorting.</p> <h2 id="higher-order-functions">Higher order functions</h2> <p>Functions in Haskell can take functions as parameters and return functions. A function that does either of those is called a higher order function.</p> <h3 id="curried-functions">Curried functions</h3> <p>Every function in Haskell only takes one parameter. All the functions which take several parameters are curried functions.</p> <p>The following two calls are equivalent</p> <div class="language-haskell highlighter-rouge"><pre class="highlight"><code><span class="o">&gt;</span> <span class="n">max</span> <span class="mi">4</span> <span class="mi">5</span>
<span class="o">&gt;</span> <span class="p">(</span><span class="n">max</span> <span class="mi">4</span><span class="p">)</span> <span class="mi">5</span>
</code></pre> </div> <p>Calling <code class="highlighter-rouge">max 4 5</code> first creates a function which takes a single parameter and returns either <code class="highlighter-rouge">4</code> or that parameter, whichever is larger. It then applies that function to <code class="highlighter-rouge">5</code>.</p> <p>Putting a space between two pieces of code is simply function application. The space is like an operator with the highest precedence.</p> <p>Again considering <code class="highlighter-rouge">max</code></p> <div class="language-haskell highlighter-rouge"><pre class="highlight"><code><span class="n">max</span> <span class="o">::</span> <span class="p">(</span><span class="kt">Ord</span> <span class="n">a</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="n">a</span> <span class="o">-&gt;</span> <span class="n">a</span><span class="o">-&gt;</span> <span class="n">a</span>
<span class="n">max</span> <span class="o">::</span> <span class="p">(</span><span class="kt">Ord</span> <span class="n">a</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="n">a</span> <span class="o">-&gt;</span> <span class="p">(</span><span class="n">a</span> <span class="o">-&gt;</span> <span class="n">a</span><span class="p">)</span>
</code></pre> </div> <p>The second line could be read as <code class="highlighter-rouge">max</code> takes an <code class="highlighter-rouge">a</code> and returns a function that takes another <code class="highlighter-rouge">a</code> and returns an <code class="highlighter-rouge">a</code>. The return type of each functions are separated with the arrows.</p> <p>Consider the following function</p> <div class="language-haskell highlighter-rouge"><pre class="highlight"><code><span class="n">multThree</span> <span class="o">::</span> <span class="p">(</span><span class="kt">Num</span> <span class="n">a</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="n">a</span> <span class="o">-&gt;</span> <span class="n">a</span> <span class="o">-&gt;</span> <span class="n">a</span> <span class="o">-&gt;</span> <span class="n">a</span>
<span class="n">multThree</span> <span class="n">x</span> <span class="n">y</span> <span class="n">z</span> <span class="o">=</span> <span class="n">x</span> <span class="o">*</span> <span class="n">y</span> <span class="o">*</span> <span class="n">z</span>
</code></pre> </div> <p>When we call <code class="highlighter-rouge">multThree 3 5 9</code> we are actually calling <code class="highlighter-rouge">((multThree 3) 5) 9</code>. This means that <code class="highlighter-rouge">3</code> is applied to <code class="highlighter-rouge">multThree</code> to create a function that takes one parameter and returns a function. Next, <code class="highlighter-rouge">5</code> is applied to that function, and returns a function which takes a single parameter and multiplies it by <code class="highlighter-rouge">15</code>. Finally, <code class="highlighter-rouge">9</code> is applied to that function and the result is <code class="highlighter-rouge">135</code>.</p> <p>By calling functions without some of their parameters, we can create new functions.</p> <div class="language-haskell highlighter-rouge"><pre class="highlight"><code><span class="o">&gt;</span> <span class="kr">let</span> <span class="n">multTwoWithNine</span> <span class="o">=</span> <span class="n">multThree</span> <span class="mi">9</span>
<span class="o">&gt;</span> <span class="n">multTwoWithNine</span> <span class="mi">2</span> <span class="mi">3</span>
<span class="o">&gt;</span> <span class="mi">54</span>
<span class="o">&gt;</span> <span class="kr">let</span> <span class="n">multWithEighteen</span> <span class="o">=</span> <span class="n">multTwoWithNine</span> <span class="mi">2</span>
<span class="o">&gt;</span> <span class="n">multWithEighteen</span> <span class="mi">10</span>
<span class="o">&gt;</span> <span class="mi">180</span>
</code></pre> </div> <p>Infix functions can also be partially applied by using sections. To section an infix function, surround it with parentheses and only supply a parameter on one side.</p> <div class="language-haskell highlighter-rouge"><pre class="highlight"><code><span class="n">divTen</span> <span class="o">::</span> <span class="p">(</span><span class="kt">Floating</span> <span class="n">a</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="n">a</span> <span class="o">-&gt;</span> <span class="n">a</span>
<span class="n">divTen</span> <span class="o">=</span> <span class="p">(</span><span class="o">/</span><span class="mi">10</span><span class="p">)</span>
<span class="n">isUpperAlphanum</span> <span class="o">::</span> <span class="kt">Char</span> <span class="o">-&gt;</span> <span class="kt">Bool</span>
<span class="n">isUpperAlphanum</span> <span class="o">=</span> <span class="p">(</span><span class="sc">'e</span><span class="err">l</span><span class="n">em'</span> <span class="p">[</span><span class="sc">'A'</span><span class="o">..</span><span class="sc">'Z'</span><span class="p">])</span>
</code></pre> </div> <p>Note that when using sections, <code class="highlighter-rouge">-</code> cannot be used directly. <code class="highlighter-rouge">(-4)</code> means <code class="highlighter-rouge">-4</code>. To make a function which takes a value and subtracts <code class="highlighter-rouge">4</code> from it you must replace the <code class="highlighter-rouge">-</code> with <code class="highlighter-rouge">subtract</code>, <code class="highlighter-rouge">(subtract 4)</code>.</p> <h3 id="higher-order-functions-1">Higher order functions</h3> <div class="language-haskell highlighter-rouge"><pre class="highlight"><code><span class="n">applyTwice</span> <span class="o">::</span> <span class="p">(</span><span class="n">a</span> <span class="o">-&gt;</span> <span class="n">a</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">a</span> <span class="o">-&gt;</span> <span class="n">a</span>
<span class="n">applyTwice</span> <span class="n">f</span> <span class="n">x</span> <span class="o">=</span> <span class="n">f</span> <span class="p">(</span><span class="n">f</span> <span class="n">x</span><span class="p">)</span>
</code></pre> </div> <p>Notice that the type declaration contains parentheses. They are mandatory when one of the parameters is a function.</p> <div class="language-haskell highlighter-rouge"><pre class="highlight"><code><span class="o">&gt;</span> <span class="n">applyTwice</span> <span class="p">(</span><span class="o">+</span><span class="mi">4</span><span class="p">)</span> <span class="mi">10</span>
<span class="o">&gt;</span> <span class="mi">18</span>
</code></pre> </div> <p>We can now re-implement another standard library function, <code class="highlighter-rouge">zipWith</code>. <code class="highlighter-rouge">zipWith</code> takes a function and two lists as parameters and then joins the two lists by applying the function between corresponding elements.</p> <div class="language-haskell highlighter-rouge"><pre class="highlight"><code><span class="n">zipWith'</span> <span class="p">(</span><span class="n">a</span> <span class="o">-&gt;</span> <span class="n">b</span> <span class="o">-&gt;</span> <span class="n">c</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="p">[</span><span class="n">a</span><span class="p">]</span> <span class="o">-&gt;</span> <span class="n">b</span> <span class="o">-&gt;</span> <span class="p">[</span><span class="n">c</span><span class="p">]</span>
<span class="n">zipWith'</span> <span class="kr">_</span> <span class="kt">[]</span> <span class="kr">_</span> <span class="o">=</span> <span class="kt">[]</span>
<span class="n">zipWith'</span> <span class="kr">_</span> <span class="kr">_</span> <span class="kt">[]</span> <span class="o">=</span> <span class="kt">[]</span>
<span class="n">zipWith'</span> <span class="n">f</span> <span class="p">(</span><span class="n">x</span><span class="o">:</span><span class="n">xs</span><span class="p">)</span> <span class="p">(</span><span class="n">y</span><span class="o">:</span><span class="n">ys</span><span class="p">)</span> <span class="o">=</span> <span class="n">f</span> <span class="n">x</span> <span class="n">y</span> <span class="o">:</span> <span class="n">zipWith'</span> <span class="n">f</span> <span class="n">xs</span> <span class="n">ys</span>
</code></pre> </div> <p>In the type decleration the first parameter is a function that takes two things and produces a third. The second and third parameters are lists, and the return value is a list, with each list matching the respective types of the arguments of the first function.</p> <div class="language-haskell highlighter-rouge"><pre class="highlight"><code><span class="o">&gt;</span> <span class="n">zipWith'</span> <span class="p">(</span><span class="o">+</span><span class="p">)</span> <span class="p">[</span><span class="mi">4</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">]</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">]</span>
<span class="o">&gt;</span> <span class="p">[</span><span class="mi">6</span><span class="p">,</span><span class="mi">8</span><span class="p">,</span><span class="mi">7</span><span class="p">,</span><span class="mi">9</span><span class="p">]</span>
</code></pre> </div> <p>Another standard library function is <code class="highlighter-rouge">flip</code>. It takes a function and returns a function which is like the original function, but with the first two arguments flipped.</p> <div class="language-haskell highlighter-rouge"><pre class="highlight"><code><span class="n">flip'</span> <span class="o">::</span> <span class="p">(</span><span class="n">a</span> <span class="o">-&gt;</span> <span class="n">b</span> <span class="o">-&gt;</span> <span class="n">c</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="p">(</span><span class="n">b</span> <span class="o">-&gt;</span> <span class="n">a</span> <span class="o">-&gt;</span> <span class="n">c</span><span class="p">)</span>
<span class="n">flip'</span> <span class="n">f</span> <span class="o">=</span> <span class="n">g</span>
  <span class="kr">where</span> <span class="n">g</span> <span class="n">x</span> <span class="n">y</span> <span class="o">=</span> <span class="n">f</span> <span class="n">y</span> <span class="n">x</span>
</code></pre> </div> <p>Reading the type declaration we say that <code class="highlighter-rouge">flip'</code> takes a function that takes an <code class="highlighter-rouge">a</code> and a <code class="highlighter-rouge">b</code>, and returns a function that takes a <code class="highlighter-rouge">b</code> and an <code class="highlighter-rouge">a</code>. Because functions are curried by default, the second pair of parentheses is really unnecessary, because <code class="highlighter-rouge">-&gt;</code> is right associative by default.</p> <p><code class="highlighter-rouge">(a -&gt; b -&gt; c) -&gt; (b -&gt; a -&gt; c)</code> is the same as <code class="highlighter-rouge">(a -&gt; b -&gt; c) -&gt; (b -&gt; (a -&gt; c))</code> which is the same as <code class="highlighter-rouge">(a -&gt; b -&gt; c) -&gt; b -&gt; a -&gt; c</code>.</p> <p>We can further simplify the function by writing it as</p> <div class="language-haskell highlighter-rouge"><pre class="highlight"><code><span class="n">flip'</span> <span class="o">::</span> <span class="p">(</span><span class="n">a</span> <span class="o">-&gt;</span> <span class="n">b</span> <span class="o">-&gt;</span> <span class="n">c</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">b</span> <span class="o">-&gt;</span> <span class="n">a</span> <span class="o">-&gt;</span> <span class="n">c</span>
<span class="n">flip'</span> <span class="n">f</span> <span class="n">y</span> <span class="n">x</span> <span class="o">=</span> <span class="n">f</span> <span class="n">x</span> <span class="n">y</span>
</code></pre> </div> <h3 id="maps-and-filters">Maps and filters</h3> <p><strong>map</strong> Takes a function and a list and applies that function to every element in the list, producing a new list.</p> <p>The definition of <code class="highlighter-rouge">map</code> is</p> <div class="language-haskell highlighter-rouge"><pre class="highlight"><code><span class="n">map</span> <span class="o">::</span> <span class="p">(</span><span class="n">a</span> <span class="o">-&gt;</span> <span class="n">b</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="p">[</span><span class="n">a</span><span class="p">]</span> <span class="o">-&gt;</span> <span class="p">[</span><span class="n">b</span><span class="p">]</span>
<span class="n">map</span> <span class="kr">_</span> <span class="kt">[]</span> <span class="o">=</span> <span class="kt">[]</span>
<span class="n">map</span> <span class="n">f</span> <span class="p">(</span><span class="n">x</span><span class="o">:</span><span class="n">xs</span><span class="p">)</span> <span class="o">=</span> <span class="n">f</span> <span class="n">x</span> <span class="o">:</span> <span class="n">map</span> <span class="n">f</span> <span class="n">xs</span>
</code></pre> </div> <div class="language-haskell highlighter-rouge"><pre class="highlight"><code><span class="o">&gt;</span> <span class="n">map</span> <span class="p">(</span><span class="o">+</span><span class="mi">2</span><span class="p">)</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">]</span>
<span class="o">&gt;</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">]</span>
</code></pre> </div> <p>This is much more readable than the equivalent list comprehension <code class="highlighter-rouge">[x+2 | x &lt;- [1,2,3,4]]</code>.</p> <p><strong>filter</strong> is a function that takes a predicate and a list and returns the elements of the list that satisfy the predicate</p> <div class="language-haskell highlighter-rouge"><pre class="highlight"><code><span class="n">filter</span> <span class="o">::</span> <span class="p">(</span><span class="n">a</span> <span class="o">-&gt;</span> <span class="kt">Bool</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="p">[</span><span class="n">a</span><span class="p">]</span> <span class="o">-&gt;</span> <span class="p">[</span><span class="n">a</span><span class="p">]</span>
<span class="n">filter</span> <span class="kr">_</span> <span class="kt">[]</span> <span class="o">=</span> <span class="kt">[]</span>
<span class="n">filter</span> <span class="n">p</span> <span class="p">(</span><span class="n">x</span><span class="o">:</span><span class="n">xs</span><span class="p">)</span>
  <span class="o">|</span> <span class="n">p</span> <span class="n">x</span> <span class="o">=</span> <span class="n">x</span> <span class="o">:</span> <span class="n">filter</span> <span class="n">p</span> <span class="n">xs</span>
  <span class="o">|</span> <span class="n">otherwise</span> <span class="o">=</span> <span class="n">filter</span> <span class="n">p</span> <span class="n">xs</span>
</code></pre> </div> <div class="language-haskell highlighter-rouge"><pre class="highlight"><code><span class="o">&gt;</span> <span class="n">filter</span> <span class="p">(</span><span class="o">&gt;</span><span class="mi">3</span><span class="p">)</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="mi">7</span><span class="p">,</span><span class="mi">8</span><span class="p">,</span><span class="mi">9</span><span class="p">]</span>
<span class="o">&gt;</span> <span class="p">[</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="mi">7</span><span class="p">,</span><span class="mi">8</span><span class="p">,</span><span class="mi">9</span><span class="p">]</span>
<span class="o">&gt;</span> <span class="kr">let</span> <span class="n">notNull</span> <span class="n">x</span> <span class="o">=</span> <span class="n">not</span> <span class="p">(</span><span class="n">null</span> <span class="n">x</span><span class="p">)</span> <span class="kr">in</span> <span class="n">filter</span> <span class="n">notNull</span> <span class="p">[[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">],</span><span class="kt">[]</span><span class="p">,[</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">],[</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">],</span><span class="kt">[]</span><span class="p">,</span><span class="kt">[]</span><span class="p">]</span>
<span class="o">&gt;</span> <span class="p">[[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">],[</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">],[</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">]]</span>
</code></pre> </div> <p>Recalling the earlier implementation of QuickSort, we can replace the list comprehensions with calls to filter.</p> <div class="language-haskell highlighter-rouge"><pre class="highlight"><code><span class="n">quicksort</span> <span class="o">::</span> <span class="p">(</span><span class="kt">Ord</span> <span class="n">a</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="n">a</span><span class="p">]</span> <span class="o">-&gt;</span> <span class="p">[</span><span class="n">a</span><span class="p">]</span>
<span class="n">quicksort</span> <span class="kt">[]</span> <span class="o">=</span> <span class="kt">[]</span>
<span class="n">quicksort</span> <span class="p">(</span><span class="n">x</span><span class="o">:</span><span class="n">xs</span><span class="p">)</span> <span class="o">=</span>
  <span class="kr">let</span> <span class="n">smallerSorted</span> <span class="o">=</span> <span class="n">quicksort</span> <span class="p">(</span><span class="n">filter</span> <span class="p">(</span><span class="o">&lt;=</span><span class="n">x</span><span class="p">)</span> <span class="n">xs</span><span class="p">)</span>
      <span class="n">biggerSorted</span> <span class="o">=</span> <span class="n">quicksort</span> <span class="p">(</span><span class="n">filter</span> <span class="p">(</span><span class="o">&gt;</span><span class="n">x</span><span class="p">)</span> <span class="n">xs</span><span class="p">)</span>
  <span class="kr">in</span> <span class="n">smallerSorted</span> <span class="o">++</span> <span class="p">[</span><span class="n">x</span><span class="p">]</span> <span class="o">++</span> <span class="n">biggerSorted</span>
</code></pre> </div> <p><strong>takeWhile</strong> is a function that takes a list and a predicate and returns all of the elements from the start of the list while the predicate returns true</p> <p>Suppose we wish to find the sum of all odd square that are less than <code class="highlighter-rouge">10000</code></p> <div class="language-haskell highlighter-rouge"><pre class="highlight"><code><span class="o">&gt;</span> <span class="n">sum</span> <span class="p">(</span><span class="n">takeWhile</span> <span class="p">(</span><span class="o">&lt;</span><span class="mi">10000</span><span class="p">)</span> <span class="p">(</span><span class="n">filter</span> <span class="n">odd</span> <span class="p">(</span><span class="n">map</span> <span class="p">(</span><span class="o">^</span><span class="mi">2</span><span class="p">)</span> <span class="p">[</span><span class="mi">1</span><span class="o">..</span><span class="p">])))</span>
<span class="o">&gt;</span> <span class="mi">166650</span>
</code></pre> </div> <p>In the Collatz sequence, we start with a natural number. If the number is even we divide it by 2. If the number is odd we multiply it by 3 and add 1. We take the resulting value and apply the same process to it, stopping when we reach one.</p> <div class="language-haskell highlighter-rouge"><pre class="highlight"><code><span class="n">chain</span> <span class="o">::</span> <span class="p">(</span><span class="kt">Integral</span> <span class="n">a</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="n">a</span> <span class="o">-&gt;</span> <span class="p">[</span><span class="n">a</span><span class="p">]</span>
<span class="n">chain</span> <span class="mi">1</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">]</span>
<span class="n">chain</span> <span class="n">n</span>
  <span class="o">|</span> <span class="n">even</span> <span class="n">n</span> <span class="o">=</span> <span class="n">n</span><span class="o">:</span><span class="n">chain</span> <span class="p">(</span><span class="n">n</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span>
  <span class="o">|</span> <span class="n">odd</span> <span class="n">n</span> <span class="o">=</span> <span class="n">n</span><span class="o">:</span><span class="n">chain</span> <span class="p">(</span><span class="n">n</span><span class="o">*</span><span class="mi">3</span> <span class="o">+</span> <span class="mi">2</span><span class="p">)</span>
</code></pre> </div> <div class="language-haskell highlighter-rouge"><pre class="highlight"><code><span class="o">&gt;</span> <span class="n">chain</span> <span class="mi">10</span>
<span class="o">&gt;</span> <span class="p">[</span><span class="mi">10</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">16</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span>
</code></pre> </div> <h3 id="lambdas">Lambdas</h3> <p>Lambdas are anonymous functions that are used because we need some functions only once, and do not want to pollute the namespace. We write a lambda with a \newline and then write the parameters, followed by a <code class="highlighter-rouge">-&gt;</code> and then the function body.</p> <p>Filtering for long chains we might write</p> <div class="language-haskell highlighter-rouge"><pre class="highlight"><code><span class="n">numLongChains</span> <span class="o">::</span> <span class="kt">Int</span>
<span class="n">numLongChains</span> <span class="o">=</span> <span class="n">length</span> <span class="p">(</span><span class="n">filter</span> <span class="p">(</span><span class="nf">\</span><span class="n">xs</span> <span class="o">-&gt;</span> <span class="n">length</span> <span class="n">xs</span> <span class="o">&gt;</span> <span class="mi">15</span><span class="p">)</span> <span class="p">(</span><span class="n">map</span> <span class="n">chain</span> <span class="p">[</span><span class="mi">1</span><span class="o">..</span><span class="mi">100</span><span class="p">]))</span>
</code></pre> </div> <p>Lambdas can take any number of parameters in the same way as normal functions</p> <div class="language-haskell highlighter-rouge"><pre class="highlight"><code><span class="o">&gt;</span> <span class="n">zipWith</span> <span class="p">(</span><span class="nf">\</span><span class="n">a</span> <span class="n">b</span> <span class="o">-&gt;</span> <span class="p">(</span><span class="n">a</span> <span class="o">*</span> <span class="mi">30</span> <span class="o">+</span> <span class="mi">3</span><span class="p">)</span> <span class="o">/</span> <span class="n">b</span><span class="p">)</span> <span class="p">[</span><span class="mi">5</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">]</span>
<span class="o">&gt;</span> <span class="p">[</span><span class="mf">153.0</span><span class="p">,</span> <span class="mf">61.5</span><span class="p">,</span> <span class="mf">31.0</span><span class="p">,</span> <span class="mf">15.75</span><span class="p">,</span> <span class="mf">6.6</span><span class="p">]</span>
</code></pre> </div> <p>As with normal functions, we can pattern match in lambdas.</p> <div class="language-haskell highlighter-rouge"><pre class="highlight"><code><span class="o">&gt;</span> <span class="n">map</span> <span class="p">(</span><span class="nf">\</span><span class="n">newline</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">a</span> <span class="o">+</span> <span class="n">b</span><span class="p">)</span> <span class="p">[(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">),(</span><span class="mi">3</span><span class="p">,</span><span class="mi">5</span><span class="p">),(</span><span class="mi">6</span><span class="p">,</span><span class="mi">3</span><span class="p">),(</span><span class="mi">2</span><span class="p">,</span><span class="mi">6</span><span class="p">),(</span><span class="mi">2</span><span class="p">,</span><span class="mi">5</span><span class="p">)]</span>
<span class="o">&gt;</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span><span class="mi">8</span><span class="p">,</span><span class="mi">9</span><span class="p">,</span><span class="mi">8</span><span class="p">,</span><span class="mi">7</span><span class="p">]</span>
</code></pre> </div> <p>Due to the way we curry functions, the following two are equivalent</p> <div class="language-haskell highlighter-rouge"><pre class="highlight"><code><span class="n">addThree</span> <span class="o">::</span> <span class="p">(</span><span class="kt">Num</span> <span class="n">a</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="n">a</span> <span class="o">-&gt;</span> <span class="n">a</span> <span class="o">-&gt;</span> <span class="n">a</span> <span class="o">-&gt;</span> <span class="n">a</span>
<span class="n">addThree</span> <span class="n">x</span> <span class="n">y</span> <span class="n">z</span> <span class="o">=</span> <span class="n">x</span> <span class="o">+</span> <span class="n">y</span> <span class="o">+</span> <span class="n">z</span>
</code></pre> </div> <div class="language-haskell highlighter-rouge"><pre class="highlight"><code><span class="n">addThree</span> <span class="o">::</span> <span class="p">(</span><span class="kt">Num</span> <span class="n">a</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="n">a</span> <span class="o">-&gt;</span> <span class="n">a</span> <span class="o">-&gt;</span> <span class="n">a</span> <span class="o">-&gt;</span> <span class="n">a</span>
<span class="n">addThree</span> <span class="o">=</span> <span class="nf">\</span><span class="n">x</span> <span class="o">-&gt;</span> <span class="nf">\</span><span class="n">y</span> <span class="o">-&gt;</span> <span class="nf">\</span><span class="n">z</span> <span class="o">-&gt;</span> <span class="n">x</span> <span class="o">+</span> <span class="n">y</span> <span class="o">+</span> <span class="n">z</span>
</code></pre> </div> <p>While the example above decreases readability, it can aid with the understanding of some functions, such as <code class="highlighter-rouge">flip</code></p> <div class="highlighter-rouge"><pre class="highlight"><code>flip' :: (a -&gt; b -&gt; c) -&gt; b -&gt; a -&gt; c
flip' f = \x y -&gt; f y x
</code></pre> </div> <h3 id="folding">Folding</h3> <p><strong>foldl</strong> The left fold the folds a list up form the left side</p> <div class="language-haskell highlighter-rouge"><pre class="highlight"><code><span class="n">sum'</span> <span class="o">::</span> <span class="p">(</span><span class="kt">Num</span> <span class="n">a</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="n">a</span><span class="p">]</span> <span class="o">-&gt;</span> <span class="n">a</span>
<span class="n">sum'</span> <span class="n">xs</span> <span class="o">=</span> <span class="n">foldl</span> <span class="p">(</span><span class="nf">\</span><span class="n">acc</span> <span class="n">x</span> <span class="o">-&gt;</span> <span class="n">acc</span> <span class="o">+</span> <span class="n">x</span><span class="p">)</span> <span class="mi">0</span> <span class="n">xs</span>
</code></pre> </div> <p>In the example above <code class="highlighter-rouge">\acc x -&gt; acc + x</code> is the binary function. <code class="highlighter-rouge">0</code> is the starting value and <code class="highlighter-rouge">xs</code> is the list to be folded up.</p> <div class="language-haskell highlighter-rouge"><pre class="highlight"><code><span class="o">&gt;</span> <span class="n">sum'</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span>
<span class="o">&gt;</span> <span class="mi">11</span>
</code></pre> </div> <p>At each step we have | <code class="highlighter-rouge">0 + 3</code> | <code class="highlighter-rouge">[3,5,2,1]</code> | | <code class="highlighter-rouge">3 + 5</code> | <code class="highlighter-rouge">[5,2,1]</code> | | <code class="highlighter-rouge">8 + 2</code> | <code class="highlighter-rouge">[2,1]</code> | | <code class="highlighter-rouge">10 + 1</code>| <code class="highlighter-rouge">[1]</code> | | <code class="highlighter-rouge">11</code> | |</p> <p>We could implement <code class="highlighter-rouge">elem</code> using <code class="highlighter-rouge">foldl</code></p> <div class="language-haskell highlighter-rouge"><pre class="highlight"><code><span class="n">elem'</span> <span class="o">::</span> <span class="p">(</span><span class="kt">Eq</span> <span class="n">a</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="n">a</span> <span class="o">-&gt;</span> <span class="p">[</span><span class="n">a</span><span class="p">]</span> <span class="o">-&gt;</span> <span class="kt">Bool</span>
<span class="n">elem'</span> <span class="n">y</span> <span class="n">ys</span> <span class="o">=</span> <span class="n">foldl</span> <span class="p">(</span><span class="nf">\</span><span class="n">acc</span> <span class="n">x</span> <span class="o">-&gt;</span> <span class="kr">if</span> <span class="n">x</span> <span class="o">==</span> <span class="n">y</span> <span class="kr">then</span> <span class="kt">True</span> <span class="kr">else</span> <span class="n">acc</span><span class="p">)</span> <span class="kt">False</span> <span class="n">ys</span>
</code></pre> </div> <p>The starting value and accumulator above are both boolean values.</p> <p><strong>foldr</strong> Works in a similar way to <strong>foldl</strong>, except that it consumes values from the right <code class="highlighter-rouge">foldr</code> takes the accumulator as the second function.</p> <p>We can implement <code class="highlighter-rouge">map</code> with a <code class="highlighter-rouge">foldr</code>.</p> <div class="language-haskell highlighter-rouge"><pre class="highlight"><code><span class="n">map'</span> <span class="o">::</span> <span class="p">(</span><span class="n">a</span> <span class="o">-&gt;</span> <span class="n">b</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="p">[</span><span class="n">a</span><span class="p">]</span> <span class="o">-&gt;</span> <span class="p">[</span><span class="n">b</span><span class="p">]</span>
<span class="n">map'</span> <span class="n">f</span> <span class="n">xs</span> <span class="o">=</span> <span class="n">foldr</span> <span class="p">(</span><span class="nf">\</span><span class="n">x</span> <span class="n">acc</span> <span class="o">-&gt;</span> <span class="n">f</span> <span class="n">x</span> <span class="o">:</span> <span class="n">acc</span><span class="p">)</span> <span class="kt">[]</span> <span class="n">xs</span>
</code></pre> </div> <p>If we map <code class="highlighter-rouge">(+3)</code> to <code class="highlighter-rouge">[1,2,3]</code>, we approach the list from the right side. We take the first element <code class="highlighter-rouge">3</code> and apply the function to it, giving <code class="highlighter-rouge">6</code>. We prepend <code class="highlighter-rouge">6</code> to the accumulator. We then apply <code class="highlighter-rouge">(+3)</code> to <code class="highlighter-rouge">2</code>, giving <code class="highlighter-rouge">5</code>, and prepend it to the accumulator. Continuing in the same manner we reach <code class="highlighter-rouge">[4,5,6]</code>.</p> <p>One notable difference is that <code class="highlighter-rouge">folr</code> works on infinite lists, while <code class="highlighter-rouge">foldl</code> does not.</p> <p>Folds can be used to implement any function were you traverse a list once.</p> <p>There are also the functions <code class="highlighter-rouge">foldl1</code> and <code class="highlighter-rouge">foldr1</code> which do not require a starting value, instead assuming that the first value in their traversal order is the starting value.</p> <p>This would allow an implementation of sum as <code class="highlighter-rouge">sum = foldl1 (+)</code>, although it would cause an error on an empty list.</p> <h4 id="fold-implementations-of-standard-library-functions">Fold implementations of standard library functions</h4> <div class="language-haskell highlighter-rouge"><pre class="highlight"><code><span class="n">maximum'</span> <span class="o">::</span> <span class="p">(</span><span class="kt">Ord</span> <span class="n">a</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="n">a</span><span class="p">]</span> <span class="o">-&gt;</span> <span class="n">a</span>
<span class="n">maximum'</span> <span class="o">=</span> <span class="n">foldr1</span> <span class="p">(</span><span class="nf">\</span><span class="n">x</span> <span class="n">acc</span> <span class="o">-&gt;</span> <span class="kr">if</span> <span class="n">x</span> <span class="o">&gt;</span> <span class="n">acc</span> <span class="kr">then</span> <span class="n">x</span> <span class="kr">else</span> <span class="n">acc</span><span class="p">)</span>

<span class="n">reverse'</span> <span class="o">::</span> <span class="p">[</span><span class="n">a</span><span class="p">]</span> <span class="o">-&gt;</span> <span class="p">[</span><span class="n">a</span><span class="p">]</span>
<span class="n">reverse'</span> <span class="o">=</span> <span class="n">foldl</span> <span class="p">(</span><span class="nf">\</span><span class="n">acc</span> <span class="n">x</span> <span class="o">-&gt;</span> <span class="n">x</span> <span class="o">:</span> <span class="n">acc</span><span class="p">)</span> <span class="kt">[]</span>

<span class="n">product'</span> <span class="o">::</span> <span class="p">(</span><span class="kt">Num</span> <span class="n">a</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="n">a</span><span class="p">]</span> <span class="o">-&gt;</span> <span class="n">a</span>
<span class="n">product'</span> <span class="o">=</span> <span class="n">foldr1</span> <span class="p">(</span><span class="o">*</span><span class="p">)</span>

<span class="n">filter'</span> <span class="o">::</span> <span class="p">(</span><span class="n">a</span> <span class="o">-&gt;</span> <span class="kt">Bool</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="p">[</span><span class="n">a</span><span class="p">]</span> <span class="o">-&gt;</span> <span class="p">[</span><span class="n">a</span><span class="p">]</span>
<span class="n">filter'</span> <span class="n">p</span> <span class="o">=</span> <span class="n">foldr</span> <span class="p">(</span><span class="nf">\</span><span class="n">x</span> <span class="n">acc</span> <span class="o">-&gt;</span> <span class="kr">if</span> <span class="n">p</span> <span class="n">x</span> <span class="kr">then</span> <span class="n">x</span> <span class="o">:</span> <span class="n">acc</span> <span class="kr">else</span> <span class="n">acc</span><span class="p">)</span> <span class="kt">[]</span>

<span class="n">head'</span> <span class="o">::</span> <span class="p">[</span><span class="n">a</span><span class="p">]</span> <span class="o">-&gt;</span> <span class="n">a</span>
<span class="n">head'</span> <span class="o">=</span> <span class="n">foldr1</span> <span class="p">(</span><span class="nf">\</span><span class="n">x</span> <span class="kr">_</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="p">)</span>

<span class="n">last'</span> <span class="o">::</span> <span class="p">[</span><span class="n">a</span><span class="p">]</span> <span class="o">-&gt;</span> <span class="n">a</span>
<span class="n">last'</span> <span class="o">=</span> <span class="n">foldl1</span> <span class="p">(</span><span class="nf">\</span><span class="kr">_</span> <span class="n">x</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="p">)</span>
</code></pre> </div> <p>The <code class="highlighter-rouge">head</code> function would be better implemented by pattern matching, as the <code class="highlighter-rouge">fold</code> traverses the entire list.</p> <p>In <code class="highlighter-rouge">reverse</code> we take a starting value of an empty list and append each value from the left to our list.</p> <h3 id="scanl-and-scanr"><code class="highlighter-rouge">scanl</code> and <code class="highlighter-rouge">scanr</code></h3> <p><code class="highlighter-rouge">scanl</code> and <code class="highlighter-rouge">scanr</code> are like <code class="highlighter-rouge">foldl</code> and <code class="highlighter-rouge">foldr</code>, with the difference being that they report all the intermediate accumulator states in the form of a list. There are also <code class="highlighter-rouge">scanl1</code> and <code class="highlighter-rouge">scanr1</code></p> <div class="language-haskell highlighter-rouge"><pre class="highlight"><code><span class="o">&gt;</span> <span class="n">scanl</span> <span class="p">(</span><span class="o">+</span><span class="p">)</span> <span class="mi">0</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span>
<span class="o">&gt;</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">8</span><span class="p">,</span><span class="mi">10</span><span class="p">,</span><span class="mi">11</span><span class="p">]</span>
<span class="o">&gt;</span> <span class="n">scanr</span> <span class="p">(</span><span class="o">+</span><span class="p">)</span> <span class="mi">0</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span>
<span class="o">&gt;</span> <span class="p">[</span><span class="mi">11</span><span class="p">,</span><span class="mi">8</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span>
<span class="o">&gt;</span> <span class="n">scanl1</span> <span class="p">(</span><span class="nf">\</span><span class="n">acc</span> <span class="n">x</span> <span class="o">-&gt;</span> <span class="kr">if</span> <span class="n">x</span> <span class="o">&gt;</span> <span class="n">acc</span> <span class="kr">then</span> <span class="n">x</span> <span class="kr">else</span> <span class="n">acc</span><span class="p">)</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">3</span><span class="p">,,</span><span class="mi">7</span><span class="p">,</span><span class="mi">9</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span>
<span class="o">&gt;</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">7</span><span class="p">,</span><span class="mi">9</span><span class="p">,</span><span class="mi">9</span><span class="p">,</span><span class="mi">9</span><span class="p">]</span>
<span class="o">&gt;</span> <span class="n">scanl</span> <span class="p">(</span><span class="n">flip</span> <span class="p">(</span><span class="o">:</span><span class="p">))</span> <span class="kt">[]</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span>
<span class="o">&gt;</span> <span class="p">[</span><span class="kt">[]</span><span class="p">,[</span><span class="mi">3</span><span class="p">],[</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">],[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">]]</span>
</code></pre> </div> <p>Scans are used to monitor the progression of a function that can be implemented as a fold.</p> <h3 id="function-application-with-">Function application with $</h3> <p>The <code class="highlighter-rouge">$</code> function is also called function application.</p> <div class="language-haskell highlighter-rouge"><pre class="highlight"><code><span class="p">(</span><span class="o">$</span><span class="p">)</span> <span class="o">::</span> <span class="p">(</span><span class="n">a</span> <span class="o">-&gt;</span> <span class="n">b</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">a</span> <span class="o">-&gt;</span> <span class="n">b</span>
<span class="n">f</span> <span class="o">$</span> <span class="n">x</span> <span class="o">=</span> <span class="n">f</span> <span class="n">x</span>
</code></pre> </div> <p>Whereas normal function application has the highest precedence, <code class="highlighter-rouge">$</code> has the lowest precedence.</p> <p>Function application with a space is left-associative so <code class="highlighter-rouge">f a b c</code> is the same as <code class="highlighter-rouge">((f a) b) c</code>. Function application with <code class="highlighter-rouge">$</code> is right associative.</p> <p>Consider the expression <code class="highlighter-rouge">sum (map sqrt [1..130])</code>. We can instead write <code class="highlighter-rouge">sum $ map sqrt [1..130]</code>. When a <code class="highlighter-rouge">$</code> is encountered the expression on its right is applied as the parameter to the function on its left.</p> <p>Consider <code class="highlighter-rouge">sqrt (3 + 4 + 9)</code>. We could instead write this as <code class="highlighter-rouge">sqrt $ 3 + 4 + 9</code>.</p> <p>In <code class="highlighter-rouge">sum (filter (&gt; 10) (map (*2) [2..10]))</code> we can write <code class="highlighter-rouge">sum $ filter (&gt; 10) $ map (*2) [2..10]</code> because <code class="highlighter-rouge">f (g (z x))</code> is equal to <code class="highlighter-rouge">f $ g $ z x</code>.</p> <h3 id="function-composition">Function composition</h3> <p>In Haskell, function composition is performed with the <code class="highlighter-rouge">.</code> function, which is defined as follows</p> <div class="language-haskell highlighter-rouge"><pre class="highlight"><code><span class="p">(</span><span class="o">.</span><span class="p">)</span> <span class="o">::</span> <span class="p">(</span><span class="n">b</span> <span class="o">-&gt;</span> <span class="n">c</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="p">(</span><span class="n">a</span> <span class="o">-&gt;</span> <span class="n">b</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">a</span> <span class="o">-&gt;</span> <span class="n">c</span>
<span class="n">f</span> <span class="o">.</span> <span class="n">g</span> <span class="o">=</span> <span class="nf">\</span><span class="n">x</span> <span class="o">-&gt;</span> <span class="n">f</span> <span class="p">(</span><span class="n">g</span> <span class="n">x</span><span class="p">)</span>
</code></pre> </div> <p><code class="highlighter-rouge">f</code> must take as its parameter a value that has the same type as <code class="highlighter-rouge">g</code>’s return value.</p> <p>One of the uses for function composition is making functions on the fly to pass to other functions, which is often cleaner and more concise than lambdas.</p> <div class="language-haskell highlighter-rouge"><pre class="highlight"><code><span class="o">&gt;</span> <span class="n">map</span> <span class="p">(</span><span class="nf">\</span><span class="n">x</span> <span class="o">-&gt;</span> <span class="n">negate</span> <span class="p">(</span><span class="n">abs</span> <span class="n">x</span><span class="p">))</span> <span class="p">[</span><span class="mi">5</span><span class="p">,</span><span class="o">-</span><span class="mi">3</span><span class="p">,</span><span class="o">-</span><span class="mi">6</span><span class="p">,</span><span class="mi">7</span><span class="p">,</span><span class="o">-</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="o">-</span><span class="mi">19</span><span class="p">,</span><span class="mi">24</span><span class="p">]</span>
<span class="o">&gt;</span> <span class="p">[</span><span class="o">-</span><span class="mi">5</span><span class="p">,</span><span class="o">-</span><span class="mi">3</span><span class="p">,</span><span class="o">-</span><span class="mi">6</span><span class="p">,</span><span class="o">-</span><span class="mi">7</span><span class="p">,</span><span class="o">-</span><span class="mi">3</span><span class="p">,</span><span class="o">-</span><span class="mi">2</span><span class="p">,</span><span class="o">-</span><span class="mi">19</span><span class="p">,</span><span class="o">-</span><span class="mi">24</span><span class="p">]</span>
<span class="o">&gt;</span> <span class="n">map</span> <span class="p">(</span><span class="n">negate</span> <span class="o">.</span> <span class="n">abs</span><span class="p">)</span> <span class="p">[</span><span class="mi">5</span><span class="p">,</span><span class="o">-</span><span class="mi">3</span><span class="p">,</span><span class="o">-</span><span class="mi">6</span><span class="p">,</span><span class="mi">7</span><span class="p">,</span><span class="o">-</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="o">-</span><span class="mi">19</span><span class="p">,</span><span class="mi">24</span><span class="p">]</span>
<span class="o">&gt;</span> <span class="p">[</span><span class="o">-</span><span class="mi">5</span><span class="p">,</span><span class="o">-</span><span class="mi">3</span><span class="p">,</span><span class="o">-</span><span class="mi">6</span><span class="p">,</span><span class="o">-</span><span class="mi">7</span><span class="p">,</span><span class="o">-</span><span class="mi">3</span><span class="p">,</span><span class="o">-</span><span class="mi">2</span><span class="p">,</span><span class="o">-</span><span class="mi">19</span><span class="p">,</span><span class="o">-</span><span class="mi">24</span><span class="p">]</span>
</code></pre> </div> <p>Function composition is right associative, so multiple functions can be composed together.</p> <h4 id="function-composition-with-multiple-parameters">Function composition with multiple parameters</h4> <p>If we want to use a function with multiple parameters in a function composition, we usually have to partially apply them so that each function takes just one parameter.</p> <p><code class="highlighter-rouge">sum (replicate 5 (max 6.7 8.9))</code> can be rewritten as <code class="highlighter-rouge">(sum . replicate 5. max 6.7) 8.9</code> or as <code class="highlighter-rouge">sum . replicate 5 . max 6.7 $ 8.9</code>.</p> <p>What is happening is the creation of a function that takes what <code class="highlighter-rouge">max 6.7</code> takes and applies <code class="highlighter-rouge">replicate 5</code> to it. Then a function that takes the result of that and does a sum of it is create. Finally, that unction is called with <code class="highlighter-rouge">8.9</code>. However it is more easily read as taking the value of <code class="highlighter-rouge">max 6.7 8.9</code>, replicating it <code class="highlighter-rouge">5</code> times, and taking the sum of that replication.</p> <p>If you want to rewrite a function with lots of parentheses you can start by putting the last parameter of the innermost function after a $, and replacing each pair of parentheses with a <code class="highlighter-rouge">.</code>.</p> <p><code class="highlighter-rouge">replicate 100 (product (map (*3) (zipWith max [1,2,3,4,5] [4,5,6,7,8])))</code> can be rewritten as <code class="highlighter-rouge">replicate 100 . product . map (*3) . zipWith max [1,2,3,4,5] $ [4,5,6,7,8]</code>.</p> <p>The free point style allows functions to be written more cleanly</p> <div class="language-haskell highlighter-rouge"><pre class="highlight"><code><span class="n">fn</span> <span class="n">x</span> <span class="o">=</span> <span class="n">ceiling</span> <span class="p">(</span><span class="n">negate</span> <span class="p">(</span><span class="n">tan</span> <span class="p">(</span><span class="n">cos</span> <span class="p">(</span><span class="n">max</span> <span class="mi">50</span> <span class="n">x</span><span class="p">))))</span>
</code></pre> </div> <p>can instead be written</p> <div class="language-haskell highlighter-rouge"><pre class="highlight"><code><span class="n">fn</span> <span class="o">=</span> <span class="n">ceiling</span> <span class="o">.</span> <span class="n">negate</span> <span class="o">.</span> <span class="n">tan</span> <span class="o">.</span> <span class="n">cos</span> <span class="o">.</span> <span class="n">max</span> <span class="mi">50</span>
</code></pre> </div> <h2 id="modules">Modules</h2> <p>A Haskell module is a collection of related functions, types, and typeclasses. A program is a collection of modules in which the main module loads up the other modules and then uses their functions to perform some process.</p> <p>Modules provide many advantages. If a module is generic enough, the functions it exports can be used in many different programs. If code is separated into self-contained modules which aren’t too reliant on each other, they can be reused later on and changed more easily without having to rewrite other code.</p> <p>The standard library is split into modules, each of which contains related functions and types.</p> <p>Modules are imported before the definition of any function with the syntax <code class="highlighter-rouge">import module_name</code>.</p> <p>The <code class="highlighter-rouge">Data.List</code> module has useful functions for working with lists.</p> <p>One of thest functions is <code class="highlighter-rouge">numUniques</code></p> <div class="language-haskell highlighter-rouge"><pre class="highlight"><code><span class="n">numUniques</span><span class="o">::</span> <span class="p">(</span><span class="kt">Eq</span> <span class="n">a</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="n">a</span><span class="p">]</span> <span class="o">-&gt;</span> <span class="kt">Int</span>
<span class="n">numUniques</span> <span class="o">=</span> <span class="n">length</span> <span class="o">.</span> <span class="n">nub</span>
</code></pre> </div> <p>When <code class="highlighter-rouge">Data.List</code> is imported, all of its exports become available in the global namespace. <code class="highlighter-rouge">nub</code> is another function in <code class="highlighter-rouge">Data.List</code> that removes duplicate elements from a list.</p> <p>In the terminal, functions can be added to the global namespace with <code class="highlighter-rouge">:m</code></p> <div class="language-haskell highlighter-rouge"><pre class="highlight"><code><span class="o">&gt;</span> <span class="o">:</span><span class="n">m</span> <span class="o">+</span> <span class="kt">Data</span><span class="o">.</span><span class="kt">List</span> <span class="kt">Data</span><span class="o">.</span><span class="kt">Map</span> <span class="kt">Data</span><span class="o">.</span><span class="kt">Set</span>
</code></pre> </div> <p>Individual functions can also be imported</p> <div class="language-haskell highlighter-rouge"><pre class="highlight"><code><span class="kr">import</span> <span class="nn">Data.List</span> <span class="p">(</span><span class="nf">nub</span><span class="p">,</span> <span class="nf">sort</span><span class="p">)</span>
</code></pre> </div> <p>We can also import all of the functions in a module except some which are explicitly excluded. This is useful if different modules export functions with the same name.</p> <div class="language-haskell highlighter-rouge"><pre class="highlight"><code><span class="kr">import</span> <span class="nn">Data.List</span> <span class="k">hiding</span> <span class="p">(</span><span class="nf">nub</span><span class="p">)</span>
</code></pre> </div> <p>Another method for dealing with name clashes is qualified imports. The <code class="highlighter-rouge">Data.Map</code> module contains functions with the same names as some of those in <code class="highlighter-rouge">Prelude</code>, such as <code class="highlighter-rouge">filter</code> or <code class="highlighter-rouge">null</code></p> <div class="language-haskell highlighter-rouge"><pre class="highlight"><code><span class="kr">import</span> <span class="k">qualified</span> <span class="nn">Data.Map</span>
</code></pre> </div> <p>This means that when we wish to reference the <code class="highlighter-rouge">filter</code> function in <code class="highlighter-rouge">Data.Map</code> we must write <code class="highlighter-rouge">Data.Map.Filter</code>. As this can make code very verbose, there is the option to name the import</p> <div class="language-haskell highlighter-rouge"><pre class="highlight"><code><span class="kr">import</span> <span class="k">qualified</span> <span class="nn">Data.Map</span> <span class="k">as</span> <span class="n">M</span>
</code></pre> </div> <p>We can now access <code class="highlighter-rouge">Data.Map.Filter</code> as <code class="highlighter-rouge">M.filter</code></p> <h3 id="datalist"><code class="highlighter-rouge">Data.List</code></h3> <p><strong>intersperse</strong> takes an element and a list and puts that element in between each pair of elements in the list</p> <div class="language-haskell highlighter-rouge"><pre class="highlight"><code><span class="o">&gt;</span> <span class="n">intersperse</span> <span class="mi">0</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">]</span>
<span class="o">&gt;</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">5</span><span class="p">]</span>
</code></pre> </div> <p><strong>intercalate</strong> takes a list of lists and a list, and inserts the list between each of the lists within the list of lists, before flattening the result</p> <div class="language-haskell highlighter-rouge"><pre class="highlight"><code><span class="o">&gt;</span> <span class="n">intercalate</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span> <span class="p">[[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">],[</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">],[</span><span class="mi">7</span><span class="p">,</span><span class="mi">8</span><span class="p">,</span><span class="mi">9</span><span class="p">]]</span>
<span class="o">&gt;</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">7</span><span class="p">,</span><span class="mi">8</span><span class="p">,</span><span class="mi">9</span><span class="p">]</span>
</code></pre> </div> <p><strong>transpose</strong> transposes a list of lists. Considering the list of lists as a 2d matrix, rows become columns and vice versa</p> <div class="language-haskell highlighter-rouge"><pre class="highlight"><code><span class="o">&gt;</span> <span class="n">transpose</span> <span class="p">[[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">],[</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">],[</span><span class="mi">7</span><span class="p">,</span><span class="mi">8</span><span class="p">,</span><span class="mi">9</span><span class="p">]]</span>
<span class="o">&gt;</span> <span class="p">[[</span><span class="mi">1</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">7</span><span class="p">],[</span><span class="mi">2</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">8</span><span class="p">],[</span><span class="mi">3</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="mi">9</span><span class="p">]]</span>
</code></pre> </div> <p><strong>fold’</strong> and <strong>foldl1’</strong> are stricter version of their respective lazy incarnations. When using lazy folds on very large lists, stack overflow errors may occur. Due to the lazy nature of folds, the accumulator is not actually updated as the folding happens. The strict fold functions actually compute the intermediate values rather than filling up the stack with thunks.</p> <p><strong>concat</strong> flattens a list of lists into a list of elements</p> <div class="language-haskell highlighter-rouge"><pre class="highlight"><code><span class="o">&gt;</span> <span class="n">concat</span> <span class="p">[[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">],[</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">],[</span><span class="mi">7</span><span class="p">,</span><span class="mi">8</span><span class="p">,</span><span class="mi">9</span><span class="p">]]</span>
<span class="o">&gt;</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="mi">7</span><span class="p">,</span><span class="mi">8</span><span class="p">,</span><span class="mi">9</span><span class="p">]</span>
</code></pre> </div> <p><strong>concatMap</strong> is the same as first mapping a function to a list, and then concatenating the list with <code class="highlighter-rouge">concat</code></p> <p><strong>and</strong> takes a list of values and returns <code class="highlighter-rouge">True</code> only if all the values in the list are <code class="highlighter-rouge">True</code></p> <p><strong>or</strong> takes a list and returns <code class="highlighter-rouge">True</code> if any of the values in the list are <code class="highlighter-rouge">True</code></p> <div class="language-haskell highlighter-rouge"><pre class="highlight"><code><span class="o">&gt;</span> <span class="n">and</span> <span class="o">$</span> <span class="n">map</span> <span class="p">(</span><span class="o">&gt;</span><span class="mi">4</span><span class="p">)</span> <span class="p">[</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="mi">7</span><span class="p">,</span><span class="mi">8</span><span class="p">]</span>
<span class="o">&gt;</span> <span class="kt">True</span>
<span class="o">&gt;</span> <span class="n">or</span> <span class="o">$</span> <span class="n">map</span> <span class="p">(</span><span class="o">==</span><span class="mi">4</span><span class="p">)</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="mi">7</span><span class="p">,</span><span class="mi">8</span><span class="p">]</span>
<span class="o">&gt;</span> <span class="kt">True</span>
</code></pre> </div> <p><strong>any</strong> and <strong>all</strong> take a predicate and then check if any or all of the elements in the list satisfy the predicate, respectively. These functions are usually used rather than mapping over a list and then using <strong>or</strong> or <strong>and</strong></p> <p><strong>iterate</strong> takes a function and a starting value. It applies the function to the starting value, then applies that function to the result, and repeats, returning in the form of an infinite list</p> <div class="language-haskell highlighter-rouge"><pre class="highlight"><code><span class="o">&gt;</span> <span class="n">take</span> <span class="mi">10</span> <span class="o">$</span> <span class="n">iterate</span> <span class="p">(</span><span class="o">*</span><span class="mi">2</span><span class="p">)</span> <span class="mi">1</span>
<span class="o">&gt;</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">8</span><span class="p">,</span><span class="mi">15</span><span class="p">,</span><span class="mi">32</span><span class="p">,</span><span class="mi">64</span><span class="p">,</span><span class="mi">128</span><span class="p">,</span><span class="mi">256</span><span class="p">,</span><span class="mi">512</span><span class="p">]</span>
</code></pre> </div> <p><strong>splitAt</strong> takes a number and a list. It then splits the list at that many elements, returning the two lists in a tuple</p> <div class="language-haskell highlighter-rouge"><pre class="highlight"><code><span class="o">&gt;</span> <span class="n">splitAt</span> <span class="mi">3</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">]</span>
<span class="o">&gt;</span> <span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">],</span> <span class="p">[</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">])</span>
</code></pre> </div> <p><strong>takeWhile</strong> takes elements from a list while the predicate holds</p> <div class="language-haskell highlighter-rouge"><pre class="highlight"><code><span class="o">&gt;</span> <span class="n">takeWhile</span> <span class="p">(</span><span class="o">/=</span><span class="sc">' '</span><span class="p">)</span> <span class="s">"This is a sentence"</span>
<span class="o">&gt;</span> <span class="s">"This"</span>
</code></pre> </div> <p><strong>dropWhile</strong> takes a list and drops all the elements from the list while the predicate holds</p> <div class="language-haskell highlighter-rouge"><pre class="highlight"><code><span class="o">&gt;</span> <span class="n">dropWhile</span> <span class="p">(</span><span class="o">&lt;</span><span class="mi">3</span><span class="p">)</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">8</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="mi">8</span><span class="p">]</span>
<span class="o">&gt;</span> <span class="p">[</span><span class="mi">8</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="mi">8</span><span class="p">]</span>
</code></pre> </div> <p><strong>span</strong> returns a pair of lists, the first list containing the result of <code class="highlighter-rouge">takeWhile</code> on the list, and the second list containing the remaining elements</p> <p><strong>break</strong> <code class="highlighter-rouge">break p</code> is the equivalent of <code class="highlighter-rouge">span (not . p)</code></p> <p><strong>sort</strong> sorts a list of the <code class="highlighter-rouge">Ord</code> typeclass</p> <p><strong>group</strong> takes a list and groups the adjacent elements into sublists if they are equal</p> <div class="language-haskell highlighter-rouge"><pre class="highlight"><code><span class="o">&gt;</span> <span class="n">group</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">4</span><span class="p">]</span>
<span class="o">&gt;</span> <span class="p">[[</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">],[</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">],[</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">],[</span><span class="mi">4</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">4</span><span class="p">]]</span>
</code></pre> </div> <p><strong>inits</strong> and <strong>tails</strong> are like <strong>init</strong> and <strong>tail</strong> except that they recursively apply to the list until there is nothing left</p> <div class="language-haskell highlighter-rouge"><pre class="highlight"><code><span class="o">&gt;</span> <span class="n">inits</span> <span class="s">"text"</span>
<span class="o">&gt;</span> <span class="p">[</span><span class="s">""</span><span class="p">,</span> <span class="s">"t"</span><span class="p">,</span> <span class="s">"te"</span><span class="p">,</span> <span class="s">"tex"</span><span class="p">,</span> <span class="s">"text"</span><span class="p">]</span>
</code></pre> </div> <p><strong>isInfixOf</strong> returns true if a sublist is contained within a list</p> <p><strong>isPrefixOf</strong> and <strong>isSuffixOf</strong> search for a sublist at the beginning and end of a list respectively</p> <p><strong>elem</strong> and <strong>notElem</strong> check if an element is or is not inside a list</p> <p><strong>partition</strong> takes a list and a predicate and returns a pair of lists, the first containing all the elements that satisfy the predicate, and the second containing those that do not</p> <p><strong>find</strong> takes a list and a predicate and returns the first element that satisfies the predicate</p> <p>The type of <code class="highlighter-rouge">find</code> is <code class="highlighter-rouge">Maybe a</code> as it can contain <code class="highlighter-rouge">Just a</code> or <code class="highlighter-rouge">Nothing</code>.</p> <p><strong>elemIndex</strong> returns the index of an element in a list, or <code class="highlighter-rouge">Nothing</code> if the element is not contained within the list</p> <p><strong>elemIndices</strong> returns a list of the indices of an element within a list</p> <p><strong>findIndex</strong> maybe returns the index of the first element that satisfies the predicate</p> <p><strong>zip3</strong>, <strong>zip4</strong>, <strong>zipWith3</strong>, and <strong>zipWith4</strong> zip 3 or 4 lists into triples or 4 tuples</p> <p><strong>lines</strong> takes a string returns every line of that string in a separate list</p> <div class="language-haskell highlighter-rouge"><pre class="highlight"><code><span class="o">&gt;</span> <span class="n">lines</span> <span class="s">"line 1</span><span class="se">\n</span><span class="s">line 2</span><span class="se">\n</span><span class="s">line 3"</span>
<span class="o">&gt;</span> <span class="p">[</span><span class="s">"line 1"</span><span class="p">,</span> <span class="s">"line 2"</span><span class="p">,</span> <span class="s">"line 3"</span><span class="p">]</span>
</code></pre> </div> <p><strong>unlines</strong> takes a list of strings and joins them together with the ‘\n’ character</p> <p><strong>words</strong> and <strong>unwords</strong> split a line of text into words or join a list of words respectively</p> <p><strong>delete</strong> takes an element and a list and deletes the first occurrence of that element in the list</p> <p><strong>\</strong> the list difference function. For every element in the right hand list, it removes a matching element in the left one</p> <p><strong>union</strong> returns the union of two lists</p> <p><strong>intersect</strong> returns only the elements that are found in both lists</p> <p><strong>insert</strong> takes an element and a list of elements that can be sorted and inserts it into the last position where it is less than or equal to the next element</p> <p><strong>length</strong>, <strong>take</strong>, <strong>drop</strong> <strong>splitAt</strong>, <strong>!!</strong>, and <strong>replicte</strong> all take <strong>Int</strong> as one of their parameters, or return an <strong>Int</strong>. They could be more generic if they took any type that’s part of <strong>Integral</strong> or <strong>Num</strong>. <code class="highlighter-rouge">Data.List</code> contains <strong>genericLength</strong>, <strong>genericTake</strong> etc to provide these functions without breaking old code.</p> <p>The <strong>nub</strong>, <strong>delete</strong>, <strong>union</strong>, <strong>intersect</strong>, and <strong>group</strong> functions all have their more general counterparts <strong>nubBy</strong> etc. While the standard functions use <code class="highlighter-rouge">==</code> to test for equality, the <code class="highlighter-rouge">By</code> functions take an equality function as a parameter.</p> <p>Similarly there are <code class="highlighter-rouge">sortBy</code>, <code class="highlighter-rouge">insertBy</code>, <code class="highlighter-rouge">maximumBy</code>, and <code class="highlighter-rouge">minimumBy</code> functions.</p> <h3 id="datachar"><code class="highlighter-rouge">Data.Char</code></h3> <p>The <code class="highlighter-rouge">Data.Char</code> module deals with characters</p> <p><strong>isControl</strong> checks whether a character is a control character</p> <p><strong>isSpace</strong> checks whether a character is a white space character</p> <p><strong>isLower</strong> checks whether a character is lower cased</p> <p><strong>isUpper</strong> checks whether a character is upper cased</p> <p><strong>isAlpha</strong> checks whether a character is a letter</p> <p><strong>isAlphaNum</strong> checks whether a character is a letter or a number</p> <p><strong>isPrint</strong> checks whether a character is printable</p> <p><strong>isDigit</strong> checks whether a character is a digit</p> <p><strong>isOctDigit</strong> checks whether a character is an octal digit</p> <p><strong>isHexDigit</strong> checks whether a character is a hexadecimal digit</p> <p><strong>isLetter</strong> checks whether a character is a letter</p> <p><strong>isMark</strong> checks for Unicode mark characters. These characters combine with preceding letters to form letters with accents</p> <p><strong>isNumber</strong> checks whether a character is numeric</p> <p><strong>isPunctuation</strong> checks whether a character is punctuation</p> <p><strong>isSymbol</strong> checks whether a character is a symbol</p> <p><strong>isSeparator</strong> checks for Unicode spaces and separators</p> <p><strong>isAscii</strong> checks whether a character falls within the first 128 of the Unicode set</p> <p><strong>isLatin1</strong> checks whether a character falls into the first 256 characters of the Unicode set</p> <p><strong>isAsciiUpper</strong> checks whether a character is ASCII and uppercase</p> <p><strong>isAsciiLower</strong> checks whether a character is ASCII and lowercase</p> <p>All of the above functions have a type signature of <code class="highlighter-rouge">Char -&gt; Bool</code></p> <p><code class="highlighter-rouge">Data.Char</code> exports a data type which is similar to <code class="highlighter-rouge">Ordering</code>. The <code class="highlighter-rouge">Ordering</code> type can have a value of <code class="highlighter-rouge">LT</code>, <code class="highlighter-rouge">EQ</code>, or <code class="highlighter-rouge">GT</code>. It describes possible result that can arise from comparing elements. The <code class="highlighter-rouge">GeneralCategory</code> type is also an enumeration. It presents possible categories that a character can fall into.</p> <p><code class="highlighter-rouge">generalCategory</code> has a type of <code class="highlighter-rouge">Char -&gt; GeneralCategory</code>. There are a total of 31 categories.</p> <div class="language-haskell highlighter-rouge"><pre class="highlight"><code><span class="o">&gt;</span> <span class="n">generalCategory</span> <span class="sc">' '</span>
<span class="o">&gt;</span> <span class="kt">Space</span>
<span class="o">&gt;</span> <span class="n">generalCategory</span> <span class="sc">'A'</span>
<span class="o">&gt;</span> <span class="kt">UppercaseLetter</span>
<span class="o">&gt;</span> <span class="n">generalCategory</span> <span class="sc">'|'</span>
<span class="o">&gt;</span> <span class="kt">MathSymbol</span>
</code></pre> </div> <p><strong>toUpper</strong> converts a character to uppercase, ignoring those which do not have an uppercase</p> <p><strong>toLower</strong> converts a character to lowercase</p> <p><strong>toTitle</strong> converts a character to title case, which is usually the same as uppercase</p> <p><strong>digitToInt</strong> converts a character to an <code class="highlighter-rouge">Int</code>. The character must be in the range ‘0..9, a..f, A..F’</p> <p><strong>intToDigit</strong> is the inverse of <code class="highlighter-rouge">digitToInt</code></p> <p><strong>ord</strong> and <strong>chr</strong> convert characters to their numeric values and vice versa</p> <h3 id="datamap"><code class="highlighter-rouge">Data.Map</code></h3> <p>Association lists are lists that are used to store key-value pairs where ordering does not matter.</p> <p>We could represent this structure with a list of pairs, and find values by their key as follows</p> <div class="language-haskell highlighter-rouge"><pre class="highlight"><code><span class="n">findKey</span> <span class="o">::</span> <span class="p">(</span><span class="kt">Eq</span> <span class="n">k</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="n">k</span> <span class="o">-&gt;</span> <span class="p">[(</span><span class="n">k</span><span class="p">,</span> <span class="n">v</span><span class="p">)]</span> <span class="o">-&gt;</span> <span class="n">v</span>
<span class="n">findKey</span> <span class="n">key</span> <span class="n">xs</span> <span class="o">=</span> <span class="n">snd</span> <span class="o">.</span> <span class="n">head</span> <span class="o">.</span> <span class="n">filter</span> <span class="p">(</span><span class="nf">\</span><span class="p">(</span><span class="n">k</span><span class="p">,</span><span class="n">v</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">key</span> <span class="o">==</span> <span class="n">k</span><span class="p">)</span> <span class="o">$</span> <span class="n">xs</span>
</code></pre> </div> <p>The function takes the list of pairs, filters the list so that only matching keys remain, and takes the head value.</p> <p>In order to deal with elements which do not exist, we must return <code class="highlighter-rouge">Maybe v</code></p> <div class="language-haskell highlighter-rouge"><pre class="highlight"><code><span class="n">findKey</span> <span class="o">::</span> <span class="p">(</span><span class="kt">Eq</span> <span class="n">k</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="n">k</span> <span class="o">-&gt;</span> <span class="p">[(</span><span class="n">k</span><span class="p">,</span><span class="n">v</span><span class="p">)]</span> <span class="o">-&gt;</span> <span class="kt">Maybe</span> <span class="n">v</span>
<span class="n">findKey</span> <span class="n">key</span> <span class="kt">[]</span> <span class="o">=</span> <span class="kt">Nothing</span>
<span class="n">findKey</span> <span class="n">key</span> <span class="p">((</span><span class="n">k</span><span class="p">,</span><span class="n">v</span><span class="p">)</span><span class="o">:</span><span class="n">xs</span><span class="p">)</span> <span class="o">=</span> <span class="kr">if</span> <span class="n">key</span> <span class="o">==</span> <span class="n">k</span>
                           <span class="kr">then</span> <span class="kt">Just</span> <span class="n">v</span>
                           <span class="kr">else</span> <span class="n">findKey</span> <span class="n">key</span> <span class="n">xs</span>
</code></pre> </div> <p>This recursive function on a list can be implemented as a fold</p> <div class="language-haskell highlighter-rouge"><pre class="highlight"><code><span class="n">findKey</span> <span class="o">::</span> <span class="p">(</span><span class="kt">Eq</span> <span class="n">k</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="n">k</span> <span class="o">-&gt;</span> <span class="p">[(</span><span class="n">k</span><span class="p">,</span><span class="n">v</span><span class="p">)]</span> <span class="o">-&gt;</span> <span class="kt">Maybe</span> <span class="n">v</span>
<span class="n">findKey</span> <span class="n">key</span> <span class="o">=</span> <span class="n">foldr</span> <span class="p">(</span><span class="nf">\</span><span class="p">(</span><span class="n">k</span><span class="p">,</span><span class="n">v</span><span class="p">)</span> <span class="n">acc</span> <span class="o">-&gt;</span> <span class="kr">if</span> <span class="n">key</span> <span class="o">==</span> <span class="n">k</span> <span class="kr">then</span> <span class="kt">Just</span> <span class="n">v</span> <span class="kr">else</span> <span class="n">acc</span><span class="p">)</span> <span class="kt">Nothing</span>
</code></pre> </div> <p>The <code class="highlighter-rouge">findKey</code> function does the same thing as the <code class="highlighter-rouge">lookup</code> function from <code class="highlighter-rouge">Data.List</code>. The <code class="highlighter-rouge">Data.Map</code> module offers association lists which are much faster, as they are not traversing lists.</p> <p><code class="highlighter-rouge">Data.Map</code> should qualified in order to stop namespace clashes with <code class="highlighter-rouge">Prelude</code> and <code class="highlighter-rouge">Data.List</code>.</p> <p><strong>fromList</strong> takes an association list and returns a map with the same associations</p> <p>If there are duplicate keys in the list, they are discarded. <code class="highlighter-rouge">fromList</code> has the signature <code class="highlighter-rouge">Map.fromList :: (Ord k) =&gt; [(k, v)] -&gt; Map.Map k v</code>.</p> <p>The keys must be orderable so that they can be placed in a tree.</p> <p><strong>empty</strong> represents an empty map</p> <p><strong>insert</strong> takes a key, a value, and a map, and returns a new map with the new item</p> <div class="language-haskell highlighter-rouge"><pre class="highlight"><code><span class="o">&gt;</span> <span class="kt">Map</span><span class="o">.</span><span class="n">empty</span>
<span class="o">&gt;</span> <span class="n">fromList</span> <span class="kt">[]</span>
<span class="o">&gt;</span> <span class="kt">Map</span><span class="o">.</span><span class="n">insert</span> <span class="mi">3</span> <span class="mi">100</span> <span class="kt">Map</span><span class="o">.</span><span class="n">empty</span>
<span class="o">&gt;</span> <span class="n">fromList</span> <span class="p">[(</span><span class="mi">3</span><span class="p">,</span><span class="mi">100</span><span class="p">)]</span>
</code></pre> </div> <p><strong>null</strong> checks if a map is empty</p> <p><strong>size</strong> reports the size of a map, which is the number of key value pairs</p> <p><strong>singleton</strong> takes a key and a value and creates a map with exactly one mapping</p> <p><strong>lookup</strong> returns <code class="highlighter-rouge">Just something</code> if a key exists and <code class="highlighter-rouge">Nothing</code> if it does not</p> <p><strong>member</strong> is a predicate that takes a key and a map and reports whether the key is in the map</p> <p><strong>map</strong> and <strong>filter</strong> work much like their list equivalents, working on the values</p> <p><strong>toList</strong> is the inverse of <code class="highlighter-rouge">fromList</code></p> <p><strong>keys</strong> and <strong>elems</strong> return a list of keys and values respectively</p> <p><strong>fromListWith</strong> acts like <code class="highlighter-rouge">fromList</code> except that it takes a function supplied to decide what to do with duplicate keys</p> <p>The function is used to combine the values of those keys into some other value</p> <p><strong>insertWIth</strong> inserts a key-value pair into a map, using the passed function if the key already exists</p> <h3 id="dataset"><code class="highlighter-rouge">Data.Set</code></h3> <p><code class="highlighter-rouge">Data.Set</code> offers set structures.</p> <p><strong>fromList</strong> takes a list and converts it to a set</p> <div class="language-haskell highlighter-rouge"><pre class="highlight"><code><span class="o">&gt;</span> <span class="kt">Set</span><span class="o">.</span><span class="n">fromList</span> <span class="s">"The quick brown fox jumped over the lazy dog."</span>
<span class="o">&gt;</span> <span class="n">fromList</span> <span class="s">" .Tabcdefghijklmnopqrstuvwxyz"</span>
</code></pre> </div> <p>The elements are ordered and each element is unique</p> <p><strong>intersection</strong> returns a set of the elements which are present in both sets</p> <p><strong>difference</strong> returns a set of the elements which are in the first set but not the second</p> <p><strong>union</strong> returns a set of the combined elements of both sets</p> <p><strong>null</strong>, <strong>size</strong>, <strong>member</strong>, <strong>empty</strong>, <strong>singleton</strong>, <strong>insert</strong>, and <strong>delete</strong> work as expected</p> <p><strong>isSubsetOf</strong> checks if the first set is a subset of the second set</p> <p><strong>isProperSubsetOf</strong> checks if the first set is a proper subset of the second set</p> <h3 id="creating-modules">Creating modules</h3> <p>Modules are defined as follows</p> <div class="language-haskell highlighter-rouge"><pre class="highlight"><code><span class="kr">module</span> <span class="nn">Geometry</span>  
<span class="p">(</span> <span class="nf">sphereVolume</span>  
<span class="p">,</span> <span class="nf">sphereArea</span>  
<span class="p">,</span> <span class="nf">cubeVolume</span>  
<span class="p">,</span> <span class="nf">cubeArea</span>  
<span class="p">,</span> <span class="nf">cuboidArea</span>  
<span class="p">,</span> <span class="nf">cuboidVolume</span>  
<span class="p">)</span> <span class="kr">where</span>  

<span class="n">sphereVolume</span> <span class="o">::</span> <span class="kt">Float</span> <span class="o">-&gt;</span> <span class="kt">Float</span>  
<span class="n">sphereVolume</span> <span class="n">radius</span> <span class="o">=</span> <span class="p">(</span><span class="mf">4.0</span> <span class="o">/</span> <span class="mf">3.0</span><span class="p">)</span> <span class="o">*</span> <span class="n">pi</span> <span class="o">*</span> <span class="p">(</span><span class="n">radius</span> <span class="o">^</span> <span class="mi">3</span><span class="p">)</span>  

<span class="n">sphereArea</span> <span class="o">::</span> <span class="kt">Float</span> <span class="o">-&gt;</span> <span class="kt">Float</span>  
<span class="n">sphereArea</span> <span class="n">radius</span> <span class="o">=</span> <span class="mi">4</span> <span class="o">*</span> <span class="n">pi</span> <span class="o">*</span> <span class="p">(</span><span class="n">radius</span> <span class="o">^</span> <span class="mi">2</span><span class="p">)</span>  

<span class="n">cubeVolume</span> <span class="o">::</span> <span class="kt">Float</span> <span class="o">-&gt;</span> <span class="kt">Float</span>  
<span class="n">cubeVolume</span> <span class="n">side</span> <span class="o">=</span> <span class="n">cuboidVolume</span> <span class="n">side</span> <span class="n">side</span> <span class="n">side</span>  

<span class="n">cubeArea</span> <span class="o">::</span> <span class="kt">Float</span> <span class="o">-&gt;</span> <span class="kt">Float</span>  
<span class="n">cubeArea</span> <span class="n">side</span> <span class="o">=</span> <span class="n">cuboidArea</span> <span class="n">side</span> <span class="n">side</span> <span class="n">side</span>  

<span class="n">cuboidVolume</span> <span class="o">::</span> <span class="kt">Float</span> <span class="o">-&gt;</span> <span class="kt">Float</span> <span class="o">-&gt;</span> <span class="kt">Float</span> <span class="o">-&gt;</span> <span class="kt">Float</span>  
<span class="n">cuboidVolume</span> <span class="n">a</span> <span class="n">b</span> <span class="n">c</span> <span class="o">=</span> <span class="n">rectangleArea</span> <span class="n">a</span> <span class="n">b</span> <span class="o">*</span> <span class="n">c</span>  

<span class="n">cuboidArea</span> <span class="o">::</span> <span class="kt">Float</span> <span class="o">-&gt;</span> <span class="kt">Float</span> <span class="o">-&gt;</span> <span class="kt">Float</span> <span class="o">-&gt;</span> <span class="kt">Float</span>  
<span class="n">cuboidArea</span> <span class="n">a</span> <span class="n">b</span> <span class="n">c</span> <span class="o">=</span> <span class="n">rectangleArea</span> <span class="n">a</span> <span class="n">b</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">+</span> <span class="n">rectangleArea</span> <span class="n">a</span> <span class="n">c</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">+</span> <span class="n">rectangleArea</span> <span class="n">c</span> <span class="n">b</span> <span class="o">*</span> <span class="mi">2</span>  

<span class="n">rectangleArea</span> <span class="o">::</span> <span class="kt">Float</span> <span class="o">-&gt;</span> <span class="kt">Float</span> <span class="o">-&gt;</span> <span class="kt">Float</span>  
<span class="n">rectangleArea</span> <span class="n">a</span> <span class="n">b</span> <span class="o">=</span> <span class="n">a</span> <span class="o">*</span> <span class="n">b</span>  
</code></pre> </div> <p>The helper function <code class="highlighter-rouge">rectangleArea</code> is not exported.</p> <p>Modules can be given hierarchical structures. Each module can have a number of submodules which can have submodules of their own.</p> <h4 id="creating-submodules">Creating submodules</h4> <p>First we create a folder called <code class="highlighter-rouge">Geometry</code>. Within this folder we create three files: <code class="highlighter-rouge">Sphere.hs</code>, <code class="highlighter-rouge">Cuboid.hs</code>, and <code class="highlighter-rouge">Cube.hs</code></p> <div class="language-haskell highlighter-rouge"><pre class="highlight"><code><span class="kr">module</span> <span class="nn">Geometry.Sphere</span>  
<span class="p">(</span> <span class="nf">volume</span>  
<span class="p">,</span> <span class="nf">area</span>  
<span class="p">)</span> <span class="kr">where</span>  

<span class="n">volume</span> <span class="o">::</span> <span class="kt">Float</span> <span class="o">-&gt;</span> <span class="kt">Float</span>  
<span class="n">volume</span> <span class="n">radius</span> <span class="o">=</span> <span class="p">(</span><span class="mf">4.0</span> <span class="o">/</span> <span class="mf">3.0</span><span class="p">)</span> <span class="o">*</span> <span class="n">pi</span> <span class="o">*</span> <span class="p">(</span><span class="n">radius</span> <span class="o">^</span> <span class="mi">3</span><span class="p">)</span>  

<span class="n">area</span> <span class="o">::</span> <span class="kt">Float</span> <span class="o">-&gt;</span> <span class="kt">Float</span>  
<span class="n">area</span> <span class="n">radius</span> <span class="o">=</span> <span class="mi">4</span> <span class="o">*</span> <span class="n">pi</span> <span class="o">*</span> <span class="p">(</span><span class="n">radius</span> <span class="o">^</span> <span class="mi">2</span><span class="p">)</span>  
</code></pre> </div> <div class="language-haskell highlighter-rouge"><pre class="highlight"><code><span class="kr">module</span> <span class="nn">Geometry.Cuboid</span>  
<span class="p">(</span> <span class="nf">volume</span>  
<span class="p">,</span> <span class="nf">area</span>  
<span class="p">)</span> <span class="kr">where</span>  

<span class="n">volume</span> <span class="o">::</span> <span class="kt">Float</span> <span class="o">-&gt;</span> <span class="kt">Float</span> <span class="o">-&gt;</span> <span class="kt">Float</span> <span class="o">-&gt;</span> <span class="kt">Float</span>  
<span class="n">volume</span> <span class="n">a</span> <span class="n">b</span> <span class="n">c</span> <span class="o">=</span> <span class="n">rectangleArea</span> <span class="n">a</span> <span class="n">b</span> <span class="o">*</span> <span class="n">c</span>  

<span class="n">area</span> <span class="o">::</span> <span class="kt">Float</span> <span class="o">-&gt;</span> <span class="kt">Float</span> <span class="o">-&gt;</span> <span class="kt">Float</span> <span class="o">-&gt;</span> <span class="kt">Float</span>  
<span class="n">area</span> <span class="n">a</span> <span class="n">b</span> <span class="n">c</span> <span class="o">=</span> <span class="n">rectangleArea</span> <span class="n">a</span> <span class="n">b</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">+</span> <span class="n">rectangleArea</span> <span class="n">a</span> <span class="n">c</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">+</span> <span class="n">rectangleArea</span> <span class="n">c</span> <span class="n">b</span> <span class="o">*</span> <span class="mi">2</span>  

<span class="n">rectangleArea</span> <span class="o">::</span> <span class="kt">Float</span> <span class="o">-&gt;</span> <span class="kt">Float</span> <span class="o">-&gt;</span> <span class="kt">Float</span>  
<span class="n">rectangleArea</span> <span class="n">a</span> <span class="n">b</span> <span class="o">=</span> <span class="n">a</span> <span class="o">*</span> <span class="n">b</span>  
</code></pre> </div> <div class="language-haskell highlighter-rouge"><pre class="highlight"><code><span class="kr">module</span> <span class="nn">Geometry.Cube</span>  
<span class="p">(</span> <span class="nf">volume</span>  
<span class="p">,</span> <span class="nf">area</span>  
<span class="p">)</span> <span class="kr">where</span>  

<span class="kr">import</span> <span class="k">qualified</span> <span class="nn">Geometry.Cuboid</span> <span class="k">as</span> <span class="n">Cuboid</span>  

<span class="n">volume</span> <span class="o">::</span> <span class="kt">Float</span> <span class="o">-&gt;</span> <span class="kt">Float</span>  
<span class="n">volume</span> <span class="n">side</span> <span class="o">=</span> <span class="kt">Cuboid</span><span class="o">.</span><span class="n">volume</span> <span class="n">side</span> <span class="n">side</span> <span class="n">side</span>  

<span class="n">area</span> <span class="o">::</span> <span class="kt">Float</span> <span class="o">-&gt;</span> <span class="kt">Float</span>  
<span class="n">area</span> <span class="n">side</span> <span class="o">=</span> <span class="kt">Cuboid</span><span class="o">.</span><span class="n">area</span> <span class="n">side</span> <span class="n">side</span> <span class="n">side</span>
</code></pre> </div> <p>In each module we have defined functions with the same names. This is possible because they are separate modules.</p> <h2 id="making-types-and-typeclassses">Making Types and Typeclassses</h2> <h3 id="algebraic-data-types">Algebraic data types</h3> <div class="language-haskell highlighter-rouge"><pre class="highlight"><code><span class="kr">data</span> <span class="kt">Bool</span> <span class="o">=</span> <span class="kt">False</span> <span class="o">|</span> <span class="kt">True</span>
</code></pre> </div> <p>The <code class="highlighter-rouge">data</code> keyword is used to define a new data type. The part before the <code class="highlighter-rouge">=</code> denotes the type, and the parts after it are <code class="highlighter-rouge">value constructors</code>. They specify the different values that this type can have.</p> <p>We could think of <code class="highlighter-rouge">Int</code> as being</p> <div class="language-haskell highlighter-rouge"><pre class="highlight"><code><span class="kr">data</span> <span class="kt">Int</span> <span class="o">=</span> <span class="o">-</span><span class="mi">2147483648</span> <span class="o">|</span> <span class="o">-</span><span class="mi">2147483647</span> <span class="o">|</span> <span class="o">...</span> <span class="o">|</span> <span class="o">-</span><span class="mi">1</span> <span class="o">|</span> <span class="mi">0</span> <span class="o">|</span> <span class="mi">1</span> <span class="o">|</span> <span class="mi">2</span> <span class="o">|</span> <span class="o">...</span> <span class="o">|</span> <span class="mi">2147483647</span>
</code></pre> </div> <p>Consider the definition of a shape</p> <div class="language-haskell highlighter-rouge"><pre class="highlight"><code><span class="kr">data</span> <span class="kt">Shape</span> <span class="o">=</span> <span class="kt">Circle</span> <span class="kt">Float</span> <span class="kt">Float</span> <span class="kt">Float</span> <span class="o">|</span> <span class="kt">Rectangle</span> <span class="kt">Float</span> <span class="kt">Float</span> <span class="kt">Float</span> <span class="kt">Float</span>
</code></pre> </div> <p>The <code class="highlighter-rouge">Circle</code> value constructor has three fields. When we write a value constructor we optionally add some types after it and those types define the values it will contain.</p> <p>Value constructors are actually functions that ultimately return a value of a data type.</p> <div class="language-haskell highlighter-rouge"><pre class="highlight"><code><span class="o">&gt;</span> <span class="o">:</span><span class="n">t</span> <span class="kt">Circle</span>
<span class="o">&gt;</span> <span class="kt">Circle</span> <span class="o">::</span> <span class="kt">Float</span> <span class="o">-&gt;</span> <span class="kt">Float</span> <span class="o">-&gt;</span> <span class="kt">Float</span> <span class="o">-&gt;</span> <span class="kt">Shape</span>
<span class="o">&gt;</span> <span class="o">:</span><span class="n">t</span> <span class="kt">Rectangle</span>
<span class="o">&gt;</span> <span class="kt">Rectangle</span> <span class="o">::</span> <span class="kt">Float</span> <span class="o">-&gt;</span> <span class="kt">Float</span> <span class="o">-&gt;</span> <span class="kt">Float</span> <span class="o">-&gt;</span> <span class="kt">Float</span> <span class="o">-&gt;</span> <span class="kt">Shape</span>
</code></pre> </div> <p>A function to find the surface of a <code class="highlighter-rouge">Shape</code> cane be written as follows</p> <div class="language-haskell highlighter-rouge"><pre class="highlight"><code><span class="n">surface</span> <span class="o">::</span> <span class="kt">Shape</span> <span class="o">-&gt;</span> <span class="kt">Float</span>
<span class="n">surface</span> <span class="p">(</span><span class="kt">Circle</span> <span class="kr">_</span> <span class="kr">_</span> <span class="n">r</span><span class="p">)</span> <span class="o">=</span> <span class="n">pi</span> <span class="o">*</span> <span class="n">r</span> <span class="o">^</span> <span class="mi">2</span>
<span class="n">surface</span> <span class="p">(</span><span class="kt">Rectangle</span> <span class="n">x1</span> <span class="n">y1</span> <span class="n">x2</span> <span class="n">y2</span><span class="p">)</span> <span class="o">=</span> <span class="p">(</span><span class="n">abs</span> <span class="o">$</span> <span class="n">x2</span> <span class="o">-</span> <span class="n">x1</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">abs</span> <span class="o">$</span> <span class="n">y2</span> <span class="o">-</span> <span class="n">y1</span><span class="p">)</span>
</code></pre> </div> <p>We could not write a type declaration of <code class="highlighter-rouge">Circle -&gt; Float</code> because <code class="highlighter-rouge">Circle</code> is not a type, whereas <code class="highlighter-rouge">Shape</code> is. We can pattern match against constructors, which we have been doing before when matching against values like <code class="highlighter-rouge">[]</code> or <code class="highlighter-rouge">False</code>.</p> <p>To make our type printable we modify it as below</p> <div class="language-haskell highlighter-rouge"><pre class="highlight"><code><span class="kr">data</span> <span class="kt">Shape</span> <span class="o">=</span> <span class="kt">Circle</span> <span class="kt">Float</span> <span class="kt">Float</span> <span class="kt">Float</span> <span class="o">|</span> <span class="kt">Rectangle</span> <span class="kt">Float</span> <span class="kt">Float</span> <span class="kt">Float</span> <span class="kt">Float</span> <span class="kr">deriving</span> <span class="p">(</span><span class="kt">Show</span><span class="p">)</span>
</code></pre> </div> <p>When we add <code class="highlighter-rouge">deriving (Show)</code> at the end of a <code class="highlighter-rouge">data</code> declaration, Haskell makes that type part of the <code class="highlighter-rouge">Show</code> typeclass automatically.</p> <p>Value constructors are functions, so we can map them and partially apply them.</p> <div class="language-haskell highlighter-rouge"><pre class="highlight"><code><span class="o">&gt;</span> <span class="n">map</span> <span class="p">(</span><span class="kt">Circle</span> <span class="mi">10</span> <span class="mi">20</span><span class="p">)</span> <span class="p">[</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="mi">7</span><span class="p">]</span>
<span class="o">&gt;</span> <span class="p">[</span><span class="kt">Circle</span> <span class="mf">10.0</span> <span class="mf">20.0</span> <span class="mf">4.0</span><span class="p">,</span><span class="kt">Circle</span> <span class="mf">10.0</span> <span class="mf">20.0</span> <span class="mf">5.0</span><span class="p">,</span><span class="kt">Circle</span> <span class="mf">10.0</span> <span class="mf">20.0</span> <span class="mf">6.0</span><span class="p">,</span><span class="kt">Circle</span> <span class="mf">10.0</span> <span class="mf">20.0</span> <span class="mf">7.0</span><span class="p">]</span>  
</code></pre> </div> <p>To improve the <code class="highlighter-rouge">Shape</code> type we can define an intermediate data type to represent a point in two dimensional space</p> <div class="language-haskell highlighter-rouge"><pre class="highlight"><code><span class="kr">data</span> <span class="kt">Point</span> <span class="o">=</span> <span class="kt">Point</span> <span class="kt">Float</span> <span class="kt">Float</span> <span class="kr">deriving</span> <span class="p">(</span><span class="kt">Show</span><span class="p">)</span>  
<span class="kr">data</span> <span class="kt">Shape</span> <span class="o">=</span> <span class="kt">Circle</span> <span class="kt">Point</span> <span class="kt">Float</span> <span class="o">|</span> <span class="kt">Rectangle</span> <span class="kt">Point</span> <span class="kt">Point</span> <span class="kr">deriving</span> <span class="p">(</span><span class="kt">Show</span><span class="p">)</span>  
</code></pre> </div> <p>When defining a point, we used the name for the data type and its value constructor. This has no special meaning.</p> <p>The <code class="highlighter-rouge">surface</code> function must now be adjusted</p> <div class="language-haskell highlighter-rouge"><pre class="highlight"><code><span class="n">surface</span> <span class="o">::</span> <span class="kt">Shape</span> <span class="o">-&gt;</span> <span class="kt">Float</span>
<span class="n">surface</span> <span class="p">(</span><span class="kt">Circle</span> <span class="n">r</span><span class="p">)</span> <span class="o">=</span> <span class="n">pi</span> <span class="o">*</span> <span class="n">r</span> <span class="o">^</span> <span class="mi">2</span>
<span class="n">surface</span> <span class="p">(</span><span class="kt">Rectangle</span> <span class="p">(</span><span class="kt">Point</span> <span class="n">x1</span> <span class="n">y1</span><span class="p">)</span> <span class="p">(</span><span class="kt">Point</span> <span class="n">x2</span> <span class="n">y2</span><span class="p">))</span> <span class="o">=</span> <span class="p">(</span><span class="n">abs</span> <span class="o">$</span> <span class="n">x2</span> <span class="o">-</span> <span class="n">x1</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">abs</span> <span class="o">$</span> <span class="n">y2</span> <span class="o">-</span> <span class="n">y1</span><span class="p">)</span>
</code></pre> </div> <p>When calculating the area of the rectangle we use nested pattern matching to access the fields.</p> <p>We can defined a function to modify the position of a shape</p> <div class="language-haskell highlighter-rouge"><pre class="highlight"><code><span class="n">nudge</span> <span class="o">::</span> <span class="kt">Shape</span> <span class="o">-&gt;</span> <span class="kt">Float</span> <span class="o">-&gt;</span> <span class="kt">Float</span> <span class="o">-&gt;</span> <span class="kt">Shape</span>
<span class="n">nudge</span> <span class="p">(</span><span class="kt">Circle</span> <span class="p">(</span><span class="kt">Point</span> <span class="n">x</span> <span class="n">y</span><span class="p">)</span> <span class="n">r</span><span class="p">)</span> <span class="n">a</span> <span class="n">b</span> <span class="o">=</span> <span class="kt">Circle</span> <span class="p">(</span><span class="kt">Point</span> <span class="p">(</span><span class="n">x</span><span class="o">+</span><span class="n">a</span><span class="p">)</span> <span class="p">(</span><span class="n">y</span><span class="o">+</span><span class="n">b</span><span class="p">))</span> <span class="n">r</span>
<span class="n">nudge</span> <span class="p">(</span><span class="kt">Rectangle</span> <span class="p">(</span><span class="kt">Point</span> <span class="n">x1</span> <span class="n">y1</span><span class="p">)</span> <span class="p">(</span><span class="kt">Point</span> <span class="n">x2</span> <span class="n">y2</span><span class="p">))</span> <span class="n">a</span> <span class="n">b</span> <span class="o">=</span> <span class="kt">Rectangle</span> <span class="p">(</span><span class="kt">Point</span> <span class="p">(</span><span class="n">x1</span><span class="o">+</span><span class="n">a</span><span class="p">)</span> <span class="p">(</span><span class="n">y1</span><span class="o">+</span><span class="n">b</span><span class="p">))</span> <span class="p">(</span><span class="kt">Point</span> <span class="p">(</span><span class="n">x2</span><span class="o">+</span><span class="n">a</span><span class="p">)</span> <span class="p">(</span><span class="n">y2</span><span class="o">+</span><span class="n">a</span><span class="p">))</span>
</code></pre> </div> <div class="language-haskell highlighter-rouge"><pre class="highlight"><code><span class="o">&gt;</span> <span class="n">nudge</span> <span class="p">(</span><span class="kt">Circle</span> <span class="p">(</span><span class="kt">Point</span> <span class="mi">34</span> <span class="mi">34</span><span class="p">)</span> <span class="mi">10</span><span class="p">)</span> <span class="mi">5</span> <span class="mi">10</span>
<span class="o">&gt;</span> <span class="kt">Circle</span> <span class="p">(</span><span class="kt">Point</span> <span class="mf">39.0</span> <span class="mf">44.0</span><span class="p">)</span> <span class="mf">10.0</span>
</code></pre> </div> <p>If we don’t want to deal directly with points, we can make auxiliary functions that create shapes of some size at the zero coordinates and then nudge those.</p> <div class="language-haskell highlighter-rouge"><pre class="highlight"><code><span class="n">baseCircle</span> <span class="o">::</span> <span class="kt">Float</span> <span class="o">-&gt;</span> <span class="kt">Shape</span>
<span class="n">baseCircle</span> <span class="n">r</span> <span class="o">=</span> <span class="kt">Circle</span> <span class="p">(</span><span class="kt">Point</span> <span class="mi">0</span> <span class="mi">0</span><span class="p">)</span> <span class="n">r</span>

<span class="n">baseRect</span> <span class="o">::</span> <span class="kt">Float</span> <span class="o">-&gt;</span> <span class="kt">Float</span> <span class="o">-&gt;</span> <span class="kt">Shape</span>
<span class="n">baseRect</span> <span class="n">width</span> <span class="n">height</span> <span class="o">=</span> <span class="kt">Rectangle</span> <span class="p">(</span><span class="kt">Point</span> <span class="mi">0</span> <span class="mi">0</span><span class="p">)</span> <span class="p">(</span><span class="kt">Point</span> <span class="n">width</span> <span class="n">height</span><span class="p">)</span>
</code></pre> </div> <div class="language-haskell highlighter-rouge"><pre class="highlight"><code><span class="o">&gt;</span> <span class="n">nudge</span> <span class="p">(</span><span class="n">baseRect</span> <span class="mi">40</span> <span class="mi">100</span><span class="p">)</span> <span class="mi">60</span> <span class="mi">23</span>
<span class="o">&gt;</span> <span class="kt">Rectangle</span> <span class="p">(</span><span class="kt">Point</span> <span class="mf">60.0</span> <span class="mf">23.0</span><span class="p">)</span> <span class="p">(</span><span class="kt">Point</span> <span class="mf">100.0</span> <span class="mf">123.0</span><span class="p">)</span>
</code></pre> </div> <p>These data types can be exported in modules. Write the type along with the functions to be exported, and then add parentheses and specify the value constructors to be exported for it. To export all the value constructors for a type, just write <code class="highlighter-rouge">..</code></p> <div class="language-haskell highlighter-rouge"><pre class="highlight"><code><span class="kr">module</span> <span class="nn">Shapes</span>   
<span class="p">(</span> <span class="kt">Point</span><span class="p">(</span><span class="o">..</span><span class="p">)</span>  
<span class="p">,</span> <span class="kt">Shape</span><span class="p">(</span><span class="o">..</span><span class="p">)</span>  
<span class="p">,</span> <span class="nf">surface</span>  
<span class="p">,</span> <span class="nf">nudge</span>  
<span class="p">,</span> <span class="nf">baseCircle</span>  
<span class="p">,</span> <span class="nf">baseRect</span>  
<span class="p">)</span> <span class="kr">where</span>  
</code></pre> </div> <p>By writing <code class="highlighter-rouge">Shape(..)</code> we exported all the value constructors for <code class="highlighter-rouge">Shape</code>. This is the same as writing <code class="highlighter-rouge">Shape(Rectangle, Circle)</code>.</p> <p>We could opt not to export the value constructors for <code class="highlighter-rouge">Shape</code> by just writing <code class="highlighter-rouge">Shape</code>. This would mean that any user of the module could only make shapes using the auxiliary functions <code class="highlighter-rouge">baseCircle</code> and <code class="highlighter-rouge">baseRect</code>.</p> <h3 id="record-syntax">Record syntax</h3> <p>Suppose we wish to create a data type to contain information about a person.</p> <div class="language-haskell highlighter-rouge"><pre class="highlight"><code><span class="kr">data</span> <span class="kt">Person</span> <span class="o">=</span> <span class="kt">Person</span> <span class="kt">String</span> <span class="kt">String</span> <span class="kt">Int</span> <span class="kt">Float</span> <span class="kt">String</span> <span class="kt">String</span> <span class="kr">deriving</span> <span class="p">(</span><span class="kt">Show</span><span class="p">)</span>  
</code></pre> </div> <div class="language-haskell highlighter-rouge"><pre class="highlight"><code><span class="o">&gt;</span> <span class="kr">let</span> <span class="n">guy</span> <span class="o">=</span> <span class="kt">Person</span> <span class="s">"Buddy"</span> <span class="s">"Finklestein"</span> <span class="mi">43</span> <span class="mf">184.2</span> <span class="s">"526-2928"</span> <span class="s">"Chocolate"</span>  
<span class="o">&gt;</span> <span class="n">guy</span>  
<span class="kt">Person</span> <span class="s">"Buddy"</span> <span class="s">"Finklestein"</span> <span class="mi">43</span> <span class="mf">184.2</span> <span class="s">"526-2928"</span> <span class="s">"Chocolate"</span>  
</code></pre> </div> <p>This is somewhat unreadable.</p> <p>Now suppose that we cant to create a function to get individual pieces of information from a <code class="highlighter-rouge">Person</code>.</p> <div class="language-haskell highlighter-rouge"><pre class="highlight"><code><span class="n">firstName</span> <span class="o">::</span> <span class="kt">Person</span> <span class="o">-&gt;</span> <span class="kt">String</span>  
<span class="n">firstName</span> <span class="p">(</span><span class="kt">Person</span> <span class="n">firstname</span> <span class="kr">_</span> <span class="kr">_</span> <span class="kr">_</span> <span class="kr">_</span> <span class="kr">_</span><span class="p">)</span> <span class="o">=</span> <span class="n">firstname</span>  

<span class="n">lastName</span> <span class="o">::</span> <span class="kt">Person</span> <span class="o">-&gt;</span> <span class="kt">String</span>  
<span class="n">lastName</span> <span class="p">(</span><span class="kt">Person</span> <span class="kr">_</span> <span class="n">lastname</span> <span class="kr">_</span> <span class="kr">_</span> <span class="kr">_</span> <span class="kr">_</span><span class="p">)</span> <span class="o">=</span> <span class="n">lastname</span>  

<span class="n">age</span> <span class="o">::</span> <span class="kt">Person</span> <span class="o">-&gt;</span> <span class="kt">Int</span>  
<span class="n">age</span> <span class="p">(</span><span class="kt">Person</span> <span class="kr">_</span> <span class="kr">_</span> <span class="n">age</span> <span class="kr">_</span> <span class="kr">_</span> <span class="kr">_</span><span class="p">)</span> <span class="o">=</span> <span class="n">age</span>  

<span class="n">height</span> <span class="o">::</span> <span class="kt">Person</span> <span class="o">-&gt;</span> <span class="kt">Float</span>  
<span class="n">height</span> <span class="p">(</span><span class="kt">Person</span> <span class="kr">_</span> <span class="kr">_</span> <span class="kr">_</span> <span class="n">height</span> <span class="kr">_</span> <span class="kr">_</span><span class="p">)</span> <span class="o">=</span> <span class="n">height</span>  

<span class="n">phoneNumber</span> <span class="o">::</span> <span class="kt">Person</span> <span class="o">-&gt;</span> <span class="kt">String</span>  
<span class="n">phoneNumber</span> <span class="p">(</span><span class="kt">Person</span> <span class="kr">_</span> <span class="kr">_</span> <span class="kr">_</span> <span class="kr">_</span> <span class="n">number</span> <span class="kr">_</span><span class="p">)</span> <span class="o">=</span> <span class="n">number</span>  

<span class="n">flavor</span> <span class="o">::</span> <span class="kt">Person</span> <span class="o">-&gt;</span> <span class="kt">String</span>  
<span class="n">flavor</span> <span class="p">(</span><span class="kt">Person</span> <span class="kr">_</span> <span class="kr">_</span> <span class="kr">_</span> <span class="kr">_</span> <span class="kr">_</span> <span class="n">flavor</span><span class="p">)</span> <span class="o">=</span> <span class="n">flavor</span>  
</code></pre> </div> <p>This is tedious to write.</p> <p>Instead we can write out data type as follows</p> <div class="language-haskell highlighter-rouge"><pre class="highlight"><code><span class="kr">data</span> <span class="kt">Person</span> <span class="o">=</span> <span class="kt">Person</span> <span class="p">{</span> <span class="n">firstName</span> <span class="o">::</span> <span class="kt">String</span>  
                     <span class="p">,</span> <span class="n">lastName</span> <span class="o">::</span> <span class="kt">String</span>  
                     <span class="p">,</span> <span class="n">age</span> <span class="o">::</span> <span class="kt">Int</span>  
                     <span class="p">,</span> <span class="n">height</span> <span class="o">::</span> <span class="kt">Float</span>  
                     <span class="p">,</span> <span class="n">phoneNumber</span> <span class="o">::</span> <span class="kt">String</span>  
                     <span class="p">,</span> <span class="n">flavor</span> <span class="o">::</span> <span class="kt">String</span>  
                     <span class="p">}</span> <span class="kr">deriving</span> <span class="p">(</span><span class="kt">Show</span><span class="p">)</span>   
</code></pre> </div> <p>We define a name for each field, and then specify its type. Functions are automatically created for looking up fields. The functions have the same name as the fields.</p> <div class="language-haskell highlighter-rouge"><pre class="highlight"><code><span class="o">&gt;</span> <span class="o">:</span><span class="n">t</span> <span class="n">flavor</span>
<span class="o">&gt;</span> <span class="n">flavor</span> <span class="o">::</span> <span class="kt">Person</span> <span class="o">-&gt;</span> <span class="kt">String</span>
</code></pre> </div> <p>When we derive <code class="highlighter-rouge">Show</code>, the output is also much more useful.</p> <div class="language-haskell highlighter-rouge"><pre class="highlight"><code><span class="kr">data</span> <span class="kt">Car</span> <span class="o">=</span> <span class="kt">Car</span> <span class="kt">String</span> <span class="kt">String</span> <span class="kt">Int</span> <span class="kr">deriving</span> <span class="p">(</span><span class="kt">Show</span><span class="p">)</span>  
</code></pre> </div> <div class="language-haskell highlighter-rouge"><pre class="highlight"><code><span class="o">&gt;</span> <span class="kt">Car</span> <span class="s">"Ford"</span> <span class="s">"Mustang"</span> <span class="mi">1967</span>  
<span class="kt">Car</span> <span class="s">"Ford"</span> <span class="s">"Mustang"</span> <span class="mi">1967</span>  
</code></pre> </div> <div class="language-haskell highlighter-rouge"><pre class="highlight"><code><span class="kr">data</span> <span class="kt">Car</span> <span class="o">=</span> <span class="kt">Car</span> <span class="p">{</span><span class="n">company</span> <span class="o">::</span> <span class="kt">String</span><span class="p">,</span> <span class="n">model</span> <span class="o">::</span> <span class="kt">String</span><span class="p">,</span> <span class="n">year</span> <span class="o">::</span> <span class="kt">Int</span><span class="p">}</span> <span class="kr">deriving</span> <span class="p">(</span><span class="kt">Show</span><span class="p">)</span>
</code></pre> </div> <div class="language-haskell highlighter-rouge"><pre class="highlight"><code><span class="o">&gt;</span> <span class="kt">Car</span> <span class="p">{</span><span class="n">company</span><span class="o">=</span><span class="s">"Ford"</span><span class="p">,</span> <span class="n">model</span><span class="o">=</span><span class="s">"Mustang"</span><span class="p">,</span> <span class="n">year</span><span class="o">=</span><span class="mi">1967</span><span class="p">}</span>  
<span class="kt">Car</span> <span class="p">{</span><span class="n">company</span> <span class="o">=</span> <span class="s">"Ford"</span><span class="p">,</span> <span class="n">model</span> <span class="o">=</span> <span class="s">"Mustang"</span><span class="p">,</span> <span class="n">year</span> <span class="o">=</span> <span class="mi">1967</span><span class="p">}</span>  
</code></pre> </div> <p>When making a new <code class="highlighter-rouge">Car</code> we don’t have to put the fields in their proper order, as long as we list all of them. If we were not using record syntax, we would have to specify them in order.</p> <p>Record syntax should be used when there are numerous parameters which are not immediately distinguishable.</p> <h3 id="type-parameters">Type parameters</h3> <p>A value constructor can take some values as parameters and then produce a new value. In a similar manner, type constructors take types as parameters and produce new types.</p> <div class="language-haskell highlighter-rouge"><pre class="highlight"><code><span class="kr">data</span> <span class="kt">Maybe</span> <span class="n">a</span> <span class="o">=</span> <span class="kt">Nothing</span> <span class="o">|</span> <span class="kt">Just</span> <span class="n">a</span>
</code></pre> </div> <p>The <code class="highlighter-rouge">a</code> above is the type parameter. Because there is a type parameter involved, we call <code class="highlighter-rouge">Maybe</code> a type constructor. Depending on what we want this data type to hold when it is not <code class="highlighter-rouge">Nothing</code>, this type constructor can produce a type of <code class="highlighter-rouge">Maybe Int</code>, <code class="highlighter-rouge">Maybe String</code> or any other <code class="highlighter-rouge">Maybe</code> type. No value can have a type of just <code class="highlighter-rouge">Maybe</code>, because that is not a type, only a type constructor.</p> <p>If we pass <code class="highlighter-rouge">Char</code> as the type parameter to <code class="highlighter-rouge">Maybe</code>, we get a type of <code class="highlighter-rouge">Maybe Char</code>. The value <code class="highlighter-rouge">Just 'a'</code> has a type of <code class="highlighter-rouge">Maybe Char</code>.</p> <div class="language-haskell highlighter-rouge"><pre class="highlight"><code><span class="o">&gt;</span> <span class="kt">Just</span> <span class="s">"String"</span>
<span class="o">&gt;</span> <span class="kt">Just</span> <span class="s">"String"</span>
<span class="o">&gt;</span> <span class="kt">Just</span> <span class="mi">84</span>
<span class="o">&gt;</span> <span class="kt">Just</span> <span class="mi">84</span>
<span class="o">&gt;</span> <span class="o">:</span><span class="n">t</span> <span class="kt">Just</span> <span class="s">"String"</span>
<span class="o">&gt;</span> <span class="kt">Just</span> <span class="s">"String"</span> <span class="o">::</span> <span class="kt">Maybe</span> <span class="p">[</span><span class="kt">Char</span><span class="p">]</span>
<span class="o">&gt;</span> <span class="o">:</span><span class="n">t</span> <span class="kt">Just</span> <span class="mi">84</span>
<span class="o">&gt;</span> <span class="kt">Just</span> <span class="mi">84</span> <span class="o">::</span> <span class="p">(</span><span class="kt">Num</span> <span class="n">t</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="kt">Maybe</span> <span class="n">t</span>
<span class="o">&gt;</span> <span class="o">:</span><span class="n">t</span> <span class="kt">Nothing</span>
<span class="o">&gt;</span> <span class="kt">Nothing</span> <span class="o">::</span> <span class="kt">Maybe</span> <span class="n">a</span>
<span class="o">&gt;</span> <span class="kt">Just</span> <span class="mi">10</span> <span class="o">::</span> <span class="kt">Maybe</span> <span class="kt">Double</span>
<span class="o">&gt;</span> <span class="kt">Just</span> <span class="mf">10.0</span>
</code></pre> </div> <p>Type parameters are useful because we can make different types with them depending on what kind of types we want contained in our data type.</p> <p>The type of <code class="highlighter-rouge">Nothing</code> is <code class="highlighter-rouge">Maybe a</code>. It is polymorphic. If some function requires <code class="highlighter-rouge">Maybe Int</code> as a parameter, we can give it <code class="highlighter-rouge">Nothing</code>, because <code class="highlighter-rouge">Nothing</code> doesn’t contain a value anyway. The <code class="highlighter-rouge">Maybe a</code> type can act like a <code class="highlighter-rouge">Maybe Int</code> if it has to. Similarly, the type of an empty list is <code class="highlighter-rouge">[a]</code>, so an empty list can act like anything.</p> <p>Another parametrized type is <code class="highlighter-rouge">Map k v</code>. Having maps parametrized enables us to have mappings from any type to any other type, as long as the type of the key is part of the <code class="highlighter-rouge">Ord</code> typeclass. If we were defining a mapping type, we could add a typeclass constraint in the data declaration.</p> <div class="language-haskell highlighter-rouge"><pre class="highlight"><code><span class="kr">data</span> <span class="p">(</span><span class="kt">Ord</span> <span class="n">k</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="kt">Map</span> <span class="n">v</span> <span class="n">k</span> <span class="o">=</span> <span class="o">...</span>
</code></pre> </div> <p>It is a very strong convention in Haskell to <strong>never add typeclass constraints in data declarations</strong>. This is because we don’t benefit a lot, but we end up writing more class constraints, even when we don’t need them. If we put or don’t put the <code class="highlighter-rouge">Ord k</code> constraint for <code class="highlighter-rouge">Map k v</code>, we will have to put the constraint into functions that assume the keys in a map can be ordered. If we don’t put the constraint in the data declaration, we don’t have to put <code class="highlighter-rouge">(Ord k) =&gt;</code> in the type declarations of functions that don’t care whether the keys can be ordered.</p> <p>An example is <code class="highlighter-rouge">toList</code>, which has a type signature of <code class="highlighter-rouge">toList :: Map k a -&gt; [(k, a)]</code> rather than having to have a type constraint <code class="highlighter-rouge">toList :: (Ord k) =&gt; Map k a -&gt; [(k, a)]</code> without actually doing any comparing of keys.</p> <p>We don’t put type constraints in data declarations because they will have to be put in function type declarations anyway.</p> <p>A 3d vector type and some operations are defined as follows</p> <div class="language-haskell highlighter-rouge"><pre class="highlight"><code><span class="kr">data</span> <span class="kt">Vector</span> <span class="n">a</span> <span class="o">=</span> <span class="kt">Vector</span> <span class="n">a</span> <span class="n">a</span> <span class="n">a</span> <span class="kr">deriving</span> <span class="p">(</span><span class="kt">Show</span><span class="p">)</span>  

<span class="n">vplus</span> <span class="o">::</span> <span class="p">(</span><span class="kt">Num</span> <span class="n">t</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="kt">Vector</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">Vector</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">Vector</span> <span class="n">t</span>  
<span class="p">(</span><span class="kt">Vector</span> <span class="n">i</span> <span class="n">j</span> <span class="n">k</span><span class="p">)</span> <span class="p">`</span><span class="n">vplus</span><span class="p">`</span> <span class="p">(</span><span class="kt">Vector</span> <span class="n">l</span> <span class="n">m</span> <span class="n">n</span><span class="p">)</span> <span class="o">=</span> <span class="kt">Vector</span> <span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="n">l</span><span class="p">)</span> <span class="p">(</span><span class="n">j</span><span class="o">+</span><span class="n">m</span><span class="p">)</span> <span class="p">(</span><span class="n">k</span><span class="o">+</span><span class="n">n</span><span class="p">)</span>  

<span class="n">vectMult</span> <span class="o">::</span> <span class="p">(</span><span class="kt">Num</span> <span class="n">t</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="kt">Vector</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">Vector</span> <span class="n">t</span>  
<span class="p">(</span><span class="kt">Vector</span> <span class="n">i</span> <span class="n">j</span> <span class="n">k</span><span class="p">)</span> <span class="p">`</span><span class="n">vectMult</span><span class="p">`</span> <span class="n">m</span> <span class="o">=</span> <span class="kt">Vector</span> <span class="p">(</span><span class="n">i</span><span class="o">*</span><span class="n">m</span><span class="p">)</span> <span class="p">(</span><span class="n">j</span><span class="o">*</span><span class="n">m</span><span class="p">)</span> <span class="p">(</span><span class="n">k</span><span class="o">*</span><span class="n">m</span><span class="p">)</span>  

<span class="n">scalarMult</span> <span class="o">::</span> <span class="p">(</span><span class="kt">Num</span> <span class="n">t</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="kt">Vector</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">Vector</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="n">t</span>  
<span class="p">(</span><span class="kt">Vector</span> <span class="n">i</span> <span class="n">j</span> <span class="n">k</span><span class="p">)</span> <span class="p">`</span><span class="n">scalarMult</span><span class="p">`</span> <span class="p">(</span><span class="kt">Vector</span> <span class="n">l</span> <span class="n">m</span> <span class="n">n</span><span class="p">)</span> <span class="o">=</span> <span class="n">i</span><span class="o">*</span><span class="n">l</span> <span class="o">+</span> <span class="n">j</span><span class="o">*</span><span class="n">m</span> <span class="o">+</span> <span class="n">k</span><span class="o">*</span><span class="n">n</span>  
</code></pre> </div> <p>We use a parametrized type because the vector should support several numeric types.</p> <p><code class="highlighter-rouge">vplus</code> is use to add two vectors together. <code class="highlighter-rouge">scalarMult</code> is for the scalar product of two vectors, and <code class="highlighter-rouge">vectMult</code> is for multiplying a vector with a scalar. These functions can operate on types of <code class="highlighter-rouge">Vector Int</code>, <code class="highlighter-rouge">Vector Integer</code>, <code class="highlighter-rouge">Vector Float</code>, and any other type from the <code class="highlighter-rouge">Num</code> typeclass.</p> <p>It is very important to distinguish between the type constructor and the value constructor. When declaring a data type, the part before the <code class="highlighter-rouge">=</code> is the type constructor and the constructors after it are value constructors.</p> <h3 id="derived-instances">Derived instances</h3> <p>A type can be an instance of a typeclass if it supports a particular behaviour.</p> <p>Haskell can automatically make a type an instance of any of the following typeclasses: <code class="highlighter-rouge">Eq</code>, <code class="highlighter-rouge">Ord</code>, <code class="highlighter-rouge">Enum</code>, <code class="highlighter-rouge">Bounded</code>, <code class="highlighter-rouge">Show</code>, <code class="highlighter-rouge">Read</code>.</p> <p>When we derive the <code class="highlighter-rouge">Eq</code> instance for a type and then try to compare two values, Haskell will see if the value constructors match, and it will then check if all the data contained inside matches by testing each pair of fields, each of which also have to be part of the <code class="highlighter-rouge">Eq</code> typeclass.</p> <p>We can derive instances for the <code class="highlighter-rouge">Ord</code> typeclass. If we compare two values of the same type that were made using different constructors, the value which was made with a constructor that’s defined first is smaller.</p> <div class="language-haskell highlighter-rouge"><pre class="highlight"><code><span class="kr">data</span> <span class="kt">Bool</span> <span class="o">=</span> <span class="kt">False</span> <span class="o">|</span> <span class="kt">True</span> <span class="kr">deriving</span> <span class="p">(</span><span class="kt">Ord</span><span class="p">)</span>
</code></pre> </div> <p>Because the <code class="highlighter-rouge">False</code> constructor is specified first, we can consider <code class="highlighter-rouge">True</code> to be greater than <code class="highlighter-rouge">False</code>.</p> <p>In the <code class="highlighter-rouge">Maybe a</code> data type, the <code class="highlighter-rouge">Nothing</code> value constructor is specified before the <code class="highlighter-rouge">Just</code> value constructor.</p> <p>We can use algebraic data types to make enumerations with the <code class="highlighter-rouge">Enum</code> and <code class="highlighter-rouge">Bounded</code> typeclasses.</p> <div class="language-haskell highlighter-rouge"><pre class="highlight"><code><span class="kr">data</span> <span class="kt">Day</span> <span class="o">=</span> <span class="kt">Monday</span> <span class="o">|</span> <span class="kt">Tuesday</span> <span class="o">|</span> <span class="kt">Wednesday</span> <span class="o">|</span> <span class="kt">Thursday</span> <span class="o">|</span> <span class="kt">Friday</span> <span class="o">|</span> <span class="kt">Saturday</span> <span class="o">|</span> <span class="kt">Sunday</span>   
           <span class="kr">deriving</span> <span class="p">(</span><span class="kt">Eq</span><span class="p">,</span> <span class="kt">Ord</span><span class="p">,</span> <span class="kt">Show</span><span class="p">,</span> <span class="kt">Read</span><span class="p">,</span> <span class="kt">Bounded</span><span class="p">,</span> <span class="kt">Enum</span><span class="p">)</span>  
</code></pre> </div> <p><code class="highlighter-rouge">Day</code> can be made part of the <code class="highlighter-rouge">Enum</code> typeclass because all the value constructors are nullary, taking no parameters.</p> <div class="language-haskell highlighter-rouge"><pre class="highlight"><code><span class="o">&gt;</span> <span class="n">show</span> <span class="kt">Wednesday</span>
<span class="o">&gt;</span> <span class="s">"Wednesday"</span>
<span class="o">&gt;</span> <span class="n">read</span> <span class="s">"Saturday"</span> <span class="o">::</span> <span class="kt">Day</span>
<span class="o">&gt;</span> <span class="kt">Saturday</span>
<span class="o">&gt;</span> <span class="kt">Saturday</span> <span class="o">&gt;</span> <span class="kt">Friday</span>
<span class="o">&gt;</span> <span class="kt">True</span>
<span class="o">&gt;</span> <span class="n">minBound</span> <span class="o">::</span> <span class="kt">Day</span>
<span class="o">&gt;</span> <span class="kt">Monday</span>
<span class="o">&gt;</span> <span class="n">succ</span> <span class="kt">Monday</span>
<span class="o">&gt;</span> <span class="kt">Tuesday</span>
<span class="o">&gt;</span> <span class="p">[</span><span class="kt">Thursday</span> <span class="o">..</span> <span class="kt">Sunday</span><span class="p">]</span>
<span class="o">&gt;</span> <span class="p">[</span><span class="kt">Thursday</span><span class="p">,</span> <span class="kt">Friday</span><span class="p">,</span> <span class="kt">Saturday</span><span class="p">,</span> <span class="kt">Sunday</span><span class="p">]</span>
</code></pre> </div> <h3 id="type-synonyms">Type synonyms</h3> <p>Type synonyms allow giving different names to complex types.</p> <div class="language-haskell highlighter-rouge"><pre class="highlight"><code><span class="kr">type</span> <span class="kt">String</span> <span class="o">=</span> <span class="p">[</span><span class="kt">Char</span><span class="p">]</span>
</code></pre> </div> <p>We are not actually defining a new type, only creating a synonym for an existing one.</p> <p>In the same way that functions can be partially applied, type parameters can also be partially applied</p> <div class="language-haskell highlighter-rouge"><pre class="highlight"><code><span class="kr">type</span> <span class="kt">IntMap</span> <span class="n">v</span> <span class="o">=</span> <span class="kt">Map</span> <span class="kt">Int</span> <span class="n">v</span>
</code></pre> </div> <p>or</p> <div class="language-haskell highlighter-rouge"><pre class="highlight"><code><span class="kr">type</span> <span class="kt">IntMap</span> <span class="o">=</span> <span class="kt">Map</span> <span class="kt">Int</span>
</code></pre> </div> <p>The <code class="highlighter-rouge">Either</code> data type takes two types as its parameters.</p> <div class="language-haskell highlighter-rouge"><pre class="highlight"><code><span class="kr">data</span> <span class="kt">Either</span> <span class="n">a</span> <span class="n">b</span> <span class="o">=</span> <span class="kt">Left</span> <span class="n">a</span> <span class="o">|</span> <span class="kt">Right</span> <span class="n">b</span> <span class="kr">deriving</span> <span class="p">(</span><span class="kt">Eq</span><span class="p">,</span> <span class="kt">Ord</span><span class="p">,</span> <span class="kt">Read</span><span class="p">,</span> <span class="kt">Show</span><span class="p">)</span>
</code></pre> </div> <p><code class="highlighter-rouge">Either</code> is useful to return a value and a possinle error.</p> <h3 id="recursive-data-structures">Recursive data structures</h3> <p>We can make types whose constructors have fields that are of the same type.</p> <div class="language-haskell highlighter-rouge"><pre class="highlight"><code><span class="kr">data</span> <span class="kt">List</span> <span class="n">a</span> <span class="o">=</span> <span class="kt">Empty</span> <span class="o">|</span> <span class="kt">Cons</span> <span class="n">a</span> <span class="p">(</span><span class="kt">List</span> <span class="n">a</span><span class="p">)</span> <span class="kr">deriving</span> <span class="p">(</span><span class="kt">Show</span><span class="p">,</span> <span class="kt">Read</span><span class="p">,</span> <span class="kt">Eq</span><span class="p">,</span> <span class="kt">Ord</span><span class="p">)</span>
</code></pre> </div> <p>This list definition is either empty or a combination of a head value and a list. <code class="highlighter-rouge">Cons</code> is another word for <code class="highlighter-rouge">:</code>.</p> <p>We can define functions to be automatically infix by making them comprised of special characters.</p> <div class="language-haskell highlighter-rouge"><pre class="highlight"><code><span class="kr">infixr</span> <span class="mi">5</span> <span class="o">:-:</span>
<span class="kr">data</span> <span class="kt">List</span> <span class="n">a</span> <span class="o">=</span> <span class="kt">Empty</span> <span class="o">|</span> <span class="n">a</span> <span class="o">:-:</span> <span class="p">(</span><span class="kt">List</span> <span class="n">a</span><span class="p">)</span> <span class="kr">deriving</span> <span class="p">(</span><span class="kt">Show</span><span class="p">,</span> <span class="kt">Read</span><span class="p">,</span> <span class="kt">Eq</span><span class="p">,</span> <span class="kt">Ord</span><span class="p">)</span>
</code></pre> </div> <p>When we define functions as operators, we can give them a fixity. The fixity states the associativity and the strength of the binding.</p> <div class="language-haskell highlighter-rouge"><pre class="highlight"><code><span class="o">&gt;</span> <span class="mi">3</span> <span class="o">:-:</span> <span class="mi">4</span> <span class="o">:-:</span> <span class="mi">5</span> <span class="o">:-:</span> <span class="kt">Empty</span>
<span class="o">&gt;</span> <span class="p">(</span><span class="o">:-:</span><span class="p">)</span> <span class="mi">3</span> <span class="p">((</span><span class="o">:-:</span><span class="p">)</span> <span class="mi">4</span> <span class="p">((</span><span class="o">:-:</span><span class="p">)</span> <span class="mi">5</span> <span class="kt">Empty</span><span class="p">))</span>
</code></pre> </div> <p>When deriving <code class="highlighter-rouge">Show</code> for the type, Haskell will display it as if the constructor was a prefix function.</p> <h4 id="binary-search-tree">Binary search tree</h4> <div class="language-haskell highlighter-rouge"><pre class="highlight"><code><span class="kr">data</span> <span class="kt">Tree</span> <span class="n">a</span> <span class="o">=</span> <span class="kt">EmptyTree</span> <span class="o">|</span> <span class="kt">Node</span> <span class="n">a</span> <span class="p">(</span><span class="kt">Tree</span> <span class="n">a</span><span class="p">)</span> <span class="p">(</span><span class="kt">Tree</span> <span class="n">a</span><span class="p">)</span> <span class="kr">deriving</span> <span class="p">(</span><span class="kt">Show</span><span class="p">,</span> <span class="kt">Read</span><span class="p">,</span> <span class="kt">Eq</span><span class="p">)</span>
</code></pre> </div> <p>Instead of manually building a tree, we can make a function that takes a tree and an element and inserts an element.</p> <div class="language-haskell highlighter-rouge"><pre class="highlight"><code><span class="n">singleton</span> <span class="o">::</span> <span class="n">a</span> <span class="o">-&gt;</span> <span class="kt">Tree</span> <span class="n">a</span>
<span class="n">singleton</span> <span class="n">x</span> <span class="o">=</span> <span class="kt">Node</span> <span class="n">x</span> <span class="kt">EmptyTree</span> <span class="kt">EmptyTree</span>

<span class="n">treeInsert</span> <span class="o">::</span> <span class="p">(</span><span class="kt">Ord</span> <span class="n">a</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="n">a</span> <span class="o">-&gt;</span> <span class="kt">Tree</span> <span class="n">a</span> <span class="o">-&gt;</span> <span class="kt">Tree</span> <span class="n">a</span>
<span class="n">treeInsert</span> <span class="n">x</span> <span class="kt">EmptyTree</span> <span class="o">=</span> <span class="n">singleton</span> <span class="n">x</span>
<span class="n">treeInsert</span> <span class="n">x</span> <span class="p">(</span><span class="kt">Node</span> <span class="n">a</span> <span class="n">left</span> <span class="n">right</span><span class="p">)</span>
  <span class="o">|</span> <span class="n">x</span> <span class="o">==</span> <span class="n">a</span> <span class="o">=</span> <span class="kt">Node</span> <span class="n">x</span> <span class="n">left</span> <span class="n">right</span>
  <span class="o">|</span> <span class="n">x</span> <span class="o">&lt;</span> <span class="n">a</span>  <span class="o">=</span> <span class="kt">Node</span> <span class="n">a</span> <span class="p">(</span><span class="n">treeInsert</span> <span class="n">x</span> <span class="n">left</span><span class="p">)</span> <span class="n">right</span>
  <span class="o">|</span> <span class="n">x</span> <span class="o">&gt;</span> <span class="n">a</span>  <span class="o">=</span> <span class="kt">Node</span> <span class="n">a</span> <span class="n">left</span> <span class="p">(</span><span class="n">treeInsert</span> <span class="n">x</span> <span class="n">right</span><span class="p">)</span>

<span class="n">treeElem</span> <span class="o">::</span> <span class="p">(</span><span class="kt">Ord</span> <span class="n">a</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="n">a</span> <span class="o">-&gt;</span> <span class="kt">Tree</span> <span class="n">a</span> <span class="o">-&gt;</span> <span class="kt">Bool</span>
<span class="n">treeElem</span> <span class="o">::</span> <span class="n">x</span> <span class="kt">EmptyTree</span> <span class="o">=</span> <span class="kt">False</span>
<span class="n">treeElem</span> <span class="o">::</span> <span class="n">x</span> <span class="p">(</span><span class="kt">Node</span> <span class="n">a</span> <span class="n">left</span> <span class="n">right</span><span class="p">)</span>
  <span class="o">|</span> <span class="n">x</span> <span class="o">==</span> <span class="n">a</span> <span class="o">=</span> <span class="kt">True</span>
  <span class="o">|</span> <span class="n">x</span> <span class="o">&lt;</span> <span class="n">a</span> <span class="o">=</span> <span class="n">treeElem</span> <span class="n">x</span> <span class="n">left</span>
  <span class="o">|</span> <span class="n">x</span> <span class="o">&gt;</span> <span class="n">a</span> <span class="o">=</span> <span class="n">treeElem</span> <span class="n">x</span> <span class="n">right</span>
</code></pre> </div> <p>We can use a fold to build up a tree from a list.</p> <div class="language-haskell highlighter-rouge"><pre class="highlight"><code><span class="o">&gt;</span> <span class="kr">let</span> <span class="n">nums</span> <span class="o">=</span> <span class="p">[</span><span class="mi">8</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">7</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">5</span><span class="p">]</span>
<span class="o">&gt;</span> <span class="kr">let</span> <span class="n">numsTree</span> <span class="o">=</span> <span class="n">foldr</span> <span class="n">treeInsert</span> <span class="kt">EmptyTree</span> <span class="n">nums</span>
<span class="o">&gt;</span> <span class="n">numsTree</span>
<span class="o">&gt;</span> <span class="kt">Node</span> <span class="mi">5</span> <span class="p">(</span><span class="kt">Node</span> <span class="mi">3</span> <span class="p">(</span><span class="kt">Node</span> <span class="mi">1</span> <span class="kt">EmptyTree</span> <span class="kt">EmptyTree</span><span class="p">)</span> <span class="p">(</span><span class="kt">Node</span> <span class="mi">4</span> <span class="kt">EmptyTree</span> <span class="kt">EmptyTree</span><span class="p">))</span> <span class="p">(</span><span class="kt">Node</span> <span class="mi">7</span> <span class="p">(</span><span class="kt">Node</span> <span class="mi">6</span> <span class="kt">EmptyTree</span> <span class="kt">EmptyTree</span><span class="p">)</span> <span class="p">(</span><span class="kt">Node</span> <span class="mi">8</span> <span class="kt">EmptyTree</span> <span class="kt">EmptyTree</span><span class="p">))</span>  
</code></pre> </div> <h3 id="typeclasses-1">Typeclasses</h3> <p>The <code class="highlighter-rouge">Eq</code> typeclass is defined as follows</p> <div class="language-haskell highlighter-rouge"><pre class="highlight"><code><span class="kr">class</span> <span class="kt">Eq</span> <span class="n">a</span> <span class="kr">where</span>
  <span class="p">(</span><span class="o">==</span><span class="p">)</span> <span class="o">::</span> <span class="n">a</span> <span class="o">-&gt;</span> <span class="n">a</span> <span class="o">-&gt;</span> <span class="kt">Bool</span>
  <span class="p">(</span><span class="o">/=</span><span class="p">)</span> <span class="o">::</span> <span class="n">a</span> <span class="o">-&gt;</span> <span class="n">a</span> <span class="o">-&gt;</span> <span class="kt">Bool</span>
  <span class="n">x</span> <span class="o">==</span> <span class="n">y</span> <span class="o">=</span> <span class="n">not</span> <span class="p">(</span><span class="n">x</span> <span class="o">/=</span> <span class="n">y</span><span class="p">)</span>
  <span class="n">x</span> <span class="o">/=</span> <span class="n">y</span> <span class="o">=</span> <span class="n">not</span> <span class="p">(</span><span class="n">x</span> <span class="o">==</span> <span class="n">y</span><span class="p">)</span>
</code></pre> </div> <div class="language-haskell highlighter-rouge"><pre class="highlight"><code><span class="kr">data</span> <span class="kt">TrafficLight</span> <span class="o">=</span> <span class="kt">Red</span> <span class="o">|</span> <span class="kt">Yellow</span> <span class="o">|</span> <span class="kt">Green</span>

<span class="kr">instance</span> <span class="kt">Eq</span> <span class="kt">TrafficLight</span> <span class="kr">where</span>
  <span class="kt">Red</span> <span class="o">==</span> <span class="kt">Red</span> <span class="o">=</span> <span class="kt">True</span>
  <span class="kt">Green</span> <span class="o">==</span> <span class="kt">Green</span> <span class="o">=</span> <span class="kt">True</span>
  <span class="kt">Yellow</span> <span class="o">==</span> <span class="kt">Yellow</span> <span class="o">=</span> <span class="kt">True</span>
  <span class="kr">_</span> <span class="o">==</span> <span class="kr">_</span> <span class="o">=</span> <span class="kt">False</span>
</code></pre> </div> <p>While <code class="highlighter-rouge">Eq</code> could have been implemented automatically, the code above demonstrates how it can be implemented by hand.</p> <p>The <code class="highlighter-rouge">instance</code> keyword is for making type instancs of typeclasses. Because <code class="highlighter-rouge">==</code> was defined in terms of ‘/=’ and vice versa in the class declaration, we only had to overwrite one of them in the instance.</p> <div class="language-haskell highlighter-rouge"><pre class="highlight"><code><span class="kr">instance</span> <span class="kt">Show</span> <span class="kt">TrafficLight</span> <span class="kr">where</span>
  <span class="n">show</span> <span class="kt">Red</span> <span class="o">=</span> <span class="s">"Red light"</span>
  <span class="n">show</span> <span class="kt">Yellow</span> <span class="o">=</span> <span class="s">"Yellow light"</span>
  <span class="n">show</span> <span class="kt">Green</span> <span class="o">=</span> <span class="s">"Green light"</span>
</code></pre> </div> <p>Typeclasses can also be subclasses of other typeclasses.</p> <div class="language-haskell highlighter-rouge"><pre class="highlight"><code><span class="kr">class</span> <span class="p">(</span><span class="kt">Eq</span> <span class="n">a</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="kt">Num</span> <span class="n">a</span> <span class="kr">where</span>
</code></pre> </div> <p>This states that we have to make a type an instnace of <code class="highlighter-rouge">Eq</code> before it can be made an instance of <code class="highlighter-rouge">Num</code>.</p> <p>In the declaration of <code class="highlighter-rouge">Eq</code> we can see that <code class="highlighter-rouge">a</code> is used as a concrete type because all the types in functions have to be concrete types. For <code class="highlighter-rouge">Maybe</code> we must write</p> <div class="language-haskell highlighter-rouge"><pre class="highlight"><code><span class="kr">instance</span> <span class="kt">Eq</span> <span class="p">(</span><span class="kt">Maybe</span> <span class="n">m</span><span class="p">)</span> <span class="kr">where</span>
  <span class="kt">Just</span> <span class="n">x</span> <span class="o">==</span> <span class="kt">Just</span> <span class="n">y</span> <span class="o">=</span> <span class="n">x</span> <span class="o">==</span> <span class="n">y</span>
  <span class="kt">Nothing</span> <span class="o">==</span> <span class="kt">Nothing</span> <span class="o">=</span> <span class="kt">True</span>
  <span class="kr">_</span> <span class="o">==</span> <span class="kr">_</span> <span class="o">=</span> <span class="kt">False</span>
</code></pre> </div> <p>We must also ensure that <code class="highlighter-rouge">m</code> is an instance of <code class="highlighter-rouge">Eq</code> to allow it to be compared.</p> <div class="language-haskell highlighter-rouge"><pre class="highlight"><code><span class="kr">instance</span> <span class="p">(</span><span class="kt">Eq</span> <span class="n">m</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="kt">Eq</span> <span class="p">(</span><span class="kt">Maybe</span> <span class="n">m</span><span class="p">)</span> <span class="kr">where</span>
  <span class="o">...</span>
</code></pre> </div> <p>Most of the time, class constraints in class declarations are used for making a typeclass a subclass of another typeclass and class constraints in instance declarations are used to express requirements about the contents of some type.</p> <p>The <code class="highlighter-rouge">:info</code> command can be used to display information about a typeclass.</p> <h3 id="yes-no-typeclass">Yes-No typeclass</h3> <p>In some weakly typed languages, anything can be passed to a conditional expression. In JavaScript, non empty strings, and non 0 numbers are considered to be <code class="highlighter-rouge">True</code>.</p> <p>We could implement this in Haskell</p> <div class="language-haskell highlighter-rouge"><pre class="highlight"><code><span class="kr">class</span> <span class="kt">YesNo</span> <span class="n">a</span> <span class="kr">where</span>
  <span class="n">yesno</span> <span class="o">::</span> <span class="n">a</span> <span class="o">-&gt;</span> <span class="kt">Bool</span>

<span class="kr">instance</span> <span class="kt">YesNo</span> <span class="kt">Int</span> <span class="kr">where</span>
  <span class="n">yesno</span> <span class="mi">0</span> <span class="o">=</span> <span class="kt">False</span>
  <span class="n">yesno</span> <span class="kr">_</span> <span class="o">=</span> <span class="kt">False</span>

<span class="kr">instance</span> <span class="kt">YesNo</span> <span class="p">[</span><span class="n">a</span><span class="p">]</span> <span class="kr">where</span>
  <span class="n">yesno</span> <span class="kt">[]</span> <span class="o">=</span> <span class="kt">False</span>
  <span class="n">yesno</span> <span class="kr">_</span> <span class="o">=</span> <span class="kt">True</span>

<span class="kr">instance</span> <span class="kt">YesNo</span> <span class="kt">Bool</span> <span class="kr">where</span>
  <span class="n">yesno</span> <span class="o">=</span> <span class="n">id</span>
<span class="c1">-- id is a standard library function which takes a parameter and returns the same thing</span>

<span class="kr">instance</span> <span class="kt">YesNo</span> <span class="p">(</span><span class="kt">Maybe</span> <span class="n">a</span><span class="p">)</span> <span class="kr">where</span>
  <span class="n">yesno</span> <span class="p">(</span><span class="kt">Just</span> <span class="kr">_</span><span class="p">)</span> <span class="o">=</span> <span class="kt">True</span>
  <span class="n">yesno</span> <span class="kt">Nothing</span> <span class="o">=</span> <span class="kt">False</span>
</code></pre> </div> <div class="language-haskell highlighter-rouge"><pre class="highlight"><code><span class="o">&gt;</span> <span class="n">yesno</span> <span class="o">$</span> <span class="n">length</span> <span class="kt">[]</span>
<span class="o">&gt;</span> <span class="kt">False</span>
<span class="o">&gt;</span> <span class="n">yesno</span> <span class="s">"test"</span>
<span class="o">&gt;</span> <span class="kt">True</span>
<span class="o">&gt;</span> <span class="n">yesno</span> <span class="s">""</span>
<span class="o">&gt;</span> <span class="kt">False</span>
<span class="o">&gt;</span> <span class="o">:</span><span class="n">t</span> <span class="n">yesno</span>
<span class="o">&gt;</span> <span class="kt">Yesno</span> <span class="o">::</span> <span class="p">(</span><span class="kt">YesNo</span> <span class="n">a</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="n">a</span> <span class="o">-&gt;</span> <span class="kt">Bool</span>
</code></pre> </div> <p>We can now create a function that mimics the if statement, but works with <code class="highlighter-rouge">YesNo</code> values</p> <div class="language-haskell highlighter-rouge"><pre class="highlight"><code><span class="n">yesnoIf</span> <span class="o">::</span> <span class="p">(</span><span class="kt">YesNo</span> <span class="n">y</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="n">y</span> <span class="o">-&gt;</span> <span class="n">a</span> <span class="o">-&gt;</span> <span class="n">a</span> <span class="o">-&gt;</span> <span class="n">a</span>
<span class="n">yesnoIf</span> <span class="n">yesnoVal</span> <span class="n">yesResult</span> <span class="n">noResult</span> <span class="o">=</span> <span class="kr">if</span> <span class="n">yesno</span> <span class="n">yesnoVal</span> <span class="kr">then</span> <span class="n">yesResult</span> <span class="kr">else</span> <span class="n">noResult</span>
</code></pre> </div> <h3 id="the-functor-typeclass">The Functor typeclass</h3> <div class="language-haskell highlighter-rouge"><pre class="highlight"><code><span class="kr">class</span> <span class="kt">Functor</span> <span class="n">f</span> <span class="kr">where</span>
  <span class="n">fmap</span> <span class="o">::</span> <span class="p">(</span><span class="n">a</span> <span class="o">-&gt;</span> <span class="n">b</span><span class="p">)</span> <span class="n">f</span> <span class="n">a</span> <span class="o">-&gt;</span> <span class="n">f</span> <span class="n">b</span>
</code></pre> </div> <p>The <code class="highlighter-rouge">Functor</code> typeclass defines a single function, <code class="highlighter-rouge">fmap</code>. <code class="highlighter-rouge">f</code> is not a concrete type, but a type constructor that takes one parameter. <code class="highlighter-rouge">fmap</code> takes a function from one type to another and a functor applied with one type and returns a functor applied with another type.</p> <p>The list is an instance of the <code class="highlighter-rouge">Functor</code> typeclass</p> <div class="language-haskell highlighter-rouge"><pre class="highlight"><code><span class="kr">instance</span> <span class="kt">Functor</span> <span class="kt">[]</span> <span class="kr">where</span>
  <span class="n">fmap</span> <span class="o">=</span> <span class="n">map</span>
</code></pre> </div> <p>We didn’t write <code class="highlighter-rouge">instance Functor [a]</code> because from <code class="highlighter-rouge">fmap :: (a -&gt; b) -&gt; f a -&gt; f b</code> we see that the <code class="highlighter-rouge">f</code> has to be a type constructor that takes one type. <code class="highlighter-rouge">[a]</code> is a concrete type, while <code class="highlighter-rouge">[]</code> is a type constructor that takes one type.</p> <p>Types that can act like a box can be functors. <code class="highlighter-rouge">Maybe</code> can act like a box, holding <code class="highlighter-rouge">Just &lt;something&gt;</code> or <code class="highlighter-rouge">Nothing</code>.</p> <div class="language-haskell highlighter-rouge"><pre class="highlight"><code><span class="kr">instance</span> <span class="kt">Functor</span> <span class="kt">Maybe</span> <span class="kr">where</span>
  <span class="n">fmap</span> <span class="n">f</span> <span class="p">(</span><span class="kt">Just</span> <span class="n">x</span><span class="p">)</span> <span class="o">=</span> <span class="kt">Just</span> <span class="p">(</span><span class="n">f</span> <span class="n">x</span><span class="p">)</span>
  <span class="n">fmap</span> <span class="n">f</span> <span class="kt">Nothing</span> <span class="o">=</span> <span class="kt">Nothing</span>
</code></pre> </div> <p>Again we did not specify a type. <code class="highlighter-rouge">Functor</code> wants a type constructor that takes one type and not a concrete type.</p> <p>The <code class="highlighter-rouge">Tree a</code> can be mapped over and made an instance of Functor.</p> <div class="language-haskell highlighter-rouge"><pre class="highlight"><code><span class="kr">instance</span> <span class="kt">Functor</span> <span class="kt">Tree</span> <span class="kr">where</span>
  <span class="n">fmap</span> <span class="n">f</span> <span class="kt">EmptyTree</span> <span class="o">=</span> <span class="kt">EmptyTree</span>
  <span class="n">fmap</span> <span class="n">f</span> <span class="p">(</span><span class="kt">Node</span> <span class="n">x</span> <span class="n">leftsub</span> <span class="n">rightsub</span><span class="p">)</span> <span class="o">=</span> <span class="kt">Node</span> <span class="p">(</span><span class="n">f</span> <span class="n">x</span><span class="p">)</span> <span class="p">(</span><span class="n">fmap</span> <span class="n">f</span> <span class="n">leftsub</span><span class="p">)</span> <span class="p">(</span><span class="n">fmap</span> <span class="n">f</span> <span class="n">righsub</span><span class="p">)</span>
</code></pre> </div> <p>The <code class="highlighter-rouge">fmap</code> function for <code class="highlighter-rouge">Tree</code> recursively applies <code class="highlighter-rouge">f</code> to each of the items in the <code class="highlighter-rouge">Tree</code>.</p> <div class="language-haskell highlighter-rouge"><pre class="highlight"><code><span class="o">&gt;</span> <span class="n">fmap</span> <span class="p">(</span><span class="o">*</span><span class="mi">4</span><span class="p">)</span> <span class="p">(</span><span class="n">foldr</span> <span class="n">treeInsert</span> <span class="kt">EmptyTree</span> <span class="p">[</span><span class="mi">5</span><span class="p">,</span><span class="mi">7</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">7</span><span class="p">])</span>
<span class="o">&gt;</span> <span class="kt">Node</span> <span class="mi">28</span> <span class="p">(</span><span class="kt">Node</span> <span class="mi">4</span> <span class="kt">EmptyTree</span> <span class="p">(</span><span class="kt">Node</span> <span class="mi">8</span> <span class="kt">EmptyTree</span> <span class="p">(</span><span class="kt">Node</span> <span class="mi">12</span> <span class="kt">EmptyTree</span> <span class="p">(</span><span class="kt">Node</span> <span class="mi">20</span> <span class="kt">EmptyTree</span> <span class="kt">EmptyTree</span><span class="p">))))</span> <span class="kt">EmptyTree</span>  
</code></pre> </div> <p>Now consider <code class="highlighter-rouge">Either a b</code>. The <code class="highlighter-rouge">Functor</code> typeclass wants a type constructor that takes only one type parameter, but <code class="highlighter-rouge">Either</code> takes two. We can partially apply <code class="highlighter-rouge">Either</code> by feeding it only one parameter, so that it has one free parameter.</p> <div class="language-haskell highlighter-rouge"><pre class="highlight"><code><span class="kr">instance</span> <span class="kt">Functor</span> <span class="p">(</span><span class="kt">Either</span> <span class="n">a</span><span class="p">)</span> <span class="kr">where</span>
  <span class="n">fmap</span> <span class="n">f</span> <span class="p">(</span><span class="kt">Right</span> <span class="n">x</span><span class="p">)</span> <span class="o">=</span> <span class="kt">Right</span> <span class="p">(</span><span class="n">f</span> <span class="n">x</span><span class="p">)</span>
  <span class="n">fmap</span> <span class="n">f</span> <span class="p">(</span><span class="kt">Left</span> <span class="n">x</span><span class="p">)</span> <span class="o">=</span> <span class="kt">Left</span> <span class="n">x</span>
</code></pre> </div> <p><code class="highlighter-rouge">Either a</code> is a type constructor that takes one parameter. The type signature for this specific <code class="highlighter-rouge">fmap</code> will be <code class="highlighter-rouge">(b -&gt; c) -&gt; Either a b -&gt; Either a c</code> In the implementation, we mapped in the case of a <code class="highlighter-rouge">Right</code> value constructor but not in the case of a <code class="highlighter-rouge">Left</code>.</p> <p>If we wanted to map one function over both of them, <code class="highlighter-rouge">a</code> and <code class="highlighter-rouge">b</code> would have to be the same type.</p> <p>Maps from <code class="highlighter-rouge">Data.Map</code> can also be made a functor because they hold values. <code class="highlighter-rouge">fmap</code> will map a function <code class="highlighter-rouge">v -&gt; v'</code> over a map of type <code class="highlighter-rouge">Map k v</code> and return a map of type <code class="highlighter-rouge">Map k v'</code>.</p> <p>Functors should obey some laws.</p> <ul> <li><code class="highlighter-rouge">fmap id = id</code></li> <li><code class="highlighter-rouge">fmap (g . f) = fmap g . fmap f</code></li> </ul> <h3 id="kinds">Kinds</h3> <p>Functions are also values because we can pass them etc. Types are like labels carried by values so that we can reason about them. Types have their own labels called <strong>kinds</strong>. A <strong>kind</strong> is something like the type of a type.</p> <div class="language-haskell highlighter-rouge"><pre class="highlight"><code><span class="o">&gt;</span> <span class="o">:</span><span class="n">k</span> <span class="kt">Int</span>
<span class="o">&gt;</span> <span class="kt">Int</span> <span class="o">::</span> <span class="o">*</span>
</code></pre> </div> <p>A <code class="highlighter-rouge">*</code> means that the type is a concrete type, a type without type parameters.</p> <div class="language-haskell highlighter-rouge"><pre class="highlight"><code><span class="o">&gt;</span> <span class="o">:</span><span class="n">k</span> <span class="kt">Maybe</span>
<span class="o">&gt;</span> <span class="kt">Maybe</span> <span class="o">::</span> <span class="o">*</span> <span class="o">-&gt;</span> <span class="o">*</span>
</code></pre> </div> <p>The <code class="highlighter-rouge">Maybe</code> constructor takes one concrete type, and then returns a concrete type.</p> <div class="language-haskell highlighter-rouge"><pre class="highlight"><code><span class="o">&gt;</span> <span class="o">:</span><span class="n">k</span> <span class="kt">Maybe</span> <span class="kt">Int</span>
<span class="o">&gt;</span> <span class="kt">Maybe</span> <span class="kt">Int</span> <span class="o">::</span> <span class="o">*</span>
</code></pre> </div> <p>We use <code class="highlighter-rouge">:k</code> on a type to get its kind, just like <code class="highlighter-rouge">:t</code> on a value to get its type.</p> <div class="language-haskell highlighter-rouge"><pre class="highlight"><code><span class="o">&gt;</span> <span class="o">:</span><span class="n">k</span> <span class="kt">Either</span>
<span class="o">&gt;</span> <span class="kt">Either</span> <span class="o">::</span> <span class="o">*</span> <span class="o">-&gt;</span> <span class="o">*</span> <span class="o">-&gt;</span> <span class="o">*</span>
<span class="o">&gt;</span> <span class="o">:</span><span class="n">k</span> <span class="kt">Either</span> <span class="kt">Int</span>
<span class="o">&gt;</span> <span class="kt">Either</span> <span class="kt">Int</span> <span class="o">::</span> <span class="o">*</span> <span class="o">-&gt;</span> <span class="o">*</span>
</code></pre> </div> <p><code class="highlighter-rouge">Either</code> takes two concrete types as type parameters to produce a concrete type. A partially applied either takes a single concrete type to produce a concrete type.</p> <div class="language-haskell highlighter-rouge"><pre class="highlight"><code><span class="kr">class</span> <span class="kt">Tofu</span> <span class="n">t</span> <span class="kr">where</span>
  <span class="n">tofu</span> <span class="o">::</span> <span class="n">j</span> <span class="n">a</span> <span class="o">-&gt;</span> <span class="n">t</span> <span class="n">a</span> <span class="n">j</span>
</code></pre> </div> <p>Because <code class="highlighter-rouge">j a</code> is used as the type of a value that the <code class="highlighter-rouge">tofu</code> function takes as its parameter, <code class="highlighter-rouge">j a</code> has to have a kind of <code class="highlighter-rouge">*</code>. We assume <code class="highlighter-rouge">*</code> for <code class="highlighter-rouge">a</code> so we can infer that <code class="highlighter-rouge">j</code> has to have a kind of <code class="highlighter-rouge">* -&gt; *</code>. We see that <code class="highlighter-rouge">t</code> has to produce a concrete value to, and that it takes two types.</p> <p>Knowing that <code class="highlighter-rouge">a</code> has a kind of <code class="highlighter-rouge">*</code> and <code class="highlighter-rouge">j</code> has a kind of <code class="highlighter-rouge">* -&gt; *</code>, we infer that <code class="highlighter-rouge">t</code> has to have a kind of <code class="highlighter-rouge">* -&gt; (* -&gt; *) -&gt; *</code>. So, it takes a concrete type (<code class="highlighter-rouge">a</code>), a type constructor that takes one concrete type (<code class="highlighter-rouge">j</code>) and produces a concrete type.</p> <div class="language-haskell highlighter-rouge"><pre class="highlight"><code><span class="kr">data</span> <span class="kt">Frank</span> <span class="n">a</span> <span class="n">b</span> <span class="o">=</span> <span class="kt">Frank</span> <span class="p">{</span><span class="n">frankField</span> <span class="o">::</span> <span class="n">b</span> <span class="n">a</span><span class="p">}</span> <span class="kr">deriving</span> <span class="p">(</span><span class="kt">Show</span><span class="p">)</span>
</code></pre> </div> <p>This type has a kind of <code class="highlighter-rouge">* -&gt; (* -&gt; *) -&gt; *</code>. Fields in algebraic data types are made to hold values, so the must be of kind <code class="highlighter-rouge">*</code>. We assume <code class="highlighter-rouge">*</code> for <code class="highlighter-rouge">a</code>, which means that <code class="highlighter-rouge">b</code> takes one type parameter and so its kind is <code class="highlighter-rouge">* -&gt; *</code>. We now see that <code class="highlighter-rouge">Frank</code> has a kind of <code class="highlighter-rouge">* -&gt; (* -&gt; *) -&gt; *</code>.</p> <div class="language-haskell highlighter-rouge"><pre class="highlight"><code><span class="o">&gt;</span> <span class="o">:</span><span class="n">t</span> <span class="kt">Frank</span> <span class="p">{</span><span class="n">frankField</span> <span class="o">=</span> <span class="kt">Just</span> <span class="s">"String"</span><span class="p">}</span>
<span class="o">&gt;</span> <span class="kt">Frank</span> <span class="p">{</span><span class="n">frankField</span> <span class="o">=</span> <span class="kt">Just</span> <span class="s">"String"</span><span class="p">}</span> <span class="o">::</span> <span class="kt">Frank</span> <span class="p">[</span><span class="kt">Char</span><span class="p">]</span> <span class="kt">Maybe</span>
<span class="o">&gt;</span> <span class="o">:</span><span class="n">t</span> <span class="kt">Frank</span> <span class="p">{</span><span class="n">frankField</span> <span class="o">=</span> <span class="s">"String"</span><span class="p">}</span>
<span class="o">&gt;</span> <span class="kt">Frank</span> <span class="p">{</span><span class="n">frankField</span> <span class="o">=</span> <span class="s">"String"</span><span class="p">}</span> <span class="o">::</span> <span class="kt">Frank</span> <span class="kt">Char</span> <span class="kt">[]</span>
</code></pre> </div> <p>Because <code class="highlighter-rouge">frankField</code> has a type of form <code class="highlighter-rouge">a b</code>, its values must have types that are of a similar form as well. They can be <code class="highlighter-rouge">Just "String"</code>, which has a type of <code class="highlighter-rouge">Maybe [Char]</code>, or they can have a value of <code class="highlighter-rouge">['S', 't', 'r', 'i', 'n', 'g']</code> which has a type of <code class="highlighter-rouge">[Char]</code>.</p> <p>Making <code class="highlighter-rouge">Frank</code> an instance of <code class="highlighter-rouge">Tofu</code> is quite simple. <code class="highlighter-rouge">tofu</code> takes a <code class="highlighter-rouge">j a</code>, and returns a type of <code class="highlighter-rouge">t a j</code></p> <div class="language-haskell highlighter-rouge"><pre class="highlight"><code><span class="kr">instance</span> <span class="kt">Tofu</span> <span class="kt">Frank</span> <span class="kr">where</span>
  <span class="n">tofu</span> <span class="n">x</span> <span class="o">=</span> <span class="kt">Frank</span> <span class="n">x</span>
</code></pre> </div> <div class="language-haskell highlighter-rouge"><pre class="highlight"><code><span class="o">&gt;</span> <span class="n">tofu</span> <span class="p">(</span><span class="kt">Just</span> <span class="sc">'a'</span><span class="p">)</span> <span class="o">::</span> <span class="kt">Frank</span> <span class="kt">Char</span> <span class="kt">Maybe</span>
<span class="o">&gt;</span> <span class="kt">Frank</span> <span class="p">{</span><span class="n">frankField</span> <span class="o">=</span> <span class="kt">Just</span> <span class="sc">'a'</span><span class="p">}</span>
<span class="o">&gt;</span> <span class="n">tofu</span> <span class="p">[</span><span class="s">"HELLO"</span><span class="p">]</span> <span class="o">::</span> <span class="kt">Frank</span> <span class="p">[</span><span class="kt">Char</span><span class="p">]</span> <span class="kt">[]</span>
<span class="o">&gt;</span> <span class="kt">Frank</span> <span class="p">{</span><span class="n">frankField</span> <span class="o">=</span> <span class="p">[</span><span class="s">"HELLO"</span><span class="p">]}</span>
</code></pre> </div> <p>This has no real use. A more complicated type is:</p> <div class="language-haskell highlighter-rouge"><pre class="highlight"><code><span class="kr">data</span> <span class="kt">Barry</span> <span class="n">t</span> <span class="n">k</span> <span class="n">p</span> <span class="o">=</span> <span class="kt">Barry</span> <span class="p">{</span> <span class="n">yabba</span> <span class="o">::</span> <span class="n">p</span><span class="p">,</span> <span class="n">dabba</span> <span class="o">::</span> <span class="n">t</span> <span class="n">k</span><span class="p">}</span>
</code></pre> </div> <p>Now we want to make it an instance of <code class="highlighter-rouge">Functor</code>. <code class="highlighter-rouge">Functor</code> wants types of kind <code class="highlighter-rouge">* -&gt; *</code></p> <p>It is safe to assume that <code class="highlighter-rouge">p</code> is a concrete type, and thus has a kind of <code class="highlighter-rouge">*</code>. For <code class="highlighter-rouge">k</code>, we assume <code class="highlighter-rouge">*</code>, and so <code class="highlighter-rouge">t</code> has a kind of <code class="highlighter-rouge">* -&gt; *</code>.</p> <p><code class="highlighter-rouge">Barry</code> has a kind of <code class="highlighter-rouge">(* -&gt; *) -&gt; * -&gt; * -&gt; *</code>.</p> <p>Now we can make this type a part of <code class="highlighter-rouge">Functor</code>. We have to partially apply the first two type parameters, so that we are left with <code class="highlighter-rouge">* -&gt; *</code>.</p> <p>This means that the start of the instance declaration will be <code class="highlighter-rouge">instance Functor (Barry a b) where</code>. Considering <code class="highlighter-rouge">fmap</code> specifically for <code class="highlighter-rouge">Barry</code>, it would have type <code class="highlighter-rouge">fmap :: (a -&gt; b) -&gt; Barry c d a -&gt; Barry c d b</code> when the <code class="highlighter-rouge">Functor</code>’s <code class="highlighter-rouge">f</code> is replaced with <code class="highlighter-rouge">Barry c d</code>.</p> <div class="language-haskell highlighter-rouge"><pre class="highlight"><code><span class="kr">instance</span> <span class="kt">Functor</span> <span class="p">(</span><span class="kt">Barry</span> <span class="n">a</span> <span class="n">b</span><span class="p">)</span> <span class="kr">where</span>
  <span class="n">fmap</span> <span class="n">f</span> <span class="p">(</span><span class="kt">Barry</span> <span class="p">{</span><span class="n">yabba</span> <span class="o">=</span> <span class="n">x</span><span class="p">,</span> <span class="n">dabba</span> <span class="o">=</span> <span class="n">y</span><span class="p">})</span> <span class="o">=</span> <span class="kt">Barry</span> <span class="p">{</span><span class="n">yabba</span> <span class="o">=</span> <span class="n">f</span> <span class="n">x</span><span class="p">,</span> <span class="n">dabba</span> <span class="o">=</span> <span class="n">y</span><span class="p">}</span>
</code></pre> </div> <h2 id="input-and-output">Input and output</h2> <p>The function <code class="highlighter-rouge">putStrLn</code> prints a string</p> <div class="language-haskell highlighter-rouge"><pre class="highlight"><code><span class="o">&gt;</span> <span class="o">:</span><span class="n">t</span> <span class="n">putStrLn</span>
<span class="o">&gt;</span> <span class="n">putStrLn</span> <span class="o">::</span> <span class="kt">String</span> <span class="o">-&gt;</span> <span class="kt">IO</span> <span class="nb">()</span>
</code></pre> </div> <p><code class="highlighter-rouge">putStrLn</code> takes a string and returns an IO action, that has a result type of <code class="highlighter-rouge">()</code>. An IO action is something that, when performed, will carry out an action with a side-effect, and will also contain some kind of return value. Printing a string doesn’t have a meaningful return value, so an empty tuple is returned.</p> <p>An IO action will be performed when we give it a name of <code class="highlighter-rouge">main</code> and then run our program.</p> <div class="language-haskell highlighter-rouge"><pre class="highlight"><code><span class="n">main</span> <span class="o">=</span> <span class="kr">do</span>
  <span class="n">putStrln</span> <span class="s">"Hello, what is your name?"</span>
  <span class="n">name</span> <span class="o">&lt;-</span> <span class="n">getLine</span>
  <span class="n">putStrLn</span> <span class="p">(</span><span class="s">"Hello"</span> <span class="o">++</span> <span class="n">name</span><span class="p">)</span>
</code></pre> </div> <p><code class="highlighter-rouge">main</code> always has a type signature of <code class="highlighter-rouge">main :: IO &lt;type&gt;</code> where <code class="highlighter-rouge">&lt;type&gt;</code> is some concrete type. By convention, we do not usually specify a type declaration for <code class="highlighter-rouge">main</code>.</p> <p><code class="highlighter-rouge">getLine</code> reads a line from the input, it has a type <code class="highlighter-rouge">getLine :: IO String</code>.</p> <p>The line <code class="highlighter-rouge">name &lt;- getLine</code> can be read as perform the IO action and then bind its result to <code class="highlighter-rouge">name</code>. As <code class="highlighter-rouge">getLine</code> has a type <code class="highlighter-rouge">IO String</code>, <code class="highlighter-rouge">name</code> will have a type of <code class="highlighter-rouge">String</code>.</p> <p>We can only take the data from <code class="highlighter-rouge">getLine</code> with <code class="highlighter-rouge">&lt;-</code> from within another IO action. <code class="highlighter-rouge">getLine</code> is impure because its result value is not guaranteed to be the same when performed twice.</p> <p>In a <code class="highlighter-rouge">do</code> block, the last action cannot be bound to a name.</p> <p>IO actions will only be performed when they are given a name of <code class="highlighter-rouge">main</code> or when they are inside a bigger IO faction that we composed with a <code class="highlighter-rouge">do</code> block.</p> <div class="language-haskell highlighter-rouge"><pre class="highlight"><code><span class="n">main</span> <span class="o">=</span> <span class="kr">do</span>
  <span class="n">line</span> <span class="o">&lt;-</span> <span class="n">getLine</span>
  <span class="kr">if</span> <span class="n">null</span> <span class="n">line</span>
    <span class="kr">then</span> <span class="n">return</span> <span class="nb">()</span>
    <span class="kr">else</span> <span class="kr">do</span>
      <span class="n">putStrLn</span> <span class="o">$</span> <span class="n">reverseWords</span> <span class="n">line</span>
      <span class="n">main</span>

<span class="n">reverseWords</span> <span class="o">::</span> <span class="kt">String</span> <span class="o">-&gt;</span> <span class="kt">String</span>
<span class="n">reverseWords</span> <span class="o">=</span> <span class="n">unwords</span> <span class="o">.</span> <span class="n">map</span> <span class="n">reverse</span> <span class="o">.</span> <span class="n">words</span>
</code></pre> </div> <p>The program above reads input and reverses it until a blank line is input.</p> <p>In an IO <code class="highlighter-rouge">do</code> block, ifs have to have a form of <code class="highlighter-rouge">if condition then IO action else IO action</code>.</p> <p>Because we have to do exactly one IO action after the else, we use a <code class="highlighter-rouge">do</code> block to glue together two IO actions into one.</p> <h3 id="haskell-return">Haskell return</h3> <p>While <code class="highlighter-rouge">return</code> in most languages ends execution of a method or subroutine, in Haskell (IO actions specifically), it makes an IO action out of the pure value. Using <code class="highlighter-rouge">return</code> <strong>does not</strong> cause the IO <code class="highlighter-rouge">do</code> block to end execution. All these returns do is make IO actions that don’t do anything. We can use <code class="highlighter-rouge">return</code> in combination with <code class="highlighter-rouge">&lt;-</code> to bind to names.</p> <div class="language-haskell highlighter-rouge"><pre class="highlight"><code><span class="n">main</span> <span class="o">=</span> <span class="kr">do</span>
  <span class="n">a</span> <span class="o">&lt;-</span> <span class="n">return</span> <span class="s">"String"</span>
  <span class="n">b</span> <span class="o">&lt;-</span> <span class="n">return</span> <span class="s">"gnirtS"</span>
  <span class="n">putStrLn</span> <span class="o">$</span> <span class="n">a</span> <span class="o">++</span> <span class="s">" "</span> <span class="o">++</span> <span class="n">b</span>
</code></pre> </div> <p>When dealing with IO blocks we mostly use <code class="highlighter-rouge">return</code> either because we need to create an IO action that does not do anything or because we do not want the IO action that is made up from a <code class="highlighter-rouge">do</code> block to have the result value of its last action.</p> <h3 id="io-functions">IO functions</h3> <p><strong>putStr</strong> takes a string as a parameter and returns an IO action that will print without a newline</p> <p><strong>putChar</strong> takes a character as a parameter and returns an IO action that will print it</p> <p><strong>print</strong> takes a value of a type that is an instance of <code class="highlighter-rouge">Show</code>, and prints it</p> <p><strong>getChar</strong> an IO action that reads a character form input. Reading does not happen until the user presses the enter key</p> <p><strong>when</strong> is found in <code class="highlighter-rouge">Control.Monad</code>. In a <code class="highlighter-rouge">do</code> block it appears like a control flow statement, but it is a function. It takes a boolean value and an IO action. If the boolean value is <code class="highlighter-rouge">True</code>, it returns the same IO action passed to it, otherwise it returns the <code class="highlighter-rouge">return ()</code> action.</p> <p><strong>sequence</strong> takes a list of IO actions and returns an IO action which will perform all of the Io actions in the list. <code class="highlighter-rouge">sequence :: [IO a] -&gt; IO [a]</code></p> <p><strong>mapM</strong> and <strong>mapM_</strong> <code class="highlighter-rouge">mapM</code> takes a function and a list, maps the function over the list and then sequences it, <code class="highlighter-rouge">mapM_</code> does the same except that it throws away the result later. <code class="highlighter-rouge">mapM_</code> is used when we do not care what result our sequenced IO actions have</p> <p><strong>forever</strong> located in <code class="highlighter-rouge">Control.Monad</code>, takes an IO action and returns an IO action that repeats the IO action forever</p> <p><strong>forM</strong> located in <code class="highlighter-rouge">Control.Monad</code>, is like <code class="highlighter-rouge">mapM</code> except that it has its parameters switched around. The first parameter is the list and the second is the function to map over that list, which is then sequenced</p> <div class="language-haskell highlighter-rouge"><pre class="highlight"><code><span class="kr">import</span> <span class="nn">Control.Monad</span>

<span class="n">main</span> <span class="o">=</span> <span class="kr">do</span>
  <span class="n">colors</span> <span class="o">&lt;-</span> <span class="n">forM</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">]</span> <span class="p">(</span><span class="nf">\</span><span class="n">a</span> <span class="o">-&gt;</span> <span class="kr">do</span>
    <span class="n">putStrLn</span> <span class="o">$</span> <span class="s">"Which color do you associate with the number "</span> <span class="o">++</span> <span class="n">show</span> <span class="n">a</span> <span class="o">++</span> <span class="s">"?"</span>
    <span class="n">color</span> <span class="o">&lt;-</span> <span class="n">getLine</span>
    <span class="n">return</span> <span class="n">color</span><span class="p">)</span>
  <span class="n">putStrLn</span> <span class="s">"The collors that you associate with 1, 2, 3, and 4 are: "</span>
  <span class="n">mapM</span> <span class="n">putStrLn</span> <span class="n">colors</span>
</code></pre> </div> <p>The <code class="highlighter-rouge">(\a -&gt; do ...)</code> is a function that takes a number and returns an IO action. We have to surround it with parentheses, otherwise the lambda thinks the last two IO actions below to it. We do <code class="highlighter-rouge">return color</code> in the inside <code class="highlighter-rouge">do</code> block. We do that so that the IO action which the <code class="highlighter-rouge">do</code> block defines has the result of our color contained within it. We could have left the last line as <code class="highlighter-rouge">getLine</code>.</p> <p>The <code class="highlighter-rouge">forM</code> called with its two parameters, produces an IO action, whose result we bind to <code class="highlighter-rouge">colors</code>. <code class="highlighter-rouge">colors</code> is just a list of strings. At the end we print out those strings with <code class="highlighter-rouge">mapM putStrLn colors</code>.</p> <p><code class="highlighter-rouge">forM</code> can be thought of as meaning ‘make an IO action for every element in this list, perform those actions and bind their results to something’.</p> <h3 id="files-and-streams">Files and streams</h3> <p><code class="highlighter-rouge">getContents</code> is an IO action that reads everything from the standard input until it encounters an end-of-file character.</p> <p>Its type is <code class="highlighter-rouge">getContents :: IO String</code>. <code class="highlighter-rouge">getContents</code> does lazy IO.</p> <p>The pattern of getting some string from the input, transforming it with a function, and then outputting the result is so common that there exists a function for it.</p> <p><strong>interact</strong> takes a function of type <code class="highlighter-rouge">String -&gt; String</code> as a parameter and returns an IO action that will take some input run that function on it and then print out the function’s result.</p> <div class="language-haskell highlighter-rouge"><pre class="highlight"><code><span class="n">main</span> <span class="o">=</span> <span class="n">interact</span> <span class="n">shortLinesOnly</span>

<span class="n">shortLinesOnly</span> <span class="o">::</span> <span class="kt">String</span> <span class="o">-&gt;</span> <span class="kt">String</span>
<span class="n">shortLinesOnly</span> <span class="n">input</span> <span class="o">=</span>
  <span class="kr">let</span> <span class="n">allLines</span> <span class="o">=</span> <span class="n">lines</span> <span class="n">input</span>
    <span class="n">shortLines</span> <span class="o">=</span> <span class="n">filter</span> <span class="p">(</span><span class="nf">\</span><span class="n">line</span> <span class="o">-&gt;</span> <span class="n">length</span> <span class="n">line</span> <span class="o">&lt;</span> <span class="mi">10</span><span class="p">)</span> <span class="n">allLines</span>
    <span class="n">result</span> <span class="o">=</span> <span class="n">unlines</span> <span class="n">shortLines</span>
  <span class="kr">in</span> <span class="n">result</span>
</code></pre> </div> <p>We could write thie in a less readable manner</p> <div class="language-haskell highlighter-rouge"><pre class="highlight"><code><span class="n">main</span> <span class="o">=</span> <span class="n">interact</span> <span class="o">$</span> <span class="n">unlines</span> <span class="o">.</span> <span class="n">filter</span> <span class="p">((</span><span class="o">&lt;</span><span class="mi">10</span><span class="p">)</span> <span class="o">.</span> <span class="n">length</span><span class="p">)</span> <span class="o">.</span> <span class="n">lines</span>
</code></pre> </div> <p><code class="highlighter-rouge">interact</code> can be used to make programs that are piped some contents into them and then dump some result out, or it can be used to make programs that appear to take a line of input from the user, give back some result and then take another line and so on.</p> <div class="language-haskell highlighter-rouge"><pre class="highlight"><code><span class="n">respondPalindromes</span> <span class="n">contents</span> <span class="o">=</span> <span class="n">unlines</span> <span class="p">(</span><span class="n">map</span> <span class="p">(</span><span class="nf">\</span><span class="n">xs</span> <span class="o">-&gt;</span>
  <span class="kr">if</span> <span class="n">isPalindrome</span> <span class="n">xs</span> <span class="kr">then</span> <span class="s">"palindrome"</span> <span class="kr">else</span> <span class="s">"not a palindrome"</span><span class="p">)</span> <span class="p">(</span><span class="n">lines</span> <span class="n">contents</span><span class="p">))</span>
  <span class="kr">where</span> <span class="n">isPalindrome</span> <span class="n">xs</span> <span class="o">=</span> <span class="n">xs</span> <span class="o">==</span> <span class="n">reverse</span> <span class="n">xs</span>
</code></pre> </div> </div> <script type="text/javascript" async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"> </script> <div id="toc" class="dropdown"> <img id="dropdown-button" src="/img/ic_toc.png"></img> <div id="toc-content" class="dropdown-content"> </div> </div> </article> </main> </div> <footer> <div class="search"> <form action="/Haskell-Notes" id="search_form"> <div class="tipue_search_left"><img src="/js/tipuesearch/search.png" class="tipue_search_icon"></div> <div class="tipue_search_right "><input class="mdl-textfield__input"type="text" name="q" id="tipue_search_input" pattern=".{3,}" title="At least 3 characters" required></div> <div style="clear: both;"></div> </form> <div id="tipue_search_content"></div> </div> </footer> <script>function toggle(){var e=document.getElementById("nav"),t=document.getElementById("nav-left"),n=null!==e?e:t,r=document.getElementById("menu"),i=document.getElementById("wrap");"menu-open"==n.className||"menu-open-left"==n.className?(n.className="",r.className="",i.className=""):null!==reverse?(n.className+="menu-open-left",r.className+="btn-close",i.className+="fixed"):(n.className+="menu-open",r.className+="btn-close",i.className+="fixed")}function menuClick(){if(document.addEventListener&&null!==icon)icon.addEventListener("click",toggle);else{if(!document.attachEvent||null===icon)return;icon.attachEvent("onclick",toggle)}}var normal=document.getElementById("nav-menu"),reverse=document.getElementById("nav-menu-left"),icon=null!==normal?normal:reverse;menuClick(),function(e,t){"use strict";"object"==typeof module&&"object"==typeof module.exports?module.exports=e.document?t(e,!0):function(e){if(!e.document)throw new Error("jQuery requires a window with a document");return t(e)}:t(e)}("undefined"!=typeof window?window:this,function(e,t){"use strict";function n(e,t){t=t||ne;var n=t.createElement("script");n.text=e,t.head.appendChild(n).parentNode.removeChild(n)}function r(e){var t=!!e&&"length"in e&&e.length,n=ge.type(e);return"function"!==n&&!ge.isWindow(e)&&("array"===n||0===t||"number"==typeof t&&t>0&&t-1 in e)}function i(e,t){return e.nodeName&&e.nodeName.toLowerCase()===t.toLowerCase()}function o(e,t,n){return ge.isFunction(t)?ge.grep(e,function(e,r){return!!t.call(e,r,e)!==n}):t.nodeType?ge.grep(e,function(e){return e===t!==n}):"string"!=typeof t?ge.grep(e,function(e){return se.call(t,e)>-1!==n}):ke.test(t)?ge.filter(t,e,n):(t=ge.filter(t,e),ge.grep(e,function(e){return se.call(t,e)>-1!==n&&1===e.nodeType}))}function a(e,t){for(;(e=e[t])&&1!==e.nodeType;);return e}function s(e){var t={};return ge.each(e.match(Ae)||[],function(e,n){t[n]=!0}),t}function u(e){return e}function l(e){throw e}function c(e,t,n,r){var i;try{e&&ge.isFunction(i=e.promise)?i.call(e).done(t).fail(n):e&&ge.isFunction(i=e.then)?i.call(e,t,n):t.apply(void 0,[e].slice(r))}catch(e){n.apply(void 0,[e])}}function f(){ne.removeEventListener("DOMContentLoaded",f),e.removeEventListener("load",f),ge.ready()}function p(){this.expando=ge.expando+p.uid++}function d(e){return"true"===e||"false"!==e&&("null"===e?null:e===+e+""?+e:Re.test(e)?JSON.parse(e):e)}function h(e,t,n){var r;if(void 0===n&&1===e.nodeType)if(r="data-"+t.replace(Ie,"-$&").toLowerCase(),"string"==typeof(n=e.getAttribute(r))){try{n=d(n)}catch(e){}Pe.set(e,t,n)}else n=void 0;return n}function g(e,t,n,r){var i,o=1,a=20,s=r?function(){return r.cur()}:function(){return ge.css(e,t,"")},u=s(),l=n&&n[3]||(ge.cssNumber[t]?"":"px"),c=(ge.cssNumber[t]||"px"!==l&&+u)&&We.exec(ge.css(e,t));if(c&&c[3]!==l){l=l||c[3],n=n||[],c=+u||1;do{o=o||".5",c/=o,ge.style(e,t,c+l)}while(o!==(o=s()/u)&&1!==o&&--a)}return n&&(c=+c||+u||0,i=n[1]?c+(n[1]+1)*n[2]:+n[2],r&&(r.unit=l,r.start=c,r.end=i)),i}function m(e){var t,n=e.ownerDocument,r=e.nodeName,i=ze[r];return i||(t=n.body.appendChild(n.createElement(r)),i=ge.css(t,"display"),t.parentNode.removeChild(t),"none"===i&&(i="block"),ze[r]=i,i)}function v(e,t){for(var n,r,i=[],o=0,a=e.length;o<a;o++)r=e[o],r.style&&(n=r.style.display,t?("none"===n&&(i[o]=Oe.get(r,"display")||null,i[o]||(r.style.display="")),""===r.style.display&&$e(r)&&(i[o]=m(r))):"none"!==n&&(i[o]="none",Oe.set(r,"display",n)));for(o=0;o<a;o++)null!=i[o]&&(e[o].style.display=i[o]);return e}function y(e,t){var n;return n="undefined"!=typeof e.getElementsByTagName?e.getElementsByTagName(t||"*"):"undefined"!=typeof e.querySelectorAll?e.querySelectorAll(t||"*"):[],void 0===t||t&&i(e,t)?ge.merge([e],n):n}function x(e,t){for(var n=0,r=e.length;n<r;n++)Oe.set(e[n],"globalEval",!t||Oe.get(t[n],"globalEval"))}function b(e,t,n,r,i){for(var o,a,s,u,l,c,f=t.createDocumentFragment(),p=[],d=0,h=e.length;d<h;d++)if((o=e[d])||0===o)if("object"===ge.type(o))ge.merge(p,o.nodeType?[o]:o);else if(Ye.test(o)){for(a=a||f.appendChild(t.createElement("div")),s=(Ue.exec(o)||["",""])[1].toLowerCase(),u=Ge[s]||Ge._default,a.innerHTML=u[1]+ge.htmlPrefilter(o)+u[2],c=u[0];c--;)a=a.lastChild;ge.merge(p,a.childNodes),a=f.firstChild,a.textContent=""}else p.push(t.createTextNode(o));for(f.textContent="",d=0;o=p[d++];)if(r&&ge.inArray(o,r)>-1)i&&i.push(o);else if(l=ge.contains(o.ownerDocument,o),a=y(f.appendChild(o),"script"),l&&x(a),n)for(c=0;o=a[c++];)Ve.test(o.type||"")&&n.push(o);return f}function w(){return!0}function T(){return!1}function C(){try{return ne.activeElement}catch(e){}}function E(e,t,n,r,i,o){var a,s;if("object"==typeof t){"string"!=typeof n&&(r=r||n,n=void 0);for(s in t)E(e,s,n,r,t[s],o);return e}if(null==r&&null==i?(i=n,r=n=void 0):null==i&&("string"==typeof n?(i=r,r=void 0):(i=r,r=n,n=void 0)),!1===i)i=T;else if(!i)return e;return 1===o&&(a=i,i=function(e){return ge().off(e),a.apply(this,arguments)},i.guid=a.guid||(a.guid=ge.guid++)),e.each(function(){ge.event.add(this,t,i,r,n)})}function k(e,t){return i(e,"table")&&i(11!==t.nodeType?t:t.firstChild,"tr")?ge(">tbody",e)[0]||e:e}function N(e){return e.type=(null!==e.getAttribute("type"))+"/"+e.type,e}function S(e){var t=rt.exec(e.type);return t?e.type=t[1]:e.removeAttribute("type"),e}function D(e,t){var n,r,i,o,a,s,u,l;if(1===t.nodeType){if(Oe.hasData(e)&&(o=Oe.access(e),a=Oe.set(t,o),l=o.events)){delete a.handle,a.events={};for(i in l)for(n=0,r=l[i].length;n<r;n++)ge.event.add(t,i,l[i][n])}Pe.hasData(e)&&(s=Pe.access(e),u=ge.extend({},s),Pe.set(t,u))}}function j(e,t){var n=t.nodeName.toLowerCase();"input"===n&&Xe.test(e.type)?t.checked=e.checked:"input"!==n&&"textarea"!==n||(t.defaultValue=e.defaultValue)}function A(e,t,r,i){t=oe.apply([],t);var o,a,s,u,l,c,f=0,p=e.length,d=p-1,h=t[0],g=ge.isFunction(h);if(g||p>1&&"string"==typeof h&&!de.checkClone&&nt.test(h))return e.each(function(n){var o=e.eq(n);g&&(t[0]=h.call(this,n,o.html())),A(o,t,r,i)});if(p&&(o=b(t,e[0].ownerDocument,!1,e,i),a=o.firstChild,1===o.childNodes.length&&(o=a),a||i)){for(s=ge.map(y(o,"script"),N),u=s.length;f<p;f++)l=o,f!==d&&(l=ge.clone(l,!0,!0),u&&ge.merge(s,y(l,"script"))),r.call(e[f],l,f);if(u)for(c=s[s.length-1].ownerDocument,ge.map(s,S),f=0;f<u;f++)l=s[f],Ve.test(l.type||"")&&!Oe.access(l,"globalEval")&&ge.contains(c,l)&&(l.src?ge._evalUrl&&ge._evalUrl(l.src):n(l.textContent.replace(it,""),c))}return e}function q(e,t,n){for(var r,i=t?ge.filter(t,e):e,o=0;null!=(r=i[o]);o++)n||1!==r.nodeType||ge.cleanData(y(r)),r.parentNode&&(n&&ge.contains(r.ownerDocument,r)&&x(y(r,"script")),r.parentNode.removeChild(r));return e}function L(e,t,n){var r,i,o,a,s=e.style;return n=n||st(e),n&&(a=n.getPropertyValue(t)||n[t],""!==a||ge.contains(e.ownerDocument,e)||(a=ge.style(e,t)),!de.pixelMarginRight()&&at.test(a)&&ot.test(t)&&(r=s.width,i=s.minWidth,o=s.maxWidth,s.minWidth=s.maxWidth=s.width=a,a=n.width,s.width=r,s.minWidth=i,s.maxWidth=o)),void 0!==a?a+"":a}function H(e,t){return{get:function(){return e()?void delete this.get:(this.get=t).apply(this,arguments)}}}function F(e){if(e in dt)return e;for(var t=e[0].toUpperCase()+e.slice(1),n=pt.length;n--;)if((e=pt[n]+t)in dt)return e}function O(e){var t=ge.cssProps[e];return t||(t=ge.cssProps[e]=F(e)||e),t}function P(e,t,n){var r=We.exec(t);return r?Math.max(0,r[2]-(n||0))+(r[3]||"px"):t}function R(e,t,n,r,i){var o,a=0;for(o=n===(r?"border":"content")?4:"width"===t?1:0;o<4;o+=2)"margin"===n&&(a+=ge.css(e,n+Be[o],!0,i)),r?("content"===n&&(a-=ge.css(e,"padding"+Be[o],!0,i)),"margin"!==n&&(a-=ge.css(e,"border"+Be[o]+"Width",!0,i))):(a+=ge.css(e,"padding"+Be[o],!0,i),"padding"!==n&&(a+=ge.css(e,"border"+Be[o]+"Width",!0,i)));return a}function I(e,t,n){var r,i=st(e),o=L(e,t,i),a="border-box"===ge.css(e,"boxSizing",!1,i);return at.test(o)?o:(r=a&&(de.boxSizingReliable()||o===e.style[t]),"auto"===o&&(o=e["offset"+t[0].toUpperCase()+t.slice(1)]),(o=parseFloat(o)||0)+R(e,t,n||(a?"border":"content"),r,i)+"px")}function M(e,t,n,r,i){return new M.prototype.init(e,t,n,r,i)}function W(){gt&&(!1===ne.hidden&&e.requestAnimationFrame?e.requestAnimationFrame(W):e.setTimeout(W,ge.fx.interval),ge.fx.tick())}function B(){return e.setTimeout(function(){ht=void 0}),ht=ge.now()}function $(e,t){var n,r=0,i={height:e};for(t=t?1:0;r<4;r+=2-t)n=Be[r],i["margin"+n]=i["padding"+n]=e;return t&&(i.opacity=i.width=e),i}function _(e,t,n){for(var r,i=(U.tweeners[t]||[]).concat(U.tweeners["*"]),o=0,a=i.length;o<a;o++)if(r=i[o].call(n,t,e))return r}function z(e,t,n){var r,i,o,a,s,u,l,c,f="width"in t||"height"in t,p=this,d={},h=e.style,g=e.nodeType&&$e(e),m=Oe.get(e,"fxshow");n.queue||(a=ge._queueHooks(e,"fx"),null==a.unqueued&&(a.unqueued=0,s=a.empty.fire,a.empty.fire=function(){a.unqueued||s()}),a.unqueued++,p.always(function(){p.always(function(){a.unqueued--,ge.queue(e,"fx").length||a.empty.fire()})}));for(r in t)if(i=t[r],mt.test(i)){if(delete t[r],o=o||"toggle"===i,i===(g?"hide":"show")){if("show"!==i||!m||void 0===m[r])continue;g=!0}d[r]=m&&m[r]||ge.style(e,r)}if((u=!ge.isEmptyObject(t))||!ge.isEmptyObject(d)){f&&1===e.nodeType&&(n.overflow=[h.overflow,h.overflowX,h.overflowY],l=m&&m.display,null==l&&(l=Oe.get(e,"display")),c=ge.css(e,"display"),"none"===c&&(l?c=l:(v([e],!0),l=e.style.display||l,c=ge.css(e,"display"),v([e]))),("inline"===c||"inline-block"===c&&null!=l)&&"none"===ge.css(e,"float")&&(u||(p.done(function(){h.display=l}),null==l&&(c=h.display,l="none"===c?"":c)),h.display="inline-block")),n.overflow&&(h.overflow="hidden",p.always(function(){h.overflow=n.overflow[0],h.overflowX=n.overflow[1],h.overflowY=n.overflow[2]})),u=!1;for(r in d)u||(m?"hidden"in m&&(g=m.hidden):m=Oe.access(e,"fxshow",{display:l}),o&&(m.hidden=!g),g&&v([e],!0),p.done(function(){g||v([e]),Oe.remove(e,"fxshow");for(r in d)ge.style(e,r,d[r])})),u=_(g?m[r]:0,r,p),r in m||(m[r]=u.start,g&&(u.end=u.start,u.start=0))}}function X(e,t){var n,r,i,o,a;for(n in e)if(r=ge.camelCase(n),i=t[r],o=e[n],Array.isArray(o)&&(i=o[1],o=e[n]=o[0]),n!==r&&(e[r]=o,delete e[n]),(a=ge.cssHooks[r])&&"expand"in a){o=a.expand(o),delete e[r];for(n in o)n in e||(e[n]=o[n],t[n]=i)}else t[r]=i}function U(e,t,n){var r,i,o=0,a=U.prefilters.length,s=ge.Deferred().always(function(){delete u.elem}),u=function(){if(i)return!1;for(var t=ht||B(),n=Math.max(0,l.startTime+l.duration-t),r=n/l.duration||0,o=1-r,a=0,u=l.tweens.length;a<u;a++)l.tweens[a].run(o);return s.notifyWith(e,[l,o,n]),o<1&&u?n:(u||s.notifyWith(e,[l,1,0]),s.resolveWith(e,[l]),!1)},l=s.promise({elem:e,props:ge.extend({},t),opts:ge.extend(!0,{specialEasing:{},easing:ge.easing._default},n),originalProperties:t,originalOptions:n,startTime:ht||B(),duration:n.duration,tweens:[],createTween:function(t,n){var r=ge.Tween(e,l.opts,t,n,l.opts.specialEasing[t]||l.opts.easing);return l.tweens.push(r),r},stop:function(t){var n=0,r=t?l.tweens.length:0;if(i)return this;for(i=!0;n<r;n++)l.tweens[n].run(1);return t?(s.notifyWith(e,[l,1,0]),s.resolveWith(e,[l,t])):s.rejectWith(e,[l,t]),this}}),c=l.props;for(X(c,l.opts.specialEasing);o<a;o++)if(r=U.prefilters[o].call(l,e,c,l.opts))return ge.isFunction(r.stop)&&(ge._queueHooks(l.elem,l.opts.queue).stop=ge.proxy(r.stop,r)),r;return ge.map(c,_,l),ge.isFunction(l.opts.start)&&l.opts.start.call(e,l),l.progress(l.opts.progress).done(l.opts.done,l.opts.complete).fail(l.opts.fail).always(l.opts.always),ge.fx.timer(ge.extend(u,{elem:e,anim:l,queue:l.opts.queue})),l}function V(e){return(e.match(Ae)||[]).join(" ")}function G(e){return e.getAttribute&&e.getAttribute("class")||""}function Y(e,t,n,r){var i;if(Array.isArray(t))ge.each(t,function(t,i){n||St.test(e)?r(e,i):Y(e+"["+("object"==typeof i&&null!=i?t:"")+"]",i,n,r)});else if(n||"object"!==ge.type(t))r(e,t);else for(i in t)Y(e+"["+i+"]",t[i],n,r)}function Q(e){return function(t,n){"string"!=typeof t&&(n=t,t="*");var r,i=0,o=t.toLowerCase().match(Ae)||[];if(ge.isFunction(n))for(;r=o[i++];)"+"===r[0]?(r=r.slice(1)||"*",(e[r]=e[r]||[]).unshift(n)):(e[r]=e[r]||[]).push(n)}}function J(e,t,n,r){function i(s){var u;return o[s]=!0,ge.each(e[s]||[],function(e,s){var l=s(t,n,r);return"string"!=typeof l||a||o[l]?a?!(u=l):void 0:(t.dataTypes.unshift(l),i(l),!1)}),u}var o={},a=e===Mt;return i(t.dataTypes[0])||!o["*"]&&i("*")}function K(e,t){var n,r,i=ge.ajaxSettings.flatOptions||{};for(n in t)void 0!==t[n]&&((i[n]?e:r||(r={}))[n]=t[n]);return r&&ge.extend(!0,e,r),e}function Z(e,t,n){for(var r,i,o,a,s=e.contents,u=e.dataTypes;"*"===u[0];)u.shift(),void 0===r&&(r=e.mimeType||t.getResponseHeader("Content-Type"));if(r)for(i in s)if(s[i]&&s[i].test(r)){u.unshift(i);break}if(u[0]in n)o=u[0];else{for(i in n){if(!u[0]||e.converters[i+" "+u[0]]){o=i;break}a||(a=i)}o=o||a}if(o)return o!==u[0]&&u.unshift(o),n[o]}function ee(e,t,n,r){var i,o,a,s,u,l={},c=e.dataTypes.slice();if(c[1])for(a in e.converters)l[a.toLowerCase()]=e.converters[a];for(o=c.shift();o;)if(e.responseFields[o]&&(n[e.responseFields[o]]=t),!u&&r&&e.dataFilter&&(t=e.dataFilter(t,e.dataType)),u=o,o=c.shift())if("*"===o)o=u;else if("*"!==u&&u!==o){if(!(a=l[u+" "+o]||l["* "+o]))for(i in l)if(s=i.split(" "),s[1]===o&&(a=l[u+" "+s[0]]||l["* "+s[0]])){!0===a?a=l[i]:!0!==l[i]&&(o=s[0],c.unshift(s[1]));break}if(!0!==a)if(a&&e["throws"])t=a(t);else try{t=a(t)}catch(e){return{state:"parsererror",error:a?e:"No conversion from "+u+" to "+o}}}return{state:"success",data:t}}var te=[],ne=e.document,re=Object.getPrototypeOf,ie=te.slice,oe=te.concat,ae=te.push,se=te.indexOf,ue={},le=ue.toString,ce=ue.hasOwnProperty,fe=ce.toString,pe=fe.call(Object),de={},he="3.2.1",ge=function(e,t){return new ge.fn.init(e,t)},me=/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g,ve=/^-ms-/,ye=/-([a-z])/g,xe=function(e,t){return t.toUpperCase()};ge.fn=ge.prototype={jquery:he,constructor:ge,length:0,toArray:function(){return ie.call(this)},get:function(e){return null==e?ie.call(this):e<0?this[e+this.length]:this[e]},pushStack:function(e){var t=ge.merge(this.constructor(),e);return t.prevObject=this,t},each:function(e){return ge.each(this,e)},map:function(e){return this.pushStack(ge.map(this,function(t,n){return e.call(t,n,t)}))},slice:function(){return this.pushStack(ie.apply(this,arguments))},first:function(){return this.eq(0)},last:function(){return this.eq(-1)},eq:function(e){var t=this.length,n=+e+(e<0?t:0);return this.pushStack(n>=0&&n<t?[this[n]]:[])},end:function(){return this.prevObject||this.constructor()},push:ae,sort:te.sort,splice:te.splice},ge.extend=ge.fn.extend=function(){var e,t,n,r,i,o,a=arguments[0]||{},s=1,u=arguments.length,l=!1;for("boolean"==typeof a&&(l=a,a=arguments[s]||{},s++),"object"==typeof a||ge.isFunction(a)||(a={}),s===u&&(a=this,s--);s<u;s++)if(null!=(e=arguments[s]))for(t in e)n=a[t],r=e[t],a!==r&&(l&&r&&(ge.isPlainObject(r)||(i=Array.isArray(r)))?(i?(i=!1,o=n&&Array.isArray(n)?n:[]):o=n&&ge.isPlainObject(n)?n:{},a[t]=ge.extend(l,o,r)):void 0!==r&&(a[t]=r));return a},ge.extend({expando:"jQuery"+(he+Math.random()).replace(/\D/g,""),isReady:!0,error:function(e){throw new Error(e)},noop:function(){},isFunction:function(e){return"function"===ge.type(e)},isWindow:function(e){return null!=e&&e===e.window},isNumeric:function(e){var t=ge.type(e);return("number"===t||"string"===t)&&!isNaN(e-parseFloat(e))},isPlainObject:function(e){var t,n;return!(!e||"[object Object]"!==le.call(e)||(t=re(e))&&("function"!=typeof(n=ce.call(t,"constructor")&&t.constructor)||fe.call(n)!==pe))},isEmptyObject:function(e){var t;for(t in e)return!1;return!0},type:function(e){return null==e?e+"":"object"==typeof e||"function"==typeof e?ue[le.call(e)]||"object":typeof e},globalEval:function(e){n(e)},camelCase:function(e){return e.replace(ve,"ms-").replace(ye,xe)},each:function(e,t){var n,i=0;if(r(e))for(n=e.length;i<n&&!1!==t.call(e[i],i,e[i]);i++);else for(i in e)if(!1===t.call(e[i],i,e[i]))break;return e},trim:function(e){return null==e?"":(e+"").replace(me,"")},makeArray:function(e,t){var n=t||[];return null!=e&&(r(Object(e))?ge.merge(n,"string"==typeof e?[e]:e):ae.call(n,e)),n},inArray:function(e,t,n){return null==t?-1:se.call(t,e,n)},merge:function(e,t){for(var n=+t.length,r=0,i=e.length;r<n;r++)e[i++]=t[r];return e.length=i,e},grep:function(e,t,n){for(var r=[],i=0,o=e.length,a=!n;i<o;i++)!t(e[i],i)!==a&&r.push(e[i]);return r},map:function(e,t,n){var i,o,a=0,s=[];if(r(e))for(i=e.length;a<i;a++)null!=(o=t(e[a],a,n))&&s.push(o);else for(a in e)null!=(o=t(e[a],a,n))&&s.push(o);return oe.apply([],s)},guid:1,proxy:function(e,t){var n,r,i;if("string"==typeof t&&(n=e[t],t=e,e=n),ge.isFunction(e))return r=ie.call(arguments,2),i=function(){return e.apply(t||this,r.concat(ie.call(arguments)))},i.guid=e.guid=e.guid||ge.guid++,i},now:Date.now,support:de}),"function"==typeof Symbol&&(ge.fn[Symbol.iterator]=te[Symbol.iterator]),ge.each("Boolean Number String Function Array Date RegExp Object Error Symbol".split(" "),function(e,t){ue["[object "+t+"]"]=t.toLowerCase()});var be=function(e){function t(e,t,n,r){var i,o,a,s,u,l,c,p=t&&t.ownerDocument,h=t?t.nodeType:9;if(n=n||[],"string"!=typeof e||!e||1!==h&&9!==h&&11!==h)return n;if(!r&&((t?t.ownerDocument||t:B)!==H&&L(t),t=t||H,O)){if(11!==h&&(u=ve.exec(e)))if(i=u[1]){if(9===h){if(!(a=t.getElementById(i)))return n;if(a.id===i)return n.push(a),n}else if(p&&(a=p.getElementById(i))&&M(t,a)&&a.id===i)return n.push(a),n}else{if(u[2])return K.apply(n,t.getElementsByTagName(e)),n;if((i=u[3])&&T.getElementsByClassName&&t.getElementsByClassName)return K.apply(n,t.getElementsByClassName(i)),n}if(T.qsa&&!U[e+" "]&&(!P||!P.test(e))){if(1!==h)p=t,c=e;else if("object"!==t.nodeName.toLowerCase()){for((s=t.getAttribute("id"))?s=s.replace(we,Te):t.setAttribute("id",s=W),l=N(e),o=l.length;o--;)l[o]="#"+s+" "+d(l[o]);c=l.join(","),p=ye.test(e)&&f(t.parentNode)||t}if(c)try{return K.apply(n,p.querySelectorAll(c)),n}catch(e){}finally{s===W&&t.removeAttribute("id")}}}return D(e.replace(se,"$1"),t,n,r)}function n(){function e(n,r){return t.push(n+" ")>C.cacheLength&&delete e[t.shift()],e[n+" "]=r}var t=[];return e}function r(e){return e[W]=!0,e}function i(e){var t=H.createElement("fieldset");try{return!!e(t)}catch(e){return!1}finally{t.parentNode&&t.parentNode.removeChild(t),t=null}}function o(e,t){for(var n=e.split("|"),r=n.length;r--;)C.attrHandle[n[r]]=t}function a(e,t){var n=t&&e,r=n&&1===e.nodeType&&1===t.nodeType&&e.sourceIndex-t.sourceIndex;if(r)return r;if(n)for(;n=n.nextSibling;)if(n===t)return-1;return e?1:-1}function s(e){return function(t){return"input"===t.nodeName.toLowerCase()&&t.type===e}}function u(e){return function(t){var n=t.nodeName.toLowerCase();return("input"===n||"button"===n)&&t.type===e}}function l(e){return function(t){return"form"in t?t.parentNode&&!1===t.disabled?"label"in t?"label"in t.parentNode?t.parentNode.disabled===e:t.disabled===e:t.isDisabled===e||t.isDisabled!==!e&&Ee(t)===e:t.disabled===e:"label"in t&&t.disabled===e}}function c(e){return r(function(t){return t=+t,r(function(n,r){for(var i,o=e([],n.length,t),a=o.length;a--;)n[i=o[a]]&&(n[i]=!(r[i]=n[i]))})})}function f(e){return e&&"undefined"!=typeof e.getElementsByTagName&&e}function p(){}function d(e){for(var t=0,n=e.length,r="";t<n;t++)r+=e[t].value;return r}function h(e,t,n){var r=t.dir,i=t.next,o=i||r,a=n&&"parentNode"===o,s=_++;return t.first?function(t,n,i){for(;t=t[r];)if(1===t.nodeType||a)return e(t,n,i);return!1}:function(t,n,u){var l,c,f,p=[$,s];if(u){for(;t=t[r];)if((1===t.nodeType||a)&&e(t,n,u))return!0}else for(;t=t[r];)if(1===t.nodeType||a)if(f=t[W]||(t[W]={}),c=f[t.uniqueID]||(f[t.uniqueID]={}),i&&i===t.nodeName.toLowerCase())t=t[r]||t;else{if((l=c[o])&&l[0]===$&&l[1]===s)return p[2]=l[2];if(c[o]=p,p[2]=e(t,n,u))return!0}return!1}}function g(e){return e.length>1?function(t,n,r){for(var i=e.length;i--;)if(!e[i](t,n,r))return!1;return!0}:e[0]}function m(e,n,r){for(var i=0,o=n.length;i<o;i++)t(e,n[i],r);return r}function v(e,t,n,r,i){for(var o,a=[],s=0,u=e.length,l=null!=t;s<u;s++)(o=e[s])&&(n&&!n(o,r,i)||(a.push(o),l&&t.push(s)));return a}function y(e,t,n,i,o,a){return i&&!i[W]&&(i=y(i)),o&&!o[W]&&(o=y(o,a)),r(function(r,a,s,u){var l,c,f,p=[],d=[],h=a.length,g=r||m(t||"*",s.nodeType?[s]:s,[]),y=!e||!r&&t?g:v(g,p,e,s,u),x=n?o||(r?e:h||i)?[]:a:y;if(n&&n(y,x,s,u),i)for(l=v(x,d),i(l,[],s,u),c=l.length;c--;)(f=l[c])&&(x[d[c]]=!(y[d[c]]=f));if(r){if(o||e){if(o){for(l=[],c=x.length;c--;)(f=x[c])&&l.push(y[c]=f);o(null,x=[],l,u)}for(c=x.length;c--;)(f=x[c])&&(l=o?ee(r,f):p[c])>-1&&(r[l]=!(a[l]=f))}}else x=v(x===a?x.splice(h,x.length):x),o?o(null,a,x,u):K.apply(a,x)})}function x(e){for(var t,n,r,i=e.length,o=C.relative[e[0].type],a=o||C.relative[" "],s=o?1:0,u=h(function(e){return e===t},a,!0),l=h(function(e){return ee(t,e)>-1},a,!0),c=[function(e,n,r){var i=!o&&(r||n!==j)||((t=n).nodeType?u(e,n,r):l(e,n,r));return t=null,i}];s<i;s++)if(n=C.relative[e[s].type])c=[h(g(c),n)];else{if(n=C.filter[e[s].type].apply(null,e[s].matches),n[W]){for(r=++s;r<i&&!C.relative[e[r].type];r++);return y(s>1&&g(c),s>1&&d(e.slice(0,s-1).concat({value:" "===e[s-2].type?"*":""})).replace(se,"$1"),n,s<r&&x(e.slice(s,r)),r<i&&x(e=e.slice(r)),r<i&&d(e))}c.push(n)}return g(c)}function b(e,n){var i=n.length>0,o=e.length>0,a=function(r,a,s,u,l){var c,f,p,d=0,h="0",g=r&&[],m=[],y=j,x=r||o&&C.find.TAG("*",l),b=$+=null==y?1:Math.random()||.1,w=x.length;for(l&&(j=a===H||a||l);h!==w&&null!=(c=x[h]);h++){if(o&&c){for(f=0,a||c.ownerDocument===H||(L(c),s=!O);p=e[f++];)if(p(c,a||H,s)){u.push(c);break}l&&($=b)}i&&((c=!p&&c)&&d--,r&&g.push(c))}if(d+=h,i&&h!==d){for(f=0;p=n[f++];)p(g,m,a,s);if(r){if(d>0)for(;h--;)g[h]||m[h]||(m[h]=Q.call(u));m=v(m)}K.apply(u,m),l&&!r&&m.length>0&&d+n.length>1&&t.uniqueSort(u)}return l&&($=b,j=y),g};return i?r(a):a}var w,T,C,E,k,N,S,D,j,A,q,L,H,F,O,P,R,I,M,W="sizzle"+1*new Date,B=e.document,$=0,_=0,z=n(),X=n(),U=n(),V=function(e,t){return e===t&&(q=!0),0},G={}.hasOwnProperty,Y=[],Q=Y.pop,J=Y.push,K=Y.push,Z=Y.slice,ee=function(e,t){for(var n=0,r=e.length;n<r;n++)if(e[n]===t)return n;return-1},te="checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|ismap|loop|multiple|open|readonly|required|scoped",ne="[\\x20\\t\\r\\n\\f]",re="(?:\\\\.|[\\w-]|[^\0-\\xa0])+",ie="\\["+ne+"*("+re+")(?:"+ne+"*([*^$|!~]?=)"+ne+"*(?:'((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\"|("+re+"))|)"+ne+"*\\]",oe=":("+re+")(?:\\((('((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\")|((?:\\\\.|[^\\\\()[\\]]|"+ie+")*)|.*)\\)|)",ae=new RegExp(ne+"+","g"),se=new RegExp("^"+ne+"+|((?:^|[^\\\\])(?:\\\\.)*)"+ne+"+$","g"),ue=new RegExp("^"+ne+"*,"+ne+"*"),le=new RegExp("^"+ne+"*([>+~]|"+ne+")"+ne+"*"),ce=new RegExp("="+ne+"*([^\\]'\"]*?)"+ne+"*\\]","g"),fe=new RegExp(oe),pe=new RegExp("^"+re+"$"),de={ID:new RegExp("^#("+re+")"),CLASS:new RegExp("^\\.("+re+")"),TAG:new RegExp("^("+re+"|[*])"),ATTR:new RegExp("^"+ie),PSEUDO:new RegExp("^"+oe),CHILD:new RegExp("^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\("+ne+"*(even|odd|(([+-]|)(\\d*)n|)"+ne+"*(?:([+-]|)"+ne+"*(\\d+)|))"+ne+"*\\)|)","i"),bool:new RegExp("^(?:"+te+")$","i"),needsContext:new RegExp("^"+ne+"*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\("+ne+"*((?:-\\d)?\\d*)"+ne+"*\\)|)(?=[^-]|$)","i")},he=/^(?:input|select|textarea|button)$/i,ge=/^h\d$/i,me=/^[^{]+\{\s*\[native \w/,ve=/^(?:#([\w-]+)|(\w+)|\.([\w-]+))$/,ye=/[+~]/,xe=new RegExp("\\\\([\\da-f]{1,6}"+ne+"?|("+ne+")|.)","ig"),be=function(e,t,n){var r="0x"+t-65536;return r!==r||n?t:r<0?String.fromCharCode(r+65536):String.fromCharCode(r>>10|55296,1023&r|56320)},we=/([\0-\x1f\x7f]|^-?\d)|^-$|[^\0-\x1f\x7f-\uFFFF\w-]/g,Te=function(e,t){return t?"\0"===e?"\ufffd":e.slice(0,-1)+"\\"+e.charCodeAt(e.length-1).toString(16)+" ":"\\"+e},Ce=function(){L()},Ee=h(function(e){return!0===e.disabled&&("form"in e||"label"in e)},{dir:"parentNode",next:"legend"});try{K.apply(Y=Z.call(B.childNodes),B.childNodes),Y[B.childNodes.length].nodeType}catch(e){K={apply:Y.length?function(e,t){J.apply(e,Z.call(t))}:function(e,t){for(var n=e.length,r=0;e[n++]=t[r++];);e.length=n-1}}}T=t.support={},k=t.isXML=function(e){var t=e&&(e.ownerDocument||e).documentElement;return!!t&&"HTML"!==t.nodeName},L=t.setDocument=function(e){var t,n,r=e?e.ownerDocument||e:B;return r!==H&&9===r.nodeType&&r.documentElement?(H=r,F=H.documentElement,O=!k(H),B!==H&&(n=H.defaultView)&&n.top!==n&&(n.addEventListener?n.addEventListener("unload",Ce,!1):n.attachEvent&&n.attachEvent("onunload",Ce)),T.attributes=i(function(e){return e.className="i",!e.getAttribute("className")}),T.getElementsByTagName=i(function(e){return e.appendChild(H.createComment("")),!e.getElementsByTagName("*").length}),T.getElementsByClassName=me.test(H.getElementsByClassName),T.getById=i(function(e){return F.appendChild(e).id=W,!H.getElementsByName||!H.getElementsByName(W).length}),T.getById?(C.filter.ID=function(e){var t=e.replace(xe,be);return function(e){return e.getAttribute("id")===t}},C.find.ID=function(e,t){if("undefined"!=typeof t.getElementById&&O){var n=t.getElementById(e);return n?[n]:[]}}):(C.filter.ID=function(e){var t=e.replace(xe,be);return function(e){var n="undefined"!=typeof e.getAttributeNode&&e.getAttributeNode("id");return n&&n.value===t}},C.find.ID=function(e,t){if("undefined"!=typeof t.getElementById&&O){var n,r,i,o=t.getElementById(e);if(o){if((n=o.getAttributeNode("id"))&&n.value===e)return[o];for(i=t.getElementsByName(e),r=0;o=i[r++];)if((n=o.getAttributeNode("id"))&&n.value===e)return[o]}return[]}}),C.find.TAG=T.getElementsByTagName?function(e,t){return"undefined"!=typeof t.getElementsByTagName?t.getElementsByTagName(e):T.qsa?t.querySelectorAll(e):void 0}:function(e,t){var n,r=[],i=0,o=t.getElementsByTagName(e);if("*"===e){for(;n=o[i++];)1===n.nodeType&&r.push(n);return r}return o},C.find.CLASS=T.getElementsByClassName&&function(e,t){if("undefined"!=typeof t.getElementsByClassName&&O)return t.getElementsByClassName(e)},R=[],P=[],(T.qsa=me.test(H.querySelectorAll))&&(i(function(e){F.appendChild(e).innerHTML="<a id='"+W+"'></a><select id='"+W+"-\r\\' msallowcapture=''><option selected=''></option></select>",e.querySelectorAll("[msallowcapture^='']").length&&P.push("[*^$]="+ne+"*(?:''|\"\")"),e.querySelectorAll("[selected]").length||P.push("\\["+ne+"*(?:value|"+te+")"),e.querySelectorAll("[id~="+W+"-]").length||P.push("~="),e.querySelectorAll(":checked").length||P.push(":checked"),e.querySelectorAll("a#"+W+"+*").length||P.push(".#.+[+~]")}),i(function(e){e.innerHTML="<a href='' disabled='disabled'></a><select disabled='disabled'><option/></select>";var t=H.createElement("input");t.setAttribute("type","hidden"),e.appendChild(t).setAttribute("name","D"),e.querySelectorAll("[name=d]").length&&P.push("name"+ne+"*[*^$|!~]?="),2!==e.querySelectorAll(":enabled").length&&P.push(":enabled",":disabled"),F.appendChild(e).disabled=!0,2!==e.querySelectorAll(":disabled").length&&P.push(":enabled",":disabled"),e.querySelectorAll("*,:x"),P.push(",.*:")})),(T.matchesSelector=me.test(I=F.matches||F.webkitMatchesSelector||F.mozMatchesSelector||F.oMatchesSelector||F.msMatchesSelector))&&i(function(e){T.disconnectedMatch=I.call(e,"*"),I.call(e,"[s!='']:x"),R.push("!=",oe)}),P=P.length&&new RegExp(P.join("|")),R=R.length&&new RegExp(R.join("|")),t=me.test(F.compareDocumentPosition),M=t||me.test(F.contains)?function(e,t){var n=9===e.nodeType?e.documentElement:e,r=t&&t.parentNode;return e===r||!(!r||1!==r.nodeType||!(n.contains?n.contains(r):e.compareDocumentPosition&&16&e.compareDocumentPosition(r)))}:function(e,t){if(t)for(;t=t.parentNode;)if(t===e)return!0;return!1},V=t?function(e,t){if(e===t)return q=!0,0;var n=!e.compareDocumentPosition-!t.compareDocumentPosition;return n||(n=(e.ownerDocument||e)===(t.ownerDocument||t)?e.compareDocumentPosition(t):1,1&n||!T.sortDetached&&t.compareDocumentPosition(e)===n?e===H||e.ownerDocument===B&&M(B,e)?-1:t===H||t.ownerDocument===B&&M(B,t)?1:A?ee(A,e)-ee(A,t):0:4&n?-1:1)}:function(e,t){if(e===t)return q=!0,0;var n,r=0,i=e.parentNode,o=t.parentNode,s=[e],u=[t];if(!i||!o)return e===H?-1:t===H?1:i?-1:o?1:A?ee(A,e)-ee(A,t):0;if(i===o)return a(e,t);for(n=e;n=n.parentNode;)s.unshift(n);for(n=t;n=n.parentNode;)u.unshift(n);for(;s[r]===u[r];)r++;return r?a(s[r],u[r]):s[r]===B?-1:u[r]===B?1:0},H):H},t.matches=function(e,n){return t(e,null,null,n)},t.matchesSelector=function(e,n){if((e.ownerDocument||e)!==H&&L(e),n=n.replace(ce,"='$1']"),T.matchesSelector&&O&&!U[n+" "]&&(!R||!R.test(n))&&(!P||!P.test(n)))try{var r=I.call(e,n);if(r||T.disconnectedMatch||e.document&&11!==e.document.nodeType)return r}catch(e){}return t(n,H,null,[e]).length>0},t.contains=function(e,t){return(e.ownerDocument||e)!==H&&L(e),M(e,t)},t.attr=function(e,t){(e.ownerDocument||e)!==H&&L(e);var n=C.attrHandle[t.toLowerCase()],r=n&&G.call(C.attrHandle,t.toLowerCase())?n(e,t,!O):void 0;return void 0!==r?r:T.attributes||!O?e.getAttribute(t):(r=e.getAttributeNode(t))&&r.specified?r.value:null},t.escape=function(e){return(e+"").replace(we,Te)},t.error=function(e){throw new Error("Syntax error, unrecognized expression: "+e)},t.uniqueSort=function(e){var t,n=[],r=0,i=0;if(q=!T.detectDuplicates,A=!T.sortStable&&e.slice(0),e.sort(V),q){for(;t=e[i++];)t===e[i]&&(r=n.push(i));for(;r--;)e.splice(n[r],1)}return A=null,e},E=t.getText=function(e){var t,n="",r=0,i=e.nodeType;if(i){if(1===i||9===i||11===i){if("string"==typeof e.textContent)return e.textContent;for(e=e.firstChild;e;e=e.nextSibling)n+=E(e)}else if(3===i||4===i)return e.nodeValue}else for(;t=e[r++];)n+=E(t);return n},C=t.selectors={cacheLength:50,createPseudo:r,match:de,attrHandle:{},find:{},relative:{">":{dir:"parentNode",first:!0}," ":{dir:"parentNode"},"+":{dir:"previousSibling",first:!0},"~":{dir:"previousSibling"}},preFilter:{ATTR:function(e){return e[1]=e[1].replace(xe,be),e[3]=(e[3]||e[4]||e[5]||"").replace(xe,be),"~="===e[2]&&(e[3]=" "+e[3]+" "),e.slice(0,4)},CHILD:function(e){return e[1]=e[1].toLowerCase(),"nth"===e[1].slice(0,3)?(e[3]||t.error(e[0]),e[4]=+(e[4]?e[5]+(e[6]||1):2*("even"===e[3]||"odd"===e[3])),e[5]=+(e[7]+e[8]||"odd"===e[3])):e[3]&&t.error(e[0]),e},PSEUDO:function(e){var t,n=!e[6]&&e[2];return de.CHILD.test(e[0])?null:(e[3]?e[2]=e[4]||e[5]||"":n&&fe.test(n)&&(t=N(n,!0))&&(t=n.indexOf(")",n.length-t)-n.length)&&(e[0]=e[0].slice(0,t),e[2]=n.slice(0,t)),e.slice(0,3))}},filter:{TAG:function(e){var t=e.replace(xe,be).toLowerCase();return"*"===e?function(){return!0}:function(e){return e.nodeName&&e.nodeName.toLowerCase()===t}},CLASS:function(e){var t=z[e+" "];return t||(t=new RegExp("(^|"+ne+")"+e+"("+ne+"|$)"))&&z(e,function(e){return t.test("string"==typeof e.className&&e.className||"undefined"!=typeof e.getAttribute&&e.getAttribute("class")||"")})},ATTR:function(e,n,r){return function(i){var o=t.attr(i,e);return null==o?"!="===n:!n||(o+="","="===n?o===r:"!="===n?o!==r:"^="===n?r&&0===o.indexOf(r):"*="===n?r&&o.indexOf(r)>-1:"$="===n?r&&o.slice(-r.length)===r:"~="===n?(" "+o.replace(ae," ")+" ").indexOf(r)>-1:"|="===n&&(o===r||o.slice(0,r.length+1)===r+"-"))}},CHILD:function(e,t,n,r,i){var o="nth"!==e.slice(0,3),a="last"!==e.slice(-4),s="of-type"===t;return 1===r&&0===i?function(e){return!!e.parentNode}:function(t,n,u){var l,c,f,p,d,h,g=o!==a?"nextSibling":"previousSibling",m=t.parentNode,v=s&&t.nodeName.toLowerCase(),y=!u&&!s,x=!1;if(m){if(o){for(;g;){for(p=t;p=p[g];)if(s?p.nodeName.toLowerCase()===v:1===p.nodeType)return!1;h=g="only"===e&&!h&&"nextSibling"}return!0}if(h=[a?m.firstChild:m.lastChild],a&&y){for(p=m,f=p[W]||(p[W]={}),c=f[p.uniqueID]||(f[p.uniqueID]={}),l=c[e]||[],d=l[0]===$&&l[1],x=d&&l[2],p=d&&m.childNodes[d];p=++d&&p&&p[g]||(x=d=0)||h.pop();)if(1===p.nodeType&&++x&&p===t){c[e]=[$,d,x];break}}else if(y&&(p=t,f=p[W]||(p[W]={}),c=f[p.uniqueID]||(f[p.uniqueID]={}),l=c[e]||[],d=l[0]===$&&l[1],x=d),!1===x)for(;(p=++d&&p&&p[g]||(x=d=0)||h.pop())&&((s?p.nodeName.toLowerCase()!==v:1!==p.nodeType)||!++x||(y&&(f=p[W]||(p[W]={}),c=f[p.uniqueID]||(f[p.uniqueID]={}),c[e]=[$,x]),p!==t)););return(x-=i)===r||x%r==0&&x/r>=0}}},PSEUDO:function(e,n){var i,o=C.pseudos[e]||C.setFilters[e.toLowerCase()]||t.error("unsupported pseudo: "+e);return o[W]?o(n):o.length>1?(i=[e,e,"",n],C.setFilters.hasOwnProperty(e.toLowerCase())?r(function(e,t){for(var r,i=o(e,n),a=i.length;a--;)r=ee(e,i[a]),e[r]=!(t[r]=i[a])}):function(e){return o(e,0,i)}):o}},pseudos:{not:r(function(e){var t=[],n=[],i=S(e.replace(se,"$1"));return i[W]?r(function(e,t,n,r){for(var o,a=i(e,null,r,[]),s=e.length;s--;)(o=a[s])&&(e[s]=!(t[s]=o))}):function(e,r,o){return t[0]=e,i(t,null,o,n),t[0]=null,!n.pop()}}),has:r(function(e){return function(n){return t(e,n).length>0}}),contains:r(function(e){return e=e.replace(xe,be),function(t){return(t.textContent||t.innerText||E(t)).indexOf(e)>-1}}),lang:r(function(e){return pe.test(e||"")||t.error("unsupported lang: "+e),e=e.replace(xe,be).toLowerCase(),function(t){var n;do{if(n=O?t.lang:t.getAttribute("xml:lang")||t.getAttribute("lang"))return(n=n.toLowerCase())===e||0===n.indexOf(e+"-")}while((t=t.parentNode)&&1===t.nodeType);return!1}}),
target:function(t){var n=e.location&&e.location.hash;return n&&n.slice(1)===t.id},root:function(e){return e===F},focus:function(e){return e===H.activeElement&&(!H.hasFocus||H.hasFocus())&&!!(e.type||e.href||~e.tabIndex)},enabled:l(!1),disabled:l(!0),checked:function(e){var t=e.nodeName.toLowerCase();return"input"===t&&!!e.checked||"option"===t&&!!e.selected},selected:function(e){return e.parentNode&&e.parentNode.selectedIndex,!0===e.selected},empty:function(e){for(e=e.firstChild;e;e=e.nextSibling)if(e.nodeType<6)return!1;return!0},parent:function(e){return!C.pseudos.empty(e)},header:function(e){return ge.test(e.nodeName)},input:function(e){return he.test(e.nodeName)},button:function(e){var t=e.nodeName.toLowerCase();return"input"===t&&"button"===e.type||"button"===t},text:function(e){var t;return"input"===e.nodeName.toLowerCase()&&"text"===e.type&&(null==(t=e.getAttribute("type"))||"text"===t.toLowerCase())},first:c(function(){return[0]}),last:c(function(e,t){return[t-1]}),eq:c(function(e,t,n){return[n<0?n+t:n]}),even:c(function(e,t){for(var n=0;n<t;n+=2)e.push(n);return e}),odd:c(function(e,t){for(var n=1;n<t;n+=2)e.push(n);return e}),lt:c(function(e,t,n){for(var r=n<0?n+t:n;--r>=0;)e.push(r);return e}),gt:c(function(e,t,n){for(var r=n<0?n+t:n;++r<t;)e.push(r);return e})}},C.pseudos.nth=C.pseudos.eq;for(w in{radio:!0,checkbox:!0,file:!0,password:!0,image:!0})C.pseudos[w]=s(w);for(w in{submit:!0,reset:!0})C.pseudos[w]=u(w);return p.prototype=C.filters=C.pseudos,C.setFilters=new p,N=t.tokenize=function(e,n){var r,i,o,a,s,u,l,c=X[e+" "];if(c)return n?0:c.slice(0);for(s=e,u=[],l=C.preFilter;s;){r&&!(i=ue.exec(s))||(i&&(s=s.slice(i[0].length)||s),u.push(o=[])),r=!1,(i=le.exec(s))&&(r=i.shift(),o.push({value:r,type:i[0].replace(se," ")}),s=s.slice(r.length));for(a in C.filter)!(i=de[a].exec(s))||l[a]&&!(i=l[a](i))||(r=i.shift(),o.push({value:r,type:a,matches:i}),s=s.slice(r.length));if(!r)break}return n?s.length:s?t.error(e):X(e,u).slice(0)},S=t.compile=function(e,t){var n,r=[],i=[],o=U[e+" "];if(!o){for(t||(t=N(e)),n=t.length;n--;)o=x(t[n]),o[W]?r.push(o):i.push(o);o=U(e,b(i,r)),o.selector=e}return o},D=t.select=function(e,t,n,r){var i,o,a,s,u,l="function"==typeof e&&e,c=!r&&N(e=l.selector||e);if(n=n||[],1===c.length){if(o=c[0]=c[0].slice(0),o.length>2&&"ID"===(a=o[0]).type&&9===t.nodeType&&O&&C.relative[o[1].type]){if(!(t=(C.find.ID(a.matches[0].replace(xe,be),t)||[])[0]))return n;l&&(t=t.parentNode),e=e.slice(o.shift().value.length)}for(i=de.needsContext.test(e)?0:o.length;i--&&(a=o[i],!C.relative[s=a.type]);)if((u=C.find[s])&&(r=u(a.matches[0].replace(xe,be),ye.test(o[0].type)&&f(t.parentNode)||t))){if(o.splice(i,1),!(e=r.length&&d(o)))return K.apply(n,r),n;break}}return(l||S(e,c))(r,t,!O,n,!t||ye.test(e)&&f(t.parentNode)||t),n},T.sortStable=W.split("").sort(V).join("")===W,T.detectDuplicates=!!q,L(),T.sortDetached=i(function(e){return 1&e.compareDocumentPosition(H.createElement("fieldset"))}),i(function(e){return e.innerHTML="<a href='#'></a>","#"===e.firstChild.getAttribute("href")})||o("type|href|height|width",function(e,t,n){if(!n)return e.getAttribute(t,"type"===t.toLowerCase()?1:2)}),T.attributes&&i(function(e){return e.innerHTML="<input/>",e.firstChild.setAttribute("value",""),""===e.firstChild.getAttribute("value")})||o("value",function(e,t,n){if(!n&&"input"===e.nodeName.toLowerCase())return e.defaultValue}),i(function(e){return null==e.getAttribute("disabled")})||o(te,function(e,t,n){var r;if(!n)return!0===e[t]?t.toLowerCase():(r=e.getAttributeNode(t))&&r.specified?r.value:null}),t}(e);ge.find=be,ge.expr=be.selectors,ge.expr[":"]=ge.expr.pseudos,ge.uniqueSort=ge.unique=be.uniqueSort,ge.text=be.getText,ge.isXMLDoc=be.isXML,ge.contains=be.contains,ge.escapeSelector=be.escape;var we=function(e,t,n){for(var r=[],i=void 0!==n;(e=e[t])&&9!==e.nodeType;)if(1===e.nodeType){if(i&&ge(e).is(n))break;r.push(e)}return r},Te=function(e,t){for(var n=[];e;e=e.nextSibling)1===e.nodeType&&e!==t&&n.push(e);return n},Ce=ge.expr.match.needsContext,Ee=/^<([a-z][^\/\0>:\x20\t\r\n\f]*)[\x20\t\r\n\f]*\/?>(?:<\/\1>|)$/i,ke=/^.[^:#\[\.,]*$/;ge.filter=function(e,t,n){var r=t[0];return n&&(e=":not("+e+")"),1===t.length&&1===r.nodeType?ge.find.matchesSelector(r,e)?[r]:[]:ge.find.matches(e,ge.grep(t,function(e){return 1===e.nodeType}))},ge.fn.extend({find:function(e){var t,n,r=this.length,i=this;if("string"!=typeof e)return this.pushStack(ge(e).filter(function(){for(t=0;t<r;t++)if(ge.contains(i[t],this))return!0}));for(n=this.pushStack([]),t=0;t<r;t++)ge.find(e,i[t],n);return r>1?ge.uniqueSort(n):n},filter:function(e){return this.pushStack(o(this,e||[],!1))},not:function(e){return this.pushStack(o(this,e||[],!0))},is:function(e){return!!o(this,"string"==typeof e&&Ce.test(e)?ge(e):e||[],!1).length}});var Ne,Se=/^(?:\s*(<[\w\W]+>)[^>]*|#([\w-]+))$/;(ge.fn.init=function(e,t,n){var r,i;if(!e)return this;if(n=n||Ne,"string"==typeof e){if(!(r="<"===e[0]&&">"===e[e.length-1]&&e.length>=3?[null,e,null]:Se.exec(e))||!r[1]&&t)return!t||t.jquery?(t||n).find(e):this.constructor(t).find(e);if(r[1]){if(t=t instanceof ge?t[0]:t,ge.merge(this,ge.parseHTML(r[1],t&&t.nodeType?t.ownerDocument||t:ne,!0)),Ee.test(r[1])&&ge.isPlainObject(t))for(r in t)ge.isFunction(this[r])?this[r](t[r]):this.attr(r,t[r]);return this}return i=ne.getElementById(r[2]),i&&(this[0]=i,this.length=1),this}return e.nodeType?(this[0]=e,this.length=1,this):ge.isFunction(e)?void 0!==n.ready?n.ready(e):e(ge):ge.makeArray(e,this)}).prototype=ge.fn,Ne=ge(ne);var De=/^(?:parents|prev(?:Until|All))/,je={children:!0,contents:!0,next:!0,prev:!0};ge.fn.extend({has:function(e){var t=ge(e,this),n=t.length;return this.filter(function(){for(var e=0;e<n;e++)if(ge.contains(this,t[e]))return!0})},closest:function(e,t){var n,r=0,i=this.length,o=[],a="string"!=typeof e&&ge(e);if(!Ce.test(e))for(;r<i;r++)for(n=this[r];n&&n!==t;n=n.parentNode)if(n.nodeType<11&&(a?a.index(n)>-1:1===n.nodeType&&ge.find.matchesSelector(n,e))){o.push(n);break}return this.pushStack(o.length>1?ge.uniqueSort(o):o)},index:function(e){return e?"string"==typeof e?se.call(ge(e),this[0]):se.call(this,e.jquery?e[0]:e):this[0]&&this[0].parentNode?this.first().prevAll().length:-1},add:function(e,t){return this.pushStack(ge.uniqueSort(ge.merge(this.get(),ge(e,t))))},addBack:function(e){return this.add(null==e?this.prevObject:this.prevObject.filter(e))}}),ge.each({parent:function(e){var t=e.parentNode;return t&&11!==t.nodeType?t:null},parents:function(e){return we(e,"parentNode")},parentsUntil:function(e,t,n){return we(e,"parentNode",n)},next:function(e){return a(e,"nextSibling")},prev:function(e){return a(e,"previousSibling")},nextAll:function(e){return we(e,"nextSibling")},prevAll:function(e){return we(e,"previousSibling")},nextUntil:function(e,t,n){return we(e,"nextSibling",n)},prevUntil:function(e,t,n){return we(e,"previousSibling",n)},siblings:function(e){return Te((e.parentNode||{}).firstChild,e)},children:function(e){return Te(e.firstChild)},contents:function(e){return i(e,"iframe")?e.contentDocument:(i(e,"template")&&(e=e.content||e),ge.merge([],e.childNodes))}},function(e,t){ge.fn[e]=function(n,r){var i=ge.map(this,t,n);return"Until"!==e.slice(-5)&&(r=n),r&&"string"==typeof r&&(i=ge.filter(r,i)),this.length>1&&(je[e]||ge.uniqueSort(i),De.test(e)&&i.reverse()),this.pushStack(i)}});var Ae=/[^\x20\t\r\n\f]+/g;ge.Callbacks=function(e){e="string"==typeof e?s(e):ge.extend({},e);var t,n,r,i,o=[],a=[],u=-1,l=function(){for(i=i||e.once,r=t=!0;a.length;u=-1)for(n=a.shift();++u<o.length;)!1===o[u].apply(n[0],n[1])&&e.stopOnFalse&&(u=o.length,n=!1);e.memory||(n=!1),t=!1,i&&(o=n?[]:"")},c={add:function(){return o&&(n&&!t&&(u=o.length-1,a.push(n)),function t(n){ge.each(n,function(n,r){ge.isFunction(r)?e.unique&&c.has(r)||o.push(r):r&&r.length&&"string"!==ge.type(r)&&t(r)})}(arguments),n&&!t&&l()),this},remove:function(){return ge.each(arguments,function(e,t){for(var n;(n=ge.inArray(t,o,n))>-1;)o.splice(n,1),n<=u&&u--}),this},has:function(e){return e?ge.inArray(e,o)>-1:o.length>0},empty:function(){return o&&(o=[]),this},disable:function(){return i=a=[],o=n="",this},disabled:function(){return!o},lock:function(){return i=a=[],n||t||(o=n=""),this},locked:function(){return!!i},fireWith:function(e,n){return i||(n=n||[],n=[e,n.slice?n.slice():n],a.push(n),t||l()),this},fire:function(){return c.fireWith(this,arguments),this},fired:function(){return!!r}};return c},ge.extend({Deferred:function(t){var n=[["notify","progress",ge.Callbacks("memory"),ge.Callbacks("memory"),2],["resolve","done",ge.Callbacks("once memory"),ge.Callbacks("once memory"),0,"resolved"],["reject","fail",ge.Callbacks("once memory"),ge.Callbacks("once memory"),1,"rejected"]],r="pending",i={state:function(){return r},always:function(){return o.done(arguments).fail(arguments),this},"catch":function(e){return i.then(null,e)},pipe:function(){var e=arguments;return ge.Deferred(function(t){ge.each(n,function(n,r){var i=ge.isFunction(e[r[4]])&&e[r[4]];o[r[1]](function(){var e=i&&i.apply(this,arguments);e&&ge.isFunction(e.promise)?e.promise().progress(t.notify).done(t.resolve).fail(t.reject):t[r[0]+"With"](this,i?[e]:arguments)})}),e=null}).promise()},then:function(t,r,i){function o(t,n,r,i){return function(){var s=this,c=arguments,f=function(){var e,f;if(!(t<a)){if((e=r.apply(s,c))===n.promise())throw new TypeError("Thenable self-resolution");f=e&&("object"==typeof e||"function"==typeof e)&&e.then,ge.isFunction(f)?i?f.call(e,o(a,n,u,i),o(a,n,l,i)):(a++,f.call(e,o(a,n,u,i),o(a,n,l,i),o(a,n,u,n.notifyWith))):(r!==u&&(s=void 0,c=[e]),(i||n.resolveWith)(s,c))}},p=i?f:function(){try{f()}catch(e){ge.Deferred.exceptionHook&&ge.Deferred.exceptionHook(e,p.stackTrace),t+1>=a&&(r!==l&&(s=void 0,c=[e]),n.rejectWith(s,c))}};t?p():(ge.Deferred.getStackHook&&(p.stackTrace=ge.Deferred.getStackHook()),e.setTimeout(p))}}var a=0;return ge.Deferred(function(e){n[0][3].add(o(0,e,ge.isFunction(i)?i:u,e.notifyWith)),n[1][3].add(o(0,e,ge.isFunction(t)?t:u)),n[2][3].add(o(0,e,ge.isFunction(r)?r:l))}).promise()},promise:function(e){return null!=e?ge.extend(e,i):i}},o={};return ge.each(n,function(e,t){var a=t[2],s=t[5];i[t[1]]=a.add,s&&a.add(function(){r=s},n[3-e][2].disable,n[0][2].lock),a.add(t[3].fire),o[t[0]]=function(){return o[t[0]+"With"](this===o?void 0:this,arguments),this},o[t[0]+"With"]=a.fireWith}),i.promise(o),t&&t.call(o,o),o},when:function(e){var t=arguments.length,n=t,r=Array(n),i=ie.call(arguments),o=ge.Deferred(),a=function(e){return function(n){r[e]=this,i[e]=arguments.length>1?ie.call(arguments):n,--t||o.resolveWith(r,i)}};if(t<=1&&(c(e,o.done(a(n)).resolve,o.reject,!t),"pending"===o.state()||ge.isFunction(i[n]&&i[n].then)))return o.then();for(;n--;)c(i[n],a(n),o.reject);return o.promise()}});var qe=/^(Eval|Internal|Range|Reference|Syntax|Type|URI)Error$/;ge.Deferred.exceptionHook=function(t,n){e.console&&e.console.warn&&t&&qe.test(t.name)&&e.console.warn("jQuery.Deferred exception: "+t.message,t.stack,n)},ge.readyException=function(t){e.setTimeout(function(){throw t})};var Le=ge.Deferred();ge.fn.ready=function(e){return Le.then(e)["catch"](function(e){ge.readyException(e)}),this},ge.extend({isReady:!1,readyWait:1,ready:function(e){(!0===e?--ge.readyWait:ge.isReady)||(ge.isReady=!0,!0!==e&&--ge.readyWait>0||Le.resolveWith(ne,[ge]))}}),ge.ready.then=Le.then,"complete"===ne.readyState||"loading"!==ne.readyState&&!ne.documentElement.doScroll?e.setTimeout(ge.ready):(ne.addEventListener("DOMContentLoaded",f),e.addEventListener("load",f));var He=function(e,t,n,r,i,o,a){var s=0,u=e.length,l=null==n;if("object"===ge.type(n)){i=!0;for(s in n)He(e,t,s,n[s],!0,o,a)}else if(void 0!==r&&(i=!0,ge.isFunction(r)||(a=!0),l&&(a?(t.call(e,r),t=null):(l=t,t=function(e,t,n){return l.call(ge(e),n)})),t))for(;s<u;s++)t(e[s],n,a?r:r.call(e[s],s,t(e[s],n)));return i?e:l?t.call(e):u?t(e[0],n):o},Fe=function(e){return 1===e.nodeType||9===e.nodeType||!+e.nodeType};p.uid=1,p.prototype={cache:function(e){var t=e[this.expando];return t||(t={},Fe(e)&&(e.nodeType?e[this.expando]=t:Object.defineProperty(e,this.expando,{value:t,configurable:!0}))),t},set:function(e,t,n){var r,i=this.cache(e);if("string"==typeof t)i[ge.camelCase(t)]=n;else for(r in t)i[ge.camelCase(r)]=t[r];return i},get:function(e,t){return void 0===t?this.cache(e):e[this.expando]&&e[this.expando][ge.camelCase(t)]},access:function(e,t,n){return void 0===t||t&&"string"==typeof t&&void 0===n?this.get(e,t):(this.set(e,t,n),void 0!==n?n:t)},remove:function(e,t){var n,r=e[this.expando];if(void 0!==r){if(void 0!==t){Array.isArray(t)?t=t.map(ge.camelCase):(t=ge.camelCase(t),t=t in r?[t]:t.match(Ae)||[]),n=t.length;for(;n--;)delete r[t[n]]}(void 0===t||ge.isEmptyObject(r))&&(e.nodeType?e[this.expando]=void 0:delete e[this.expando])}},hasData:function(e){var t=e[this.expando];return void 0!==t&&!ge.isEmptyObject(t)}};var Oe=new p,Pe=new p,Re=/^(?:\{[\w\W]*\}|\[[\w\W]*\])$/,Ie=/[A-Z]/g;ge.extend({hasData:function(e){return Pe.hasData(e)||Oe.hasData(e)},data:function(e,t,n){return Pe.access(e,t,n)},removeData:function(e,t){Pe.remove(e,t)},_data:function(e,t,n){return Oe.access(e,t,n)},_removeData:function(e,t){Oe.remove(e,t)}}),ge.fn.extend({data:function(e,t){var n,r,i,o=this[0],a=o&&o.attributes;if(void 0===e){if(this.length&&(i=Pe.get(o),1===o.nodeType&&!Oe.get(o,"hasDataAttrs"))){for(n=a.length;n--;)a[n]&&(r=a[n].name,0===r.indexOf("data-")&&(r=ge.camelCase(r.slice(5)),h(o,r,i[r])));Oe.set(o,"hasDataAttrs",!0)}return i}return"object"==typeof e?this.each(function(){Pe.set(this,e)}):He(this,function(t){var n;if(o&&void 0===t){if(void 0!==(n=Pe.get(o,e)))return n;if(void 0!==(n=h(o,e)))return n}else this.each(function(){Pe.set(this,e,t)})},null,t,arguments.length>1,null,!0)},removeData:function(e){return this.each(function(){Pe.remove(this,e)})}}),ge.extend({queue:function(e,t,n){var r;if(e)return t=(t||"fx")+"queue",r=Oe.get(e,t),n&&(!r||Array.isArray(n)?r=Oe.access(e,t,ge.makeArray(n)):r.push(n)),r||[]},dequeue:function(e,t){t=t||"fx";var n=ge.queue(e,t),r=n.length,i=n.shift(),o=ge._queueHooks(e,t),a=function(){ge.dequeue(e,t)};"inprogress"===i&&(i=n.shift(),r--),i&&("fx"===t&&n.unshift("inprogress"),delete o.stop,i.call(e,a,o)),!r&&o&&o.empty.fire()},_queueHooks:function(e,t){var n=t+"queueHooks";return Oe.get(e,n)||Oe.access(e,n,{empty:ge.Callbacks("once memory").add(function(){Oe.remove(e,[t+"queue",n])})})}}),ge.fn.extend({queue:function(e,t){var n=2;return"string"!=typeof e&&(t=e,e="fx",n--),arguments.length<n?ge.queue(this[0],e):void 0===t?this:this.each(function(){var n=ge.queue(this,e,t);ge._queueHooks(this,e),"fx"===e&&"inprogress"!==n[0]&&ge.dequeue(this,e)})},dequeue:function(e){return this.each(function(){ge.dequeue(this,e)})},clearQueue:function(e){return this.queue(e||"fx",[])},promise:function(e,t){var n,r=1,i=ge.Deferred(),o=this,a=this.length,s=function(){--r||i.resolveWith(o,[o])};for("string"!=typeof e&&(t=e,e=void 0),e=e||"fx";a--;)(n=Oe.get(o[a],e+"queueHooks"))&&n.empty&&(r++,n.empty.add(s));return s(),i.promise(t)}});var Me=/[+-]?(?:\d*\.|)\d+(?:[eE][+-]?\d+|)/.source,We=new RegExp("^(?:([+-])=|)("+Me+")([a-z%]*)$","i"),Be=["Top","Right","Bottom","Left"],$e=function(e,t){return e=t||e,"none"===e.style.display||""===e.style.display&&ge.contains(e.ownerDocument,e)&&"none"===ge.css(e,"display")},_e=function(e,t,n,r){var i,o,a={};for(o in t)a[o]=e.style[o],e.style[o]=t[o];i=n.apply(e,r||[]);for(o in t)e.style[o]=a[o];return i},ze={};ge.fn.extend({show:function(){return v(this,!0)},hide:function(){return v(this)},toggle:function(e){return"boolean"==typeof e?e?this.show():this.hide():this.each(function(){$e(this)?ge(this).show():ge(this).hide()})}});var Xe=/^(?:checkbox|radio)$/i,Ue=/<([a-z][^\/\0>\x20\t\r\n\f]+)/i,Ve=/^$|\/(?:java|ecma)script/i,Ge={option:[1,"<select multiple='multiple'>","</select>"],thead:[1,"<table>","</table>"],col:[2,"<table><colgroup>","</colgroup></table>"],tr:[2,"<table><tbody>","</tbody></table>"],td:[3,"<table><tbody><tr>","</tr></tbody></table>"],_default:[0,"",""]};Ge.optgroup=Ge.option,Ge.tbody=Ge.tfoot=Ge.colgroup=Ge.caption=Ge.thead,Ge.th=Ge.td;var Ye=/<|&#?\w+;/;!function(){var e=ne.createDocumentFragment(),t=e.appendChild(ne.createElement("div")),n=ne.createElement("input");n.setAttribute("type","radio"),n.setAttribute("checked","checked"),n.setAttribute("name","t"),t.appendChild(n),de.checkClone=t.cloneNode(!0).cloneNode(!0).lastChild.checked,t.innerHTML="<textarea>x</textarea>",de.noCloneChecked=!!t.cloneNode(!0).lastChild.defaultValue}();var Qe=ne.documentElement,Je=/^key/,Ke=/^(?:mouse|pointer|contextmenu|drag|drop)|click/,Ze=/^([^.]*)(?:\.(.+)|)/;ge.event={global:{},add:function(e,t,n,r,i){var o,a,s,u,l,c,f,p,d,h,g,m=Oe.get(e);if(m)for(n.handler&&(o=n,n=o.handler,i=o.selector),i&&ge.find.matchesSelector(Qe,i),n.guid||(n.guid=ge.guid++),(u=m.events)||(u=m.events={}),(a=m.handle)||(a=m.handle=function(t){return void 0!==ge&&ge.event.triggered!==t.type?ge.event.dispatch.apply(e,arguments):void 0}),t=(t||"").match(Ae)||[""],l=t.length;l--;)s=Ze.exec(t[l])||[],d=g=s[1],h=(s[2]||"").split(".").sort(),d&&(f=ge.event.special[d]||{},d=(i?f.delegateType:f.bindType)||d,f=ge.event.special[d]||{},c=ge.extend({type:d,origType:g,data:r,handler:n,guid:n.guid,selector:i,needsContext:i&&ge.expr.match.needsContext.test(i),namespace:h.join(".")},o),(p=u[d])||(p=u[d]=[],p.delegateCount=0,f.setup&&!1!==f.setup.call(e,r,h,a)||e.addEventListener&&e.addEventListener(d,a)),f.add&&(f.add.call(e,c),c.handler.guid||(c.handler.guid=n.guid)),i?p.splice(p.delegateCount++,0,c):p.push(c),ge.event.global[d]=!0)},remove:function(e,t,n,r,i){var o,a,s,u,l,c,f,p,d,h,g,m=Oe.hasData(e)&&Oe.get(e);if(m&&(u=m.events)){for(t=(t||"").match(Ae)||[""],l=t.length;l--;)if(s=Ze.exec(t[l])||[],d=g=s[1],h=(s[2]||"").split(".").sort(),d){for(f=ge.event.special[d]||{},d=(r?f.delegateType:f.bindType)||d,p=u[d]||[],s=s[2]&&new RegExp("(^|\\.)"+h.join("\\.(?:.*\\.|)")+"(\\.|$)"),a=o=p.length;o--;)c=p[o],!i&&g!==c.origType||n&&n.guid!==c.guid||s&&!s.test(c.namespace)||r&&r!==c.selector&&("**"!==r||!c.selector)||(p.splice(o,1),c.selector&&p.delegateCount--,f.remove&&f.remove.call(e,c));a&&!p.length&&(f.teardown&&!1!==f.teardown.call(e,h,m.handle)||ge.removeEvent(e,d,m.handle),delete u[d])}else for(d in u)ge.event.remove(e,d+t[l],n,r,!0);ge.isEmptyObject(u)&&Oe.remove(e,"handle events")}},dispatch:function(e){var t,n,r,i,o,a,s=ge.event.fix(e),u=new Array(arguments.length),l=(Oe.get(this,"events")||{})[s.type]||[],c=ge.event.special[s.type]||{};for(u[0]=s,t=1;t<arguments.length;t++)u[t]=arguments[t];if(s.delegateTarget=this,!c.preDispatch||!1!==c.preDispatch.call(this,s)){for(a=ge.event.handlers.call(this,s,l),t=0;(i=a[t++])&&!s.isPropagationStopped();)for(s.currentTarget=i.elem,n=0;(o=i.handlers[n++])&&!s.isImmediatePropagationStopped();)s.rnamespace&&!s.rnamespace.test(o.namespace)||(s.handleObj=o,s.data=o.data,void 0!==(r=((ge.event.special[o.origType]||{}).handle||o.handler).apply(i.elem,u))&&!1===(s.result=r)&&(s.preventDefault(),s.stopPropagation()));return c.postDispatch&&c.postDispatch.call(this,s),s.result}},handlers:function(e,t){var n,r,i,o,a,s=[],u=t.delegateCount,l=e.target;if(u&&l.nodeType&&!("click"===e.type&&e.button>=1))for(;l!==this;l=l.parentNode||this)if(1===l.nodeType&&("click"!==e.type||!0!==l.disabled)){for(o=[],a={},n=0;n<u;n++)r=t[n],i=r.selector+" ",void 0===a[i]&&(a[i]=r.needsContext?ge(i,this).index(l)>-1:ge.find(i,this,null,[l]).length),a[i]&&o.push(r);o.length&&s.push({elem:l,handlers:o})}return l=this,u<t.length&&s.push({elem:l,handlers:t.slice(u)}),s},addProp:function(e,t){Object.defineProperty(ge.Event.prototype,e,{enumerable:!0,configurable:!0,get:ge.isFunction(t)?function(){if(this.originalEvent)return t(this.originalEvent)}:function(){if(this.originalEvent)return this.originalEvent[e]},set:function(t){Object.defineProperty(this,e,{enumerable:!0,configurable:!0,writable:!0,value:t})}})},fix:function(e){return e[ge.expando]?e:new ge.Event(e)},special:{load:{noBubble:!0},focus:{trigger:function(){if(this!==C()&&this.focus)return this.focus(),!1},delegateType:"focusin"},blur:{trigger:function(){if(this===C()&&this.blur)return this.blur(),!1},delegateType:"focusout"},click:{trigger:function(){if("checkbox"===this.type&&this.click&&i(this,"input"))return this.click(),!1},_default:function(e){return i(e.target,"a")}},beforeunload:{postDispatch:function(e){void 0!==e.result&&e.originalEvent&&(e.originalEvent.returnValue=e.result)}}}},ge.removeEvent=function(e,t,n){e.removeEventListener&&e.removeEventListener(t,n)},ge.Event=function(e,t){return this instanceof ge.Event?(e&&e.type?(this.originalEvent=e,this.type=e.type,this.isDefaultPrevented=e.defaultPrevented||void 0===e.defaultPrevented&&!1===e.returnValue?w:T,this.target=e.target&&3===e.target.nodeType?e.target.parentNode:e.target,this.currentTarget=e.currentTarget,this.relatedTarget=e.relatedTarget):this.type=e,t&&ge.extend(this,t),this.timeStamp=e&&e.timeStamp||ge.now(),void(this[ge.expando]=!0)):new ge.Event(e,t)},ge.Event.prototype={constructor:ge.Event,isDefaultPrevented:T,isPropagationStopped:T,isImmediatePropagationStopped:T,isSimulated:!1,preventDefault:function(){var e=this.originalEvent;this.isDefaultPrevented=w,e&&!this.isSimulated&&e.preventDefault()},stopPropagation:function(){var e=this.originalEvent;this.isPropagationStopped=w,e&&!this.isSimulated&&e.stopPropagation()},stopImmediatePropagation:function(){var e=this.originalEvent;this.isImmediatePropagationStopped=w,e&&!this.isSimulated&&e.stopImmediatePropagation(),this.stopPropagation()}},ge.each({altKey:!0,bubbles:!0,cancelable:!0,changedTouches:!0,ctrlKey:!0,detail:!0,eventPhase:!0,metaKey:!0,pageX:!0,pageY:!0,shiftKey:!0,view:!0,"char":!0,charCode:!0,key:!0,keyCode:!0,button:!0,buttons:!0,clientX:!0,clientY:!0,offsetX:!0,offsetY:!0,pointerId:!0,pointerType:!0,screenX:!0,screenY:!0,targetTouches:!0,toElement:!0,touches:!0,which:function(e){var t=e.button;return null==e.which&&Je.test(e.type)?null!=e.charCode?e.charCode:e.keyCode:!e.which&&void 0!==t&&Ke.test(e.type)?1&t?1:2&t?3:4&t?2:0:e.which}},ge.event.addProp),ge.each({mouseenter:"mouseover",mouseleave:"mouseout",pointerenter:"pointerover",pointerleave:"pointerout"},function(e,t){ge.event.special[e]={delegateType:t,bindType:t,handle:function(e){var n,r=this,i=e.relatedTarget,o=e.handleObj;return i&&(i===r||ge.contains(r,i))||(e.type=o.origType,n=o.handler.apply(this,arguments),e.type=t),n}}}),ge.fn.extend({on:function(e,t,n,r){return E(this,e,t,n,r)},one:function(e,t,n,r){return E(this,e,t,n,r,1)},off:function(e,t,n){var r,i;if(e&&e.preventDefault&&e.handleObj)return r=e.handleObj,ge(e.delegateTarget).off(r.namespace?r.origType+"."+r.namespace:r.origType,r.selector,r.handler),this;if("object"==typeof e){for(i in e)this.off(i,t,e[i]);return this}return!1!==t&&"function"!=typeof t||(n=t,t=void 0),!1===n&&(n=T),this.each(function(){ge.event.remove(this,e,n,t)})}});var et=/<(?!area|br|col|embed|hr|img|input|link|meta|param)(([a-z][^\/\0>\x20\t\r\n\f]*)[^>]*)\/>/gi,tt=/<script|<style|<link/i,nt=/checked\s*(?:[^=]|=\s*.checked.)/i,rt=/^true\/(.*)/,it=/^\s*<!(?:\[CDATA\[|--)|(?:\]\]|--)>\s*$/g;ge.extend({htmlPrefilter:function(e){return e.replace(et,"<$1></$2>")},clone:function(e,t,n){var r,i,o,a,s=e.cloneNode(!0),u=ge.contains(e.ownerDocument,e);if(!(de.noCloneChecked||1!==e.nodeType&&11!==e.nodeType||ge.isXMLDoc(e)))for(a=y(s),o=y(e),r=0,i=o.length;r<i;r++)j(o[r],a[r]);if(t)if(n)for(o=o||y(e),a=a||y(s),r=0,i=o.length;r<i;r++)D(o[r],a[r]);else D(e,s);return a=y(s,"script"),a.length>0&&x(a,!u&&y(e,"script")),s},cleanData:function(e){for(var t,n,r,i=ge.event.special,o=0;void 0!==(n=e[o]);o++)if(Fe(n)){if(t=n[Oe.expando]){if(t.events)for(r in t.events)i[r]?ge.event.remove(n,r):ge.removeEvent(n,r,t.handle);n[Oe.expando]=void 0}n[Pe.expando]&&(n[Pe.expando]=void 0)}}}),ge.fn.extend({detach:function(e){return q(this,e,!0)},remove:function(e){return q(this,e)},text:function(e){return He(this,function(e){return void 0===e?ge.text(this):this.empty().each(function(){1!==this.nodeType&&11!==this.nodeType&&9!==this.nodeType||(this.textContent=e)})},null,e,arguments.length)},append:function(){return A(this,arguments,function(e){if(1===this.nodeType||11===this.nodeType||9===this.nodeType){k(this,e).appendChild(e)}})},prepend:function(){return A(this,arguments,function(e){if(1===this.nodeType||11===this.nodeType||9===this.nodeType){var t=k(this,e);t.insertBefore(e,t.firstChild)}})},before:function(){return A(this,arguments,function(e){this.parentNode&&this.parentNode.insertBefore(e,this)})},after:function(){return A(this,arguments,function(e){this.parentNode&&this.parentNode.insertBefore(e,this.nextSibling)})},empty:function(){for(var e,t=0;null!=(e=this[t]);t++)1===e.nodeType&&(ge.cleanData(y(e,!1)),e.textContent="");return this},clone:function(e,t){return e=null!=e&&e,t=null==t?e:t,this.map(function(){return ge.clone(this,e,t)})},html:function(e){return He(this,function(e){var t=this[0]||{},n=0,r=this.length;if(void 0===e&&1===t.nodeType)return t.innerHTML;if("string"==typeof e&&!tt.test(e)&&!Ge[(Ue.exec(e)||["",""])[1].toLowerCase()]){e=ge.htmlPrefilter(e);try{for(;n<r;n++)t=this[n]||{},1===t.nodeType&&(ge.cleanData(y(t,!1)),t.innerHTML=e);t=0}catch(e){}}t&&this.empty().append(e)},null,e,arguments.length)},replaceWith:function(){var e=[];return A(this,arguments,function(t){var n=this.parentNode;ge.inArray(this,e)<0&&(ge.cleanData(y(this)),n&&n.replaceChild(t,this))},e)}}),ge.each({appendTo:"append",prependTo:"prepend",insertBefore:"before",insertAfter:"after",replaceAll:"replaceWith"},function(e,t){ge.fn[e]=function(e){for(var n,r=[],i=ge(e),o=i.length-1,a=0;a<=o;a++)n=a===o?this:this.clone(!0),ge(i[a])[t](n),ae.apply(r,n.get());return this.pushStack(r)}});var ot=/^margin/,at=new RegExp("^("+Me+")(?!px)[a-z%]+$","i"),st=function(t){var n=t.ownerDocument.defaultView;return n&&n.opener||(n=e),n.getComputedStyle(t)};!function(){function t(){if(s){s.style.cssText="box-sizing:border-box;position:relative;display:block;margin:auto;border:1px;padding:1px;top:1%;width:50%",s.innerHTML="",Qe.appendChild(a);var t=e.getComputedStyle(s);n="1%"!==t.top,o="2px"===t.marginLeft,r="4px"===t.width,s.style.marginRight="50%",i="4px"===t.marginRight,Qe.removeChild(a),s=null}}var n,r,i,o,a=ne.createElement("div"),s=ne.createElement("div");s.style&&(s.style.backgroundClip="content-box",s.cloneNode(!0).style.backgroundClip="",de.clearCloneStyle="content-box"===s.style.backgroundClip,a.style.cssText="border:0;width:8px;height:0;top:0;left:-9999px;padding:0;margin-top:1px;position:absolute",a.appendChild(s),ge.extend(de,{pixelPosition:function(){return t(),n},boxSizingReliable:function(){return t(),r},pixelMarginRight:function(){return t(),i},reliableMarginLeft:function(){return t(),o}}))}();var ut=/^(none|table(?!-c[ea]).+)/,lt=/^--/,ct={position:"absolute",visibility:"hidden",display:"block"},ft={letterSpacing:"0",fontWeight:"400"},pt=["Webkit","Moz","ms"],dt=ne.createElement("div").style;ge.extend({cssHooks:{opacity:{get:function(e,t){if(t){var n=L(e,"opacity");return""===n?"1":n}}}},cssNumber:{animationIterationCount:!0,columnCount:!0,fillOpacity:!0,flexGrow:!0,flexShrink:!0,fontWeight:!0,lineHeight:!0,opacity:!0,order:!0,orphans:!0,widows:!0,zIndex:!0,zoom:!0},cssProps:{"float":"cssFloat"},style:function(e,t,n,r){if(e&&3!==e.nodeType&&8!==e.nodeType&&e.style){var i,o,a,s=ge.camelCase(t),u=lt.test(t),l=e.style;return u||(t=O(s)),a=ge.cssHooks[t]||ge.cssHooks[s],void 0===n?a&&"get"in a&&void 0!==(i=a.get(e,!1,r))?i:l[t]:(o=typeof n,"string"===o&&(i=We.exec(n))&&i[1]&&(n=g(e,t,i),o="number"),void(null!=n&&n===n&&("number"===o&&(n+=i&&i[3]||(ge.cssNumber[s]?"":"px")),de.clearCloneStyle||""!==n||0!==t.indexOf("background")||(l[t]="inherit"),a&&"set"in a&&void 0===(n=a.set(e,n,r))||(u?l.setProperty(t,n):l[t]=n))))}},css:function(e,t,n,r){var i,o,a,s=ge.camelCase(t);return lt.test(t)||(t=O(s)),a=ge.cssHooks[t]||ge.cssHooks[s],a&&"get"in a&&(i=a.get(e,!0,n)),void 0===i&&(i=L(e,t,r)),"normal"===i&&t in ft&&(i=ft[t]),""===n||n?(o=parseFloat(i),!0===n||isFinite(o)?o||0:i):i}}),ge.each(["height","width"],function(e,t){ge.cssHooks[t]={get:function(e,n,r){if(n)return!ut.test(ge.css(e,"display"))||e.getClientRects().length&&e.getBoundingClientRect().width?I(e,t,r):_e(e,ct,function(){return I(e,t,r)})},set:function(e,n,r){var i,o=r&&st(e),a=r&&R(e,t,r,"border-box"===ge.css(e,"boxSizing",!1,o),o);return a&&(i=We.exec(n))&&"px"!==(i[3]||"px")&&(e.style[t]=n,n=ge.css(e,t)),P(e,n,a)}}}),ge.cssHooks.marginLeft=H(de.reliableMarginLeft,function(e,t){if(t)return(parseFloat(L(e,"marginLeft"))||e.getBoundingClientRect().left-_e(e,{marginLeft:0},function(){return e.getBoundingClientRect().left}))+"px"}),ge.each({margin:"",padding:"",border:"Width"},function(e,t){ge.cssHooks[e+t]={expand:function(n){for(var r=0,i={},o="string"==typeof n?n.split(" "):[n];r<4;r++)i[e+Be[r]+t]=o[r]||o[r-2]||o[0];return i}},ot.test(e)||(ge.cssHooks[e+t].set=P)}),ge.fn.extend({css:function(e,t){return He(this,function(e,t,n){var r,i,o={},a=0;if(Array.isArray(t)){for(r=st(e),i=t.length;a<i;a++)o[t[a]]=ge.css(e,t[a],!1,r);return o}return void 0!==n?ge.style(e,t,n):ge.css(e,t)},e,t,arguments.length>1)}}),ge.Tween=M,M.prototype={constructor:M,init:function(e,t,n,r,i,o){this.elem=e,this.prop=n,this.easing=i||ge.easing._default,this.options=t,this.start=this.now=this.cur(),this.end=r,this.unit=o||(ge.cssNumber[n]?"":"px")},cur:function(){var e=M.propHooks[this.prop];return e&&e.get?e.get(this):M.propHooks._default.get(this)},run:function(e){var t,n=M.propHooks[this.prop];return this.options.duration?this.pos=t=ge.easing[this.easing](e,this.options.duration*e,0,1,this.options.duration):this.pos=t=e,this.now=(this.end-this.start)*t+this.start,this.options.step&&this.options.step.call(this.elem,this.now,this),n&&n.set?n.set(this):M.propHooks._default.set(this),this}},M.prototype.init.prototype=M.prototype,M.propHooks={_default:{get:function(e){var t;return 1!==e.elem.nodeType||null!=e.elem[e.prop]&&null==e.elem.style[e.prop]?e.elem[e.prop]:(t=ge.css(e.elem,e.prop,""),t&&"auto"!==t?t:0)},set:function(e){ge.fx.step[e.prop]?ge.fx.step[e.prop](e):1!==e.elem.nodeType||null==e.elem.style[ge.cssProps[e.prop]]&&!ge.cssHooks[e.prop]?e.elem[e.prop]=e.now:ge.style(e.elem,e.prop,e.now+e.unit)}}},M.propHooks.scrollTop=M.propHooks.scrollLeft={set:function(e){e.elem.nodeType&&e.elem.parentNode&&(e.elem[e.prop]=e.now)}},ge.easing={linear:function(e){return e},swing:function(e){return.5-Math.cos(e*Math.PI)/2},_default:"swing"},ge.fx=M.prototype.init,ge.fx.step={};var ht,gt,mt=/^(?:toggle|show|hide)$/,vt=/queueHooks$/;ge.Animation=ge.extend(U,{tweeners:{"*":[function(e,t){var n=this.createTween(e,t);return g(n.elem,e,We.exec(t),n),n}]},tweener:function(e,t){ge.isFunction(e)?(t=e,e=["*"]):e=e.match(Ae);for(var n,r=0,i=e.length;r<i;r++)n=e[r],U.tweeners[n]=U.tweeners[n]||[],U.tweeners[n].unshift(t)},prefilters:[z],prefilter:function(e,t){t?U.prefilters.unshift(e):U.prefilters.push(e)}}),ge.speed=function(e,t,n){var r=e&&"object"==typeof e?ge.extend({},e):{complete:n||!n&&t||ge.isFunction(e)&&e,duration:e,easing:n&&t||t&&!ge.isFunction(t)&&t};return ge.fx.off?r.duration=0:"number"!=typeof r.duration&&(r.duration in ge.fx.speeds?r.duration=ge.fx.speeds[r.duration]:r.duration=ge.fx.speeds._default),null!=r.queue&&!0!==r.queue||(r.queue="fx"),r.old=r.complete,r.complete=function(){ge.isFunction(r.old)&&r.old.call(this),r.queue&&ge.dequeue(this,r.queue)},r},ge.fn.extend({fadeTo:function(e,t,n,r){return this.filter($e).css("opacity",0).show().end().animate({opacity:t},e,n,r)},animate:function(e,t,n,r){var i=ge.isEmptyObject(e),o=ge.speed(t,n,r),a=function(){var t=U(this,ge.extend({},e),o);(i||Oe.get(this,"finish"))&&t.stop(!0)};return a.finish=a,i||!1===o.queue?this.each(a):this.queue(o.queue,a)},stop:function(e,t,n){var r=function(e){var t=e.stop;delete e.stop,t(n)};return"string"!=typeof e&&(n=t,t=e,e=void 0),t&&!1!==e&&this.queue(e||"fx",[]),this.each(function(){var t=!0,i=null!=e&&e+"queueHooks",o=ge.timers,a=Oe.get(this);if(i)a[i]&&a[i].stop&&r(a[i]);else for(i in a)a[i]&&a[i].stop&&vt.test(i)&&r(a[i]);for(i=o.length;i--;)o[i].elem!==this||null!=e&&o[i].queue!==e||(o[i].anim.stop(n),t=!1,o.splice(i,1));!t&&n||ge.dequeue(this,e)})},finish:function(e){return!1!==e&&(e=e||"fx"),this.each(function(){var t,n=Oe.get(this),r=n[e+"queue"],i=n[e+"queueHooks"],o=ge.timers,a=r?r.length:0;for(n.finish=!0,ge.queue(this,e,[]),i&&i.stop&&i.stop.call(this,!0),t=o.length;t--;)o[t].elem===this&&o[t].queue===e&&(o[t].anim.stop(!0),o.splice(t,1));for(t=0;t<a;t++)r[t]&&r[t].finish&&r[t].finish.call(this);delete n.finish})}}),ge.each(["toggle","show","hide"],function(e,t){var n=ge.fn[t];ge.fn[t]=function(e,r,i){return null==e||"boolean"==typeof e?n.apply(this,arguments):this.animate($(t,!0),e,r,i)}}),ge.each({slideDown:$("show"),
slideUp:$("hide"),slideToggle:$("toggle"),fadeIn:{opacity:"show"},fadeOut:{opacity:"hide"},fadeToggle:{opacity:"toggle"}},function(e,t){ge.fn[e]=function(e,n,r){return this.animate(t,e,n,r)}}),ge.timers=[],ge.fx.tick=function(){var e,t=0,n=ge.timers;for(ht=ge.now();t<n.length;t++)(e=n[t])()||n[t]!==e||n.splice(t--,1);n.length||ge.fx.stop(),ht=void 0},ge.fx.timer=function(e){ge.timers.push(e),ge.fx.start()},ge.fx.interval=13,ge.fx.start=function(){gt||(gt=!0,W())},ge.fx.stop=function(){gt=null},ge.fx.speeds={slow:600,fast:200,_default:400},ge.fn.delay=function(t,n){return t=ge.fx?ge.fx.speeds[t]||t:t,n=n||"fx",this.queue(n,function(n,r){var i=e.setTimeout(n,t);r.stop=function(){e.clearTimeout(i)}})},function(){var e=ne.createElement("input"),t=ne.createElement("select"),n=t.appendChild(ne.createElement("option"));e.type="checkbox",de.checkOn=""!==e.value,de.optSelected=n.selected,e=ne.createElement("input"),e.value="t",e.type="radio",de.radioValue="t"===e.value}();var yt,xt=ge.expr.attrHandle;ge.fn.extend({attr:function(e,t){return He(this,ge.attr,e,t,arguments.length>1)},removeAttr:function(e){return this.each(function(){ge.removeAttr(this,e)})}}),ge.extend({attr:function(e,t,n){var r,i,o=e.nodeType;if(3!==o&&8!==o&&2!==o)return"undefined"==typeof e.getAttribute?ge.prop(e,t,n):(1===o&&ge.isXMLDoc(e)||(i=ge.attrHooks[t.toLowerCase()]||(ge.expr.match.bool.test(t)?yt:void 0)),void 0!==n?null===n?void ge.removeAttr(e,t):i&&"set"in i&&void 0!==(r=i.set(e,n,t))?r:(e.setAttribute(t,n+""),n):i&&"get"in i&&null!==(r=i.get(e,t))?r:(r=ge.find.attr(e,t),null==r?void 0:r))},attrHooks:{type:{set:function(e,t){if(!de.radioValue&&"radio"===t&&i(e,"input")){var n=e.value;return e.setAttribute("type",t),n&&(e.value=n),t}}}},removeAttr:function(e,t){var n,r=0,i=t&&t.match(Ae);if(i&&1===e.nodeType)for(;n=i[r++];)e.removeAttribute(n)}}),yt={set:function(e,t,n){return!1===t?ge.removeAttr(e,n):e.setAttribute(n,n),n}},ge.each(ge.expr.match.bool.source.match(/\w+/g),function(e,t){var n=xt[t]||ge.find.attr;xt[t]=function(e,t,r){var i,o,a=t.toLowerCase();return r||(o=xt[a],xt[a]=i,i=null!=n(e,t,r)?a:null,xt[a]=o),i}});var bt=/^(?:input|select|textarea|button)$/i,wt=/^(?:a|area)$/i;ge.fn.extend({prop:function(e,t){return He(this,ge.prop,e,t,arguments.length>1)},removeProp:function(e){return this.each(function(){delete this[ge.propFix[e]||e]})}}),ge.extend({prop:function(e,t,n){var r,i,o=e.nodeType;if(3!==o&&8!==o&&2!==o)return 1===o&&ge.isXMLDoc(e)||(t=ge.propFix[t]||t,i=ge.propHooks[t]),void 0!==n?i&&"set"in i&&void 0!==(r=i.set(e,n,t))?r:e[t]=n:i&&"get"in i&&null!==(r=i.get(e,t))?r:e[t]},propHooks:{tabIndex:{get:function(e){var t=ge.find.attr(e,"tabindex");return t?parseInt(t,10):bt.test(e.nodeName)||wt.test(e.nodeName)&&e.href?0:-1}}},propFix:{"for":"htmlFor","class":"className"}}),de.optSelected||(ge.propHooks.selected={get:function(e){var t=e.parentNode;return t&&t.parentNode&&t.parentNode.selectedIndex,null},set:function(e){var t=e.parentNode;t&&(t.selectedIndex,t.parentNode&&t.parentNode.selectedIndex)}}),ge.each(["tabIndex","readOnly","maxLength","cellSpacing","cellPadding","rowSpan","colSpan","useMap","frameBorder","contentEditable"],function(){ge.propFix[this.toLowerCase()]=this}),ge.fn.extend({addClass:function(e){var t,n,r,i,o,a,s,u=0;if(ge.isFunction(e))return this.each(function(t){ge(this).addClass(e.call(this,t,G(this)))});if("string"==typeof e&&e)for(t=e.match(Ae)||[];n=this[u++];)if(i=G(n),r=1===n.nodeType&&" "+V(i)+" "){for(a=0;o=t[a++];)r.indexOf(" "+o+" ")<0&&(r+=o+" ");s=V(r),i!==s&&n.setAttribute("class",s)}return this},removeClass:function(e){var t,n,r,i,o,a,s,u=0;if(ge.isFunction(e))return this.each(function(t){ge(this).removeClass(e.call(this,t,G(this)))});if(!arguments.length)return this.attr("class","");if("string"==typeof e&&e)for(t=e.match(Ae)||[];n=this[u++];)if(i=G(n),r=1===n.nodeType&&" "+V(i)+" "){for(a=0;o=t[a++];)for(;r.indexOf(" "+o+" ")>-1;)r=r.replace(" "+o+" "," ");s=V(r),i!==s&&n.setAttribute("class",s)}return this},toggleClass:function(e,t){var n=typeof e;return"boolean"==typeof t&&"string"===n?t?this.addClass(e):this.removeClass(e):ge.isFunction(e)?this.each(function(n){ge(this).toggleClass(e.call(this,n,G(this),t),t)}):this.each(function(){var t,r,i,o;if("string"===n)for(r=0,i=ge(this),o=e.match(Ae)||[];t=o[r++];)i.hasClass(t)?i.removeClass(t):i.addClass(t);else void 0!==e&&"boolean"!==n||(t=G(this),t&&Oe.set(this,"__className__",t),this.setAttribute&&this.setAttribute("class",t||!1===e?"":Oe.get(this,"__className__")||""))})},hasClass:function(e){var t,n,r=0;for(t=" "+e+" ";n=this[r++];)if(1===n.nodeType&&(" "+V(G(n))+" ").indexOf(t)>-1)return!0;return!1}});var Tt=/\r/g;ge.fn.extend({val:function(e){var t,n,r,i=this[0];return arguments.length?(r=ge.isFunction(e),this.each(function(n){var i;1===this.nodeType&&(i=r?e.call(this,n,ge(this).val()):e,null==i?i="":"number"==typeof i?i+="":Array.isArray(i)&&(i=ge.map(i,function(e){return null==e?"":e+""})),(t=ge.valHooks[this.type]||ge.valHooks[this.nodeName.toLowerCase()])&&"set"in t&&void 0!==t.set(this,i,"value")||(this.value=i))})):i?(t=ge.valHooks[i.type]||ge.valHooks[i.nodeName.toLowerCase()],t&&"get"in t&&void 0!==(n=t.get(i,"value"))?n:(n=i.value,"string"==typeof n?n.replace(Tt,""):null==n?"":n)):void 0}}),ge.extend({valHooks:{option:{get:function(e){var t=ge.find.attr(e,"value");return null!=t?t:V(ge.text(e))}},select:{get:function(e){var t,n,r,o=e.options,a=e.selectedIndex,s="select-one"===e.type,u=s?null:[],l=s?a+1:o.length;for(r=a<0?l:s?a:0;r<l;r++)if(n=o[r],(n.selected||r===a)&&!n.disabled&&(!n.parentNode.disabled||!i(n.parentNode,"optgroup"))){if(t=ge(n).val(),s)return t;u.push(t)}return u},set:function(e,t){for(var n,r,i=e.options,o=ge.makeArray(t),a=i.length;a--;)r=i[a],(r.selected=ge.inArray(ge.valHooks.option.get(r),o)>-1)&&(n=!0);return n||(e.selectedIndex=-1),o}}}}),ge.each(["radio","checkbox"],function(){ge.valHooks[this]={set:function(e,t){if(Array.isArray(t))return e.checked=ge.inArray(ge(e).val(),t)>-1}},de.checkOn||(ge.valHooks[this].get=function(e){return null===e.getAttribute("value")?"on":e.value})});var Ct=/^(?:focusinfocus|focusoutblur)$/;ge.extend(ge.event,{trigger:function(t,n,r,i){var o,a,s,u,l,c,f,p=[r||ne],d=ce.call(t,"type")?t.type:t,h=ce.call(t,"namespace")?t.namespace.split("."):[];if(a=s=r=r||ne,3!==r.nodeType&&8!==r.nodeType&&!Ct.test(d+ge.event.triggered)&&(d.indexOf(".")>-1&&(h=d.split("."),d=h.shift(),h.sort()),l=d.indexOf(":")<0&&"on"+d,t=t[ge.expando]?t:new ge.Event(d,"object"==typeof t&&t),t.isTrigger=i?2:3,t.namespace=h.join("."),t.rnamespace=t.namespace?new RegExp("(^|\\.)"+h.join("\\.(?:.*\\.|)")+"(\\.|$)"):null,t.result=void 0,t.target||(t.target=r),n=null==n?[t]:ge.makeArray(n,[t]),f=ge.event.special[d]||{},i||!f.trigger||!1!==f.trigger.apply(r,n))){if(!i&&!f.noBubble&&!ge.isWindow(r)){for(u=f.delegateType||d,Ct.test(u+d)||(a=a.parentNode);a;a=a.parentNode)p.push(a),s=a;s===(r.ownerDocument||ne)&&p.push(s.defaultView||s.parentWindow||e)}for(o=0;(a=p[o++])&&!t.isPropagationStopped();)t.type=o>1?u:f.bindType||d,c=(Oe.get(a,"events")||{})[t.type]&&Oe.get(a,"handle"),c&&c.apply(a,n),(c=l&&a[l])&&c.apply&&Fe(a)&&(t.result=c.apply(a,n),!1===t.result&&t.preventDefault());return t.type=d,i||t.isDefaultPrevented()||f._default&&!1!==f._default.apply(p.pop(),n)||!Fe(r)||l&&ge.isFunction(r[d])&&!ge.isWindow(r)&&(s=r[l],s&&(r[l]=null),ge.event.triggered=d,r[d](),ge.event.triggered=void 0,s&&(r[l]=s)),t.result}},simulate:function(e,t,n){var r=ge.extend(new ge.Event,n,{type:e,isSimulated:!0});ge.event.trigger(r,null,t)}}),ge.fn.extend({trigger:function(e,t){return this.each(function(){ge.event.trigger(e,t,this)})},triggerHandler:function(e,t){var n=this[0];if(n)return ge.event.trigger(e,t,n,!0)}}),ge.each("blur focus focusin focusout resize scroll click dblclick mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave change select submit keydown keypress keyup contextmenu".split(" "),function(e,t){ge.fn[t]=function(e,n){return arguments.length>0?this.on(t,null,e,n):this.trigger(t)}}),ge.fn.extend({hover:function(e,t){return this.mouseenter(e).mouseleave(t||e)}}),de.focusin="onfocusin"in e,de.focusin||ge.each({focus:"focusin",blur:"focusout"},function(e,t){var n=function(e){ge.event.simulate(t,e.target,ge.event.fix(e))};ge.event.special[t]={setup:function(){var r=this.ownerDocument||this,i=Oe.access(r,t);i||r.addEventListener(e,n,!0),Oe.access(r,t,(i||0)+1)},teardown:function(){var r=this.ownerDocument||this,i=Oe.access(r,t)-1;i?Oe.access(r,t,i):(r.removeEventListener(e,n,!0),Oe.remove(r,t))}}});var Et=e.location,kt=ge.now(),Nt=/\?/;ge.parseXML=function(t){var n;if(!t||"string"!=typeof t)return null;try{n=(new e.DOMParser).parseFromString(t,"text/xml")}catch(e){n=void 0}return n&&!n.getElementsByTagName("parsererror").length||ge.error("Invalid XML: "+t),n};var St=/\[\]$/,Dt=/\r?\n/g,jt=/^(?:submit|button|image|reset|file)$/i,At=/^(?:input|select|textarea|keygen)/i;ge.param=function(e,t){var n,r=[],i=function(e,t){var n=ge.isFunction(t)?t():t;r[r.length]=encodeURIComponent(e)+"="+encodeURIComponent(null==n?"":n)};if(Array.isArray(e)||e.jquery&&!ge.isPlainObject(e))ge.each(e,function(){i(this.name,this.value)});else for(n in e)Y(n,e[n],t,i);return r.join("&")},ge.fn.extend({serialize:function(){return ge.param(this.serializeArray())},serializeArray:function(){return this.map(function(){var e=ge.prop(this,"elements");return e?ge.makeArray(e):this}).filter(function(){var e=this.type;return this.name&&!ge(this).is(":disabled")&&At.test(this.nodeName)&&!jt.test(e)&&(this.checked||!Xe.test(e))}).map(function(e,t){var n=ge(this).val();return null==n?null:Array.isArray(n)?ge.map(n,function(e){return{name:t.name,value:e.replace(Dt,"\r\n")}}):{name:t.name,value:n.replace(Dt,"\r\n")}}).get()}});var qt=/%20/g,Lt=/#.*$/,Ht=/([?&])_=[^&]*/,Ft=/^(.*?):[ \t]*([^\r\n]*)$/gm,Ot=/^(?:about|app|app-storage|.+-extension|file|res|widget):$/,Pt=/^(?:GET|HEAD)$/,Rt=/^\/\//,It={},Mt={},Wt="*/".concat("*"),Bt=ne.createElement("a");Bt.href=Et.href,ge.extend({active:0,lastModified:{},etag:{},ajaxSettings:{url:Et.href,type:"GET",isLocal:Ot.test(Et.protocol),global:!0,processData:!0,async:!0,contentType:"application/x-www-form-urlencoded; charset=UTF-8",accepts:{"*":Wt,text:"text/plain",html:"text/html",xml:"application/xml, text/xml",json:"application/json, text/javascript"},contents:{xml:/\bxml\b/,html:/\bhtml/,json:/\bjson\b/},responseFields:{xml:"responseXML",text:"responseText",json:"responseJSON"},converters:{"* text":String,"text html":!0,"text json":JSON.parse,"text xml":ge.parseXML},flatOptions:{url:!0,context:!0}},ajaxSetup:function(e,t){return t?K(K(e,ge.ajaxSettings),t):K(ge.ajaxSettings,e)},ajaxPrefilter:Q(It),ajaxTransport:Q(Mt),ajax:function(t,n){function r(t,n,r,s){var l,p,d,b,w,T=n;c||(c=!0,u&&e.clearTimeout(u),i=void 0,a=s||"",C.readyState=t>0?4:0,l=t>=200&&t<300||304===t,r&&(b=Z(h,C,r)),b=ee(h,b,C,l),l?(h.ifModified&&(w=C.getResponseHeader("Last-Modified"),w&&(ge.lastModified[o]=w),(w=C.getResponseHeader("etag"))&&(ge.etag[o]=w)),204===t||"HEAD"===h.type?T="nocontent":304===t?T="notmodified":(T=b.state,p=b.data,d=b.error,l=!d)):(d=T,!t&&T||(T="error",t<0&&(t=0))),C.status=t,C.statusText=(n||T)+"",l?v.resolveWith(g,[p,T,C]):v.rejectWith(g,[C,T,d]),C.statusCode(x),x=void 0,f&&m.trigger(l?"ajaxSuccess":"ajaxError",[C,h,l?p:d]),y.fireWith(g,[C,T]),f&&(m.trigger("ajaxComplete",[C,h]),--ge.active||ge.event.trigger("ajaxStop")))}"object"==typeof t&&(n=t,t=void 0),n=n||{};var i,o,a,s,u,l,c,f,p,d,h=ge.ajaxSetup({},n),g=h.context||h,m=h.context&&(g.nodeType||g.jquery)?ge(g):ge.event,v=ge.Deferred(),y=ge.Callbacks("once memory"),x=h.statusCode||{},b={},w={},T="canceled",C={readyState:0,getResponseHeader:function(e){var t;if(c){if(!s)for(s={};t=Ft.exec(a);)s[t[1].toLowerCase()]=t[2];t=s[e.toLowerCase()]}return null==t?null:t},getAllResponseHeaders:function(){return c?a:null},setRequestHeader:function(e,t){return null==c&&(e=w[e.toLowerCase()]=w[e.toLowerCase()]||e,b[e]=t),this},overrideMimeType:function(e){return null==c&&(h.mimeType=e),this},statusCode:function(e){var t;if(e)if(c)C.always(e[C.status]);else for(t in e)x[t]=[x[t],e[t]];return this},abort:function(e){var t=e||T;return i&&i.abort(t),r(0,t),this}};if(v.promise(C),h.url=((t||h.url||Et.href)+"").replace(Rt,Et.protocol+"//"),h.type=n.method||n.type||h.method||h.type,h.dataTypes=(h.dataType||"*").toLowerCase().match(Ae)||[""],null==h.crossDomain){l=ne.createElement("a");try{l.href=h.url,l.href=l.href,h.crossDomain=Bt.protocol+"//"+Bt.host!=l.protocol+"//"+l.host}catch(e){h.crossDomain=!0}}if(h.data&&h.processData&&"string"!=typeof h.data&&(h.data=ge.param(h.data,h.traditional)),J(It,h,n,C),c)return C;f=ge.event&&h.global,f&&0==ge.active++&&ge.event.trigger("ajaxStart"),h.type=h.type.toUpperCase(),h.hasContent=!Pt.test(h.type),o=h.url.replace(Lt,""),h.hasContent?h.data&&h.processData&&0===(h.contentType||"").indexOf("application/x-www-form-urlencoded")&&(h.data=h.data.replace(qt,"+")):(d=h.url.slice(o.length),h.data&&(o+=(Nt.test(o)?"&":"?")+h.data,delete h.data),!1===h.cache&&(o=o.replace(Ht,"$1"),d=(Nt.test(o)?"&":"?")+"_="+kt+++d),h.url=o+d),h.ifModified&&(ge.lastModified[o]&&C.setRequestHeader("If-Modified-Since",ge.lastModified[o]),ge.etag[o]&&C.setRequestHeader("If-None-Match",ge.etag[o])),(h.data&&h.hasContent&&!1!==h.contentType||n.contentType)&&C.setRequestHeader("Content-Type",h.contentType),C.setRequestHeader("Accept",h.dataTypes[0]&&h.accepts[h.dataTypes[0]]?h.accepts[h.dataTypes[0]]+("*"!==h.dataTypes[0]?", "+Wt+"; q=0.01":""):h.accepts["*"]);for(p in h.headers)C.setRequestHeader(p,h.headers[p]);if(h.beforeSend&&(!1===h.beforeSend.call(g,C,h)||c))return C.abort();if(T="abort",y.add(h.complete),C.done(h.success),C.fail(h.error),i=J(Mt,h,n,C)){if(C.readyState=1,f&&m.trigger("ajaxSend",[C,h]),c)return C;h.async&&h.timeout>0&&(u=e.setTimeout(function(){C.abort("timeout")},h.timeout));try{c=!1,i.send(b,r)}catch(e){if(c)throw e;r(-1,e)}}else r(-1,"No Transport");return C},getJSON:function(e,t,n){return ge.get(e,t,n,"json")},getScript:function(e,t){return ge.get(e,void 0,t,"script")}}),ge.each(["get","post"],function(e,t){ge[t]=function(e,n,r,i){return ge.isFunction(n)&&(i=i||r,r=n,n=void 0),ge.ajax(ge.extend({url:e,type:t,dataType:i,data:n,success:r},ge.isPlainObject(e)&&e))}}),ge._evalUrl=function(e){return ge.ajax({url:e,type:"GET",dataType:"script",cache:!0,async:!1,global:!1,"throws":!0})},ge.fn.extend({wrapAll:function(e){var t;return this[0]&&(ge.isFunction(e)&&(e=e.call(this[0])),t=ge(e,this[0].ownerDocument).eq(0).clone(!0),this[0].parentNode&&t.insertBefore(this[0]),t.map(function(){for(var e=this;e.firstElementChild;)e=e.firstElementChild;return e}).append(this)),this},wrapInner:function(e){return ge.isFunction(e)?this.each(function(t){ge(this).wrapInner(e.call(this,t))}):this.each(function(){var t=ge(this),n=t.contents();n.length?n.wrapAll(e):t.append(e)})},wrap:function(e){var t=ge.isFunction(e);return this.each(function(n){ge(this).wrapAll(t?e.call(this,n):e)})},unwrap:function(e){return this.parent(e).not("body").each(function(){ge(this).replaceWith(this.childNodes)}),this}}),ge.expr.pseudos.hidden=function(e){return!ge.expr.pseudos.visible(e)},ge.expr.pseudos.visible=function(e){return!!(e.offsetWidth||e.offsetHeight||e.getClientRects().length)},ge.ajaxSettings.xhr=function(){try{return new e.XMLHttpRequest}catch(e){}};var $t={0:200,1223:204},_t=ge.ajaxSettings.xhr();de.cors=!!_t&&"withCredentials"in _t,de.ajax=_t=!!_t,ge.ajaxTransport(function(t){var n,r;if(de.cors||_t&&!t.crossDomain)return{send:function(i,o){var a,s=t.xhr();if(s.open(t.type,t.url,t.async,t.username,t.password),t.xhrFields)for(a in t.xhrFields)s[a]=t.xhrFields[a];t.mimeType&&s.overrideMimeType&&s.overrideMimeType(t.mimeType),t.crossDomain||i["X-Requested-With"]||(i["X-Requested-With"]="XMLHttpRequest");for(a in i)s.setRequestHeader(a,i[a]);n=function(e){return function(){n&&(n=r=s.onload=s.onerror=s.onabort=s.onreadystatechange=null,"abort"===e?s.abort():"error"===e?"number"!=typeof s.status?o(0,"error"):o(s.status,s.statusText):o($t[s.status]||s.status,s.statusText,"text"!==(s.responseType||"text")||"string"!=typeof s.responseText?{binary:s.response}:{text:s.responseText},s.getAllResponseHeaders()))}},s.onload=n(),r=s.onerror=n("error"),void 0!==s.onabort?s.onabort=r:s.onreadystatechange=function(){4===s.readyState&&e.setTimeout(function(){n&&r()})},n=n("abort");try{s.send(t.hasContent&&t.data||null)}catch(e){if(n)throw e}},abort:function(){n&&n()}}}),ge.ajaxPrefilter(function(e){e.crossDomain&&(e.contents.script=!1)}),ge.ajaxSetup({accepts:{script:"text/javascript, application/javascript, application/ecmascript, application/x-ecmascript"},contents:{script:/\b(?:java|ecma)script\b/},converters:{"text script":function(e){return ge.globalEval(e),e}}}),ge.ajaxPrefilter("script",function(e){void 0===e.cache&&(e.cache=!1),e.crossDomain&&(e.type="GET")}),ge.ajaxTransport("script",function(e){if(e.crossDomain){var t,n;return{send:function(r,i){t=ge("<script>").prop({charset:e.scriptCharset,src:e.url}).on("load error",n=function(e){t.remove(),n=null,e&&i("error"===e.type?404:200,e.type)}),ne.head.appendChild(t[0])},abort:function(){n&&n()}}}});var zt=[],Xt=/(=)\?(?=&|$)|\?\?/;ge.ajaxSetup({jsonp:"callback",jsonpCallback:function(){var e=zt.pop()||ge.expando+"_"+kt++;return this[e]=!0,e}}),ge.ajaxPrefilter("json jsonp",function(t,n,r){var i,o,a,s=!1!==t.jsonp&&(Xt.test(t.url)?"url":"string"==typeof t.data&&0===(t.contentType||"").indexOf("application/x-www-form-urlencoded")&&Xt.test(t.data)&&"data");if(s||"jsonp"===t.dataTypes[0])return i=t.jsonpCallback=ge.isFunction(t.jsonpCallback)?t.jsonpCallback():t.jsonpCallback,s?t[s]=t[s].replace(Xt,"$1"+i):!1!==t.jsonp&&(t.url+=(Nt.test(t.url)?"&":"?")+t.jsonp+"="+i),t.converters["script json"]=function(){return a||ge.error(i+" was not called"),a[0]},t.dataTypes[0]="json",o=e[i],e[i]=function(){a=arguments},r.always(function(){void 0===o?ge(e).removeProp(i):e[i]=o,t[i]&&(t.jsonpCallback=n.jsonpCallback,zt.push(i)),a&&ge.isFunction(o)&&o(a[0]),a=o=void 0}),"script"}),de.createHTMLDocument=function(){var e=ne.implementation.createHTMLDocument("").body;return e.innerHTML="<form></form><form></form>",2===e.childNodes.length}(),ge.parseHTML=function(e,t,n){if("string"!=typeof e)return[];"boolean"==typeof t&&(n=t,t=!1);var r,i,o;return t||(de.createHTMLDocument?(t=ne.implementation.createHTMLDocument(""),r=t.createElement("base"),r.href=ne.location.href,t.head.appendChild(r)):t=ne),i=Ee.exec(e),o=!n&&[],i?[t.createElement(i[1])]:(i=b([e],t,o),o&&o.length&&ge(o).remove(),ge.merge([],i.childNodes))},ge.fn.load=function(e,t,n){var r,i,o,a=this,s=e.indexOf(" ");return s>-1&&(r=V(e.slice(s)),e=e.slice(0,s)),ge.isFunction(t)?(n=t,t=void 0):t&&"object"==typeof t&&(i="POST"),a.length>0&&ge.ajax({url:e,type:i||"GET",dataType:"html",data:t}).done(function(e){o=arguments,a.html(r?ge("<div>").append(ge.parseHTML(e)).find(r):e)}).always(n&&function(e,t){a.each(function(){n.apply(this,o||[e.responseText,t,e])})}),this},ge.each(["ajaxStart","ajaxStop","ajaxComplete","ajaxError","ajaxSuccess","ajaxSend"],function(e,t){ge.fn[t]=function(e){return this.on(t,e)}}),ge.expr.pseudos.animated=function(e){return ge.grep(ge.timers,function(t){return e===t.elem}).length},ge.offset={setOffset:function(e,t,n){var r,i,o,a,s,u,l,c=ge.css(e,"position"),f=ge(e),p={};"static"===c&&(e.style.position="relative"),s=f.offset(),o=ge.css(e,"top"),u=ge.css(e,"left"),l=("absolute"===c||"fixed"===c)&&(o+u).indexOf("auto")>-1,l?(r=f.position(),a=r.top,i=r.left):(a=parseFloat(o)||0,i=parseFloat(u)||0),ge.isFunction(t)&&(t=t.call(e,n,ge.extend({},s))),null!=t.top&&(p.top=t.top-s.top+a),null!=t.left&&(p.left=t.left-s.left+i),"using"in t?t.using.call(e,p):f.css(p)}},ge.fn.extend({offset:function(e){if(arguments.length)return void 0===e?this:this.each(function(t){ge.offset.setOffset(this,e,t)});var t,n,r,i,o=this[0];return o?o.getClientRects().length?(r=o.getBoundingClientRect(),t=o.ownerDocument,n=t.documentElement,i=t.defaultView,{top:r.top+i.pageYOffset-n.clientTop,left:r.left+i.pageXOffset-n.clientLeft}):{top:0,left:0}:void 0},position:function(){if(this[0]){var e,t,n=this[0],r={top:0,left:0};return"fixed"===ge.css(n,"position")?t=n.getBoundingClientRect():(e=this.offsetParent(),t=this.offset(),i(e[0],"html")||(r=e.offset()),r={top:r.top+ge.css(e[0],"borderTopWidth",!0),left:r.left+ge.css(e[0],"borderLeftWidth",!0)}),{top:t.top-r.top-ge.css(n,"marginTop",!0),left:t.left-r.left-ge.css(n,"marginLeft",!0)}}},offsetParent:function(){return this.map(function(){for(var e=this.offsetParent;e&&"static"===ge.css(e,"position");)e=e.offsetParent;return e||Qe})}}),ge.each({scrollLeft:"pageXOffset",scrollTop:"pageYOffset"},function(e,t){var n="pageYOffset"===t;ge.fn[e]=function(r){return He(this,function(e,r,i){var o;return ge.isWindow(e)?o=e:9===e.nodeType&&(o=e.defaultView),void 0===i?o?o[t]:e[r]:void(o?o.scrollTo(n?o.pageXOffset:i,n?i:o.pageYOffset):e[r]=i)},e,r,arguments.length)}}),ge.each(["top","left"],function(e,t){ge.cssHooks[t]=H(de.pixelPosition,function(e,n){if(n)return n=L(e,t),at.test(n)?ge(e).position()[t]+"px":n})}),ge.each({Height:"height",Width:"width"},function(e,t){ge.each({padding:"inner"+e,content:t,"":"outer"+e},function(n,r){ge.fn[r]=function(i,o){var a=arguments.length&&(n||"boolean"!=typeof i),s=n||(!0===i||!0===o?"margin":"border");return He(this,function(t,n,i){var o;return ge.isWindow(t)?0===r.indexOf("outer")?t["inner"+e]:t.document.documentElement["client"+e]:9===t.nodeType?(o=t.documentElement,Math.max(t.body["scroll"+e],o["scroll"+e],t.body["offset"+e],o["offset"+e],o["client"+e])):void 0===i?ge.css(t,n,s):ge.style(t,n,i,s)},t,a?i:void 0,a)}})}),ge.fn.extend({bind:function(e,t,n){return this.on(e,null,t,n)},unbind:function(e,t){return this.off(e,null,t)},delegate:function(e,t,n,r){return this.on(t,e,n,r)},undelegate:function(e,t,n){return 1===arguments.length?this.off(e,"**"):this.off(t,e||"**",n)}}),ge.holdReady=function(e){e?ge.readyWait++:ge.ready(!0)},ge.isArray=Array.isArray,ge.parseJSON=JSON.parse,ge.nodeName=i,"function"==typeof define&&define.amd&&define("jquery",[],function(){return ge});var Ut=e.jQuery,Vt=e.$;return ge.noConflict=function(t){return e.$===ge&&(e.$=Vt),t&&e.jQuery===ge&&(e.jQuery=Ut),ge},t||(e.jQuery=e.$=ge),ge});</script> <script>function defer(e){window.jQuery?e():setTimeout(function(){defer(e)},5)}function defer(e){window.jQuery?e():setTimeout(function(){defer(e)},5)}"function"!=typeof Object.create&&(Object.create=function(e){function t(){}return t.prototype=e,new t}),defer(function(){!function(e,t,a,n){"use strict";var i={init:function(t,a){var n=this;n.elem=a,n.$elem=e(a),n.opt=e.extend({},this.opt,t),n.headers=n.$elem.find(n.opt.headers),n.previous=0,0!==n.headers.length&&(n.first=parseInt(n.headers.prop("nodeName").substring(1),null)),n.build()},opt:{navigation:".anchorific",headers:"h1, h2, h3, h4, h5, h6",speed:200,anchorClass:"anchor",anchorText:"#",top:".top",spy:!0,position:"append",spyOffset:!0},build:function(){var t,a=this,n=function(){};a.opt.navigation&&(e(a.opt.navigation).append("<ul />"),a.previous=e(a.opt.navigation).find("ul").last(),n=function(e){return a.navigations(e)});for(var i=0;i<a.headers.length;i++)t=a.headers.eq(i),n(t),a.anchor(t);a.opt.spy&&a.spy(),a.opt.top&&a.back()},navigations:function(t){var a,i,s,o=this,r=o.name(t);t.attr("id")!==n&&(r=t.attr("id")),a=e("<a />").attr("href","#"+r).text(t.text()),i=e("<li />").append(a),s=parseInt(t.prop("nodeName").substring(1),null),i.attr("data-tag",s),o.subheadings(s,i),o.first=s},subheadings:function(t,a){var n=this,i=(e(n.opt.navigation).find("ul"),e(n.opt.navigation).find("li"));t===n.first?n.previous.append(a):t>n.first?(i.last().append("<ul />"),e(n.opt.navigation).find("ul").last().append(a),n.previous=a.parent()):(e("li[data-tag="+t+"]").last().parent().append(a),n.previous=a.parent())},name:function(e){return e.text().replace(/[^\w\s]/gi,"").replace(/\s+/g,"-").toLowerCase()},anchor:function(e){var t,a=this,i=a.name(e);a.opt.anchorText,a.opt.anchorClass,e.attr("id")===n&&e.attr("id",i),t=e.attr("id"),e.html('<a class="anchor" href=#'+t+">"+e.html()+"</a>")},back:function(){var t=this,a=e("body, html");e(t.opt.top).on("click",function(e){e.preventDefault(),a.animate({scrollTop:0},t.opt.speed)})},top:function(t){var a=this,n=a.opt.top;!1!==n&&(e(t).scrollTop()>200?e(n).fadeIn():e(n).fadeOut())},spy:function(){var a,i,s,o=this;e(t).scroll(function(){o.top(this),a=o.headers.map(function(){return e(this).offset().top-e(t).scrollTop()<o.opt.spyOffset?this:n}),(a=e(a).eq(a.length-1))&&a.length&&(i=e('li:has(a[href="#'+a.attr("id")+'"])'),s!==n&&s.removeClass("active"),i.addClass("active"),s=i)})}};e.fn.anchorific=function(t){return this.each(function(){if(!e.data(this,"anchorific")){var a=Object.create(i);a.init(t,this),e.data(this,"anchorific",a)}})}}(jQuery,window,document)});var tipuesearch={pages:[{title:"Test Post",text:"Not much here. A few lines of text. Heading level 2 Bold fun test(): Int { return 0 }",tags:"Notes Haskell Functional",url:"/Test-Post"},{title:"Haskell Notes",
text:'This is a collection of notes on Haskell, primarily condensed from learnyouahaskell Purely functional languages In a purely functional language, functions can have no side effects. This means that if a function is called twice with the same parameters, it is guaranteed to return the same result. This is called referential transparency and allows the compiler to reason about program behaviour, as well as proof that a function is correct. Lazy evaluation Functions will not be called and calculations will not be performed until a result is required. Programs can be thought of as a series of transformations on data. This allows structures such as infinite lists, which are only evaluated when required. Example: An infinite list of natural numbers can be generated as follows &gt; let naturals = 1 : map (+1) naturals When we want to use these values we can write &gt; take 10 naturals &gt; [1,2,3,4,5,6,7,8,9,10] We could more succinctly use the notation for a range &gt; let naturals = [1..] This gives the same infinite range as before. Static typing Haskell is a statically typed language, meaning that when it is compiled the compiler knows the type of every value. Type inference Haskell, along with many other languages, use a system of type inference. This means that when writing a = 2 + 3 it is not necessary to inform the compiler that a is a numeric value. If a function takes two parameters and adds them together, their types do not need to be stated explicitly. The function will can be executed with any two parameters that act like numbers. Basic syntax Examples: Arithmetic &gt; 3 + 16 &gt; 19 &gt; 27 * 53 &gt; 1431 &gt; 1314 - 133 &gt; 1181 &gt; 7 / 2 &gt; 3.5 When multiple operators are used on the same line, operator precedence and parentheses are respected. Negation When value are negated, they must be surrounded by parentheses. &gt; 5 * -3 The expression above will give a Precedence parsing error. Instead 5 * (-3) should be written Examples: Boolean algebra Operator Symbol And &amp;&amp; Or || Not not Equality == Inequality /= &gt; True &amp;&amp; False &gt; False &gt; True &amp;&amp; not False &gt; True &gt; False || True &gt; True &gt; not (True &amp;&amp; True) &gt; False &gt; True == False &gt; False &gt; 5 == 5 &gt; True &gt; 1 == 0 &gt; False &gt; 5 /= 5 &gt; False &gt; 5 /= 4 &gt; "string" == "string" &gt; True Functions All of the operations performed so far have been functions, specifically infix functions. Functions are usually prefix functions, which take their arguments after the function name. Infix functions are different in that the arguments surround the function name. Example: The successor function &gt; succ 9 &gt; 10 The successor function takes anything which has a defined successor, and returns that successor. The min and max functions both take two parameters &gt; min 10 11 &gt; 10 &gt; max 100 1000 &gt; 1000 &gt; min 1.5 1.4 &gt; 1.4 Function application as seen above has the highest precedence This means that the following statements are equivalent &gt; succ 9 + max 5 4 + 1 &gt; (succ 9) + (max 5 4) + 1 Suppose we want the successor to the product of two numbers, a, and b. As succ has the highest precedence writing succ a * b would first evaluate succ a and then evaluate its product with b. Instead we must right succ (a * b). Writing functions as infix If a function takes two parameters, it can be called as an infix function by surrounding it with backticks. div takes two integers and performs integral division. &gt; 92 `div` 9 &gt; 10 Function call syntax Many other languages require parentheses to denote function application. In Haskell, spaces are used instead. Function definition doubleValue x = x + x The function above consists of a function name, followed by parameters separated by spaces. After the = the function body is defined. This function will work on any numeric type. &gt; doubleValue 2 &gt; 4 &gt; doubleValue 2.5 &gt; 5 doubleSum x y = x * 2 + y * 2 This function takes two numeric parameters, doubles each of them, and returns the sum of the two doubled values. &gt; doubleSum 2 3 &gt; 10 &gt; doubleSum 5.5 7 &gt; 25.0 The function can take two numeric types, one of which is floating point and the other an integer. This will result in the integer type being converted to a floating point value. The function could also be defined in terms of the first function, doubleValue. doubleSum x y = doubleValue x + doubleValue y Function definitions do not have to be in any particular order, doubleSum could be defined before doubleValue. Conditional expressions doubleSmallNumber x = if x &gt; 100 then x else x * 2 The function doubleSmallNumber doubles the parameter x if x&lt;=100, otherwise it returns the original value of x. An if statement in Haskell is an expression, a piece of code which returns a value. Because the else is mandatory, an if statement will always return some value. If we wanted to add one to the return value in doubleSmallNumber we could write doubleSmallNumber\' x = (if x &gt; 100 then x else x * 2) + 1 Function naming The function above doubleSmallNumber\' has a \' character as its last character. This is a valid character in Haskell function names and is often used to denote a stricter, non-lazy version of a function, or a slightly modified version. Haskell functions cannot begin with uppercase characters. When a function does not take any parameters, it is called a definition or a name. Lists Lists are defined as comma separated lists of values within a set of square brackets []. A string is just syntax for a list of characters. As strings are backed by lists of characters, we can apply list functions to them. String and list concatenation Strings are concatenated with the ++ operator. &gt; "hello" ++ " " ++ "world" &gt; "hello world" This operator is used more widely for list concatenation. &gt; [1,2,3] ++ [4,5,6] &gt; [1,2,3,4,5,6] When two lists are added together, even when a singleton is added to the end of a list, Haskell has to walk through the whole list on the left side of the ++ operator which can be slow when dealing with large lists. Prepending to a list is effectively instantaneous. It is done with the : operator. &gt; \'A\' : "BC" &gt; "ABC" &gt; 5 : [4,3,2,1] &gt; [5,4,3,2,1] Note that ++ takes two lists. This means that any singleton value being appended to a list must be a list containing one item, such as [5], rather than just 5. A list definition such as [1,2,3] is actually just syntactic sugar for 1:2:3:[], where [] is an empty list. List indexing As with any sensible language, Haskell lists are indexed from 0. The !! operator is used to read an element from a list at a given index. &gt; [1,2,3,4,5] !! 2 &gt; 3 &gt; "hello" !! 1 &gt; \'e\' Attempting to access an index which does not exist will raise an error. Nested lists Lists can be infinitely nested within memory constraints. &gt; let b = [[1,2,3,4],[5,3,3,3],[1,2,2,3,4],[1,2,3]] &gt; b &gt; [[1,2,3,4],[5,3,3,3],[1,2,2,3,4],[1,2,3]] &gt; b ++ [[1,1,1,1]] &gt; [[1,2,3,4],[5,3,3,3],[1,2,2,3,4],[1,2,3],[1,1,1,1]] &gt; [6,6,6]:b &gt; [[6,6,6],[1,2,3,4],[5,3,3,3],[1,2,2,3,4],[1,2,3]] &gt; b !! 2 &gt; [1,2,2,3,4] The nested lists can be of different dimensions, but they must be of the same type. List comparisons Lists can be compared if there is a method for comparing their contents. When using &lt;, &lt;=, &gt;, &gt;= to compare lists, their elements are compared in lexicographical order. First the head elements are compared, if they are equal the next elements are compared and so forth, until two elements are not equal, or one of the lists ends. &gt; [3,4,2] == [3,4,2] &gt; True &gt; [3,2,1] &gt; [2,10,100] &gt; True &gt; [3,4,2] &gt; [3,4] &gt; True List operations head takes a list as a parameter and returns its head, the first element &gt; head [10,9,8] &gt; 10 tail takes a list as a parameter and returns its tail, the elements past the first &gt; tail [10,9,8] &gt; [9,8] last takes a list as a parameter and returns its last element &gt; last [10,9,8] &gt; 8 init takes a list as a parameter and returns the elements before the last &gt; init [10,9,8] &gt; [10,9] The functions above will raise an exception if applied to an empty list. length takes a list as a parameter and returns its length, the number of elements &gt; length [1,2,3,4,5] &gt; 5 null takes a list as a parameter and returns True if the list is empty, and False otherwise &gt; null [] &gt; True &gt; null [1,2,3] &gt; False reverse takes a list as a parameter returns the reversed list &gt; reverse [5,4,3,2,1] &gt; [1,2,3,4,5] take takes an integer and a list as parameters and extracts that many elements from the list, returning them If we try to take more elements than there are in the list, it just returns the list without raising an exception. &gt; take 3 [5,4,3,2,1] &gt; [5,4,3] &gt; take 1 [3,9,3] &gt; [3] &gt; take 5 [1,2] &gt; [1,2] &gt; take 0 [6,5,4] &gt; [] drop takes an integer and list as parameters, and drops that many elements from the start of the list &gt; drop 3 [8,4,2,1,5,6] &gt; [1,5,6] &gt; drop 0 [4,3,2,1] &gt; [4,3,2,1] &gt; drop 100 [1,2,3,4] &gt; [] maximum takes an orderable list as a parameter and returns the largest element minimum takes an orderable list as a parameter and returns the smallest element &gt; minimum [8,4,2,1,5,6] &gt; 1 &gt; maximum [1,9,2,3,4] &gt; 9 sum takes a list of numbers as a parameter and returns their sum &gt; sum [1,2,3,4,5] &gt; 15 product takes a list of numbers as a parameter and returns their product &gt; product [1,2,3,4] &gt; 24 elem takes an instance of type T and a list of type T as parameters and returns true if the instance is contained within the list elem is usually called as an infix function because it is easier to read. &gt; 4 `elem` [3,4,5,6] &gt; True &gt; 10 `elem` [1,2,3] &gt; False Ranges Ranges are a method for making lists that are arithmetic sequences of elements that can be enumerated, such as numbers and characters. &gt; [1..20] &gt; [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20] &gt; [\'a\'..\'z\'] &gt; [\'a\',\'b\',\'c\',\'d\',\'e\',\'g\',\'h\',\'j\',\'k\',\'l\',\'m\',\'n\',\'o\',\'p\',\'q\',\'r\',\'s\',\'t\',\'u\',\'v\',\'w\',\'x\',\'y\',\'z\'] The step for a range can also be specified. &gt; [2,4..20] &gt; [2,4,6,8,10,12,14,16,18,20] To make a list of numbers in descending order from m to n you have to write &gt; [m,m-1..n] Production of infinite lists Infinite lists can be produced by neglecting to specify an upper bound for a range. cycle takes a list as a parameter and cycles it into an infinite list. &gt; take 10 (cycle [3,2,1]) &gt; [3,2,1,3,2,1,3,2,1,3] repeat takes an element as a parameter and produces an infinite list of just that element &gt; take 10 (repeat 6) &gt; [6,6,6,6,6,6,6,6,6,6] If you want some number of the same element in a list it is simpler to use replicate replicate takes a number and an element a returns a list containing that many of the element &gt; replicate 5 6 &gt; [5,5,5,5,5,5] List comprehension Set comprehensions are often used for building specific sets from general sets. The part before the pipe is called the output function, is the variable, is the input set and is the the predicate. The set contains the doubles of all the values that satisfy the predicate. In Haskell we could write take 10 [2,4,..] but this would produce doubles of the first 10 natural numbers. A list comprehension should be used instead. &gt; [x*2 | x &lt;- [1..10]] &gt; [2,4,6,8,10,12,14,16,18,20] We can also add a predicate to the comprehension &gt; [x*2 | x &lt;- [1..10], x*2 &gt;= 12] &gt; [12,14,16,18,20] Suppose we want to all the numbers from 50 to 100 whose remainder when divided by the number 7 is 3. &gt; [x | x &lt;- [50,100], x `mod` 7 ==3] &gt; [52,59,66,73,80,87,94] This process is called filtering. We took a list and filtered it by the predicate. Now suppose we want to replace each odd number greater than 10 the string "BANG!" and each odd number less than 10 with "BOOM!". If a number isn\u2019t odd, we throw it out of our list. For convenience we can place out comprehension inside a function so that we can reuse it. &gt; let boomBang xs = [if x &lt; 10 then "BOOM!" else "BANG!" | x &lt;- xs, odd x] &gt; boomBang [7..13] &gt; ["BOOM!", "BOOM!", "BANG!", "BANG!"] We can include several predicates. A comprehension for numbers from 10 to 20 that are not 13, 15, or 19 can be written as. &gt; [x | x &lt;- [10..20], x /= 13, x /= 15, x /= 19] &gt; [10,11,12,14,16,17,18,20] Not only can we have multiple predicates in list comprehensions, we can also draw from multiple lists. A list produced by a comprehension that draws from two lists of lengths n and m respectively will have a length of n*m. If we have two lists, [2,5,10] and [8,10,11] and we wish to find the products of all the possible combinations between numbers in those lists, we can write &gt; [x*y | x &lt;- [2,5,10], y &lt;- [8,10,10]] &gt; [16,20,22,40,50,55,80,100,110] Now suppose that we want all possible products which are greater than 50 &gt; [x*y | x &lt;- [2,5,10], y &lt;- [8,10,10], x * y &gt; 50] &gt; [55,80,100,110] &gt; let nouns = ["hobo","frog","pope"] &gt; let adjectives = ["lazy","grouchy","scheming"] &gt; [adjective ++ " " ++ noun | adjective &lt;- adjectives, noun &lt;- nouns] &gt; ["lazy hobo","lazy frog","lazy pope","grouchy hobo","grouchy frog", "grouchy pope","scheming hobo","scheming frog","scheming pope"] We could use list comprehension to write a bad version of the length function. &gt; length` xs = sum [1 | _ &lt;- xs] This function replaces every element of the list with 1s and finds their sum. The underscore character, _, is used to denote a variable which is not used. Nested list comprehensions &gt; let xxs = [[1,3,5,2,3,1,2,4,5],[1,2,3,4,5,6,7,8,9].[1,2,4,2,1,6,3,1,3,2,3,6]] &gt; [[x | x &lt;- xs, even x] | xs &lt;- xxs] &gt; [[2,2,4],[2,4,6,8], [2,4,2,6,2,6]] The comprehension shown above applies a comprehension to each of the lists, within the outer list, filtering them to only even values. Tuples Tuples are similar to lists, providing a way to store several values in a single value. Tuples are used when the number of values you want to combine is known, and its type depends on how many components it has along with the type of the components. They are denoted with parentheses around a comma separated list of values. Unlike lists, tuples do not have to be homogeneous, meaning that they can contain several types. &gt; --List of tuples of the same type &gt; [(1,2),(3,4),(5,6)] &gt; --List of tuples of varying types -&gt; Error &gt; [(1,2),(3,"4"),(\'5\',6)] Tuples can contain lists. Tuples are much more rigid. A general function cannot be written to append an element to a tuple. There is no singleton tuple. This is because a singleton tuple would just be the value it contains and therefore provide no use. Tuple operations fst takes a pair and returns its first component &gt; fst (8,11) &gt; 8 snd takes a pair and returns its second component These functions only work on pairs. They will not work on triples, 4-tuples, 5-tuples etc. zip takes two lists and produces a list of pairs &gt; zip [1,2,3,4,5] [5,4,3,2,1] &gt; [(1,5),(2,4),(3,3),(4,2),(5,1)] &gt; zip [1..5] ["five", "four", "three", "two", "one"] &gt; [(1, "five"), (2, "four"), (3, "three"), (4, "two"), (5, "one")] If the lengths of the lists do not match the longer list is cut off and ignored past the length of the shorter list. We can apply zip to pairings of finite and infinite lists, or two infinite lists &gt; take 10 (zip [1..] [1,0..]) &gt; [(1,1),(2,0),(3,-1),(4,-2),(5,-3),(6,-4),(7,-5),(8,-6),(9,-7),(10,-8)] Types and typeclasses The :t command can be used to determine the type of an expression. &gt; :t \'a\' &gt; \'a\' :: Char &gt; :t True &gt; True :: Bool &gt; :t (True, \'a\') &gt; (True, \'a\') :: (Bool, Char) &gt; :t 4 == 5 &gt; 4 == 5 :: Bool :: should be read as \u2018has type of\u2019. Explicit types are always denoted with the first letter in capital case. Functions also have types. When writing functions, we can give an explicit type declaration. removeNonUpercase :: [Char] -&gt; [Char] removeNonUpercase st = [ c | c &lt;- st, c `elem` [\'A\'..\'Z\']] removeNonUpercase has a type of [Char] -&gt; [Char] as it maps a string to a string. We don\u2019t have to give this function a type decleration because the compiler can infer it, however it is still good practice to do so. addThree :: Int -&gt; Int -&gt; Int -&gt; Int addThree x y z = x + y + z The function above takes three parameters. The return type is the last item in the declaration and the parameters are the first three. Common types Int A 32 or 64 bit signed integer Integer A non-bounded integer Float A real floating point value with single precision Double A real floating point value with double precision Bool A boolean type, True or False Char Represents a single character Type variables head takes a list of any type and returns the first element &gt; :t head &gt; head :: [a] -&gt; a a is a type variable, meaning that it can be of any type. The type decleration of head means that it takes a list of some type a and returns a single instance of type a. This is much like generics in other languages. Functions that have type variables are called polymorphic functions. &gt; :t fst &gt; fst :: (a, b) -&gt; a fst takes a tuple which conatins two types, and returns an element which is of the same type as the first item in the pair. Note that despite the differing names of a and b they can be the same type. Typeclasses A typeclass behaves similarly to an interface. If a type is part of a typeclass, it supports and implements the behaviour that the typeclass describes. &gt; :t (==) &gt; (==) :: (Eq a) =&gt; a -&gt; a -&gt; -&gt; Bool The =&gt; symbol is called a class constraint. The euqality function takes any two values that are of the same type and returns a Bool. The class constraint is that the type of those two values must be a member of the Eq class. The Eq typeclass provides an interface for testing for equality. Any type where it makes sense to test for equality between two values of that type should be a member of the Eq class. All standard Haskell types except for IO and functions are part of the Eq typeclass. Consider the elem function which has a type of (Eq a) =&gt; a -&gt; [a] -&gt; Bool because it uses == over a list to check whether some value is contained. Common Typeclasses Eq Used for types that support equality testing. Members must implement == and /= Ord Used for types which have ordering. Ord covers &gt;, &lt;, &gt;=, and &lt;= The compare function takes two Ord members of the same type and returns an ordering. Ordering is a type that can be GT, LT, or EQ. To be a member of Ord, a type must first be a member of Eq Show Used for types that can be presented as strings. The most used function that deals with Show is show/ It takes a value whose type is a member of Show and presents it as a string. Read The read function takes a string and returns a type which is a member of Read &gt; read "True" || False &gt; True &gt; read "8.2" + 3.8 &gt; 12.0 &gt; read "[1,2,3,4]" ++ [3] &gt; [1,2,3,4,3] If we try read "4" an exception will be raised. &lt;interactive&gt;:1:0: Ambiguous type variable `a\' in the constraint: `Read a\' arising from a use of `read\' at &lt;interactive&gt;:1:0-7 Probable fix: add a type signature that fixes these type variable(s) The return type cannot be determined. Previously our use of the return value could be used to determine its type. &gt; :t read &gt; read :: (Read a) =&gt; String -&gt; a read returns a type that is part of Read, but if we do not use the value the type cannot be determined. We can use explicit type annotations to overcome this problem. &gt; read "5" :: Int &gt; 5 &gt; read "5" :: Float &gt; 5.0 &gt; read "(3, \'a\')" :: (Int, Char) &gt; (3, \'a\') Most expressions provide sufficient detail that the compiler can infer what their type is by itself. Enum Enum members are sequentially ordered types. The Enum typeclass can be used in list ranges. They also have defined successors and predecessors. (), Bool, Char, Ordering, Int, Integer, Float, and Double are in this class. &gt; [\'a\'..\'e\'] &gt; "abcde" &gt; [LT..GT] &gt; [LT, EQ, GT] &gt; succ \'B\' &gt; \'C\' Bounded Members of this typeclass have an upper and lower bound. Both minBound and maxBound have a type of (Bounded a) =&gt; a. Tuples are part of Bounded if all of their components are. &gt; minBound :: Int &gt; -2147483648 &gt; maxBound :: Bool &gt; True &gt; maxBound :: (Bool, Int, Char) &gt; (True, 2147483647, \'\\1114111\') Num Is a numeric typeclass. Its members have the property of being able to act like numbers. Whole numbers are polymorphic constants. They can act like any type that\u2019s a member of the Num typeclass. If we examine the type of * we can see that it accepts all numbers. &gt; :t (*) &gt; (*) :: (Num a) =&gt; a -&gt; a -&gt; a As * takes two numbers of the same type, (5 :: Int) * (6 :: Integer) will result in an error. To be part of Num, a type must also be part of Show and Eq. Integral Is a numeric typeclass containing Int and Integer Floating Is a numeric typeclass containing Float and Double The fromIntegral function has a type declaration of fromInegral :: (Num b, Integral a) =&gt; a -&gt; b. It takes an integral number and turns it into a more general number. Syntax in functions Pattern matching Pattern matching is the process of specifying patterns to which data should conform and then checking to see if it does, deconstructing the data according to those patterns. When defining functions, separate bodies can be defined for different patterns. factorial :: (Integral a) =&gt; a -&gt; a factorial 0 = 1 factorial n = n * factorial(n - 1) Pattern matching can fail. charName :: Char -&gt; String charName \'a\' = "Albert" charName \'b\' = "Bert" charName \'c\' = "Cecil" When called with an unexpected input, and exception will be raised Non-exhaustive patterns in function charName Pattern matching can also be used on tuples. addVectors :: (Num a) =&gt; (a, a) -&gt; (a, a) -&gt; (a, a) addVectors a b = (fst a + fst b, snd a + snd b) Using pattern matching we can instead write the function as addVectors (x1, y1) (x2, y2) = (x1 + x2, y1 + y2) There are no provided functions to extract the components of triples, but they can be easily written. first :: (a, c, c) -&gt; a first (x, _, _) = x second :: (a, b, c) -&gt; b second (_, y, _) = y third :: (a, b, c) -&gt; c third (_, _, z) = z It is also possible to pattern match in list comprehensions. &gt; let xs = [(1, 3), (4, 3), (2, 4), (5, 3), (5, 6), (3, 1)] &gt; [a+b | (a, b) &lt;- xs] &gt; [4,7,6,8,11,4] If a pattern match fails, it will move to the next element. We can pattern match against a list to make our own implementation of head head\' :: [a] -&gt; a head\' [] = error "Empty list has no head" head\' (x:_) = x tell :: (Show a) =&gt; [a] -&gt; String tell [] = "The list is empty" tell (x:[]) = "The list has one element: " ++ show x tell (x:y:[]) = "The list has two elements: " ++ show x ++ " and " ++ show y tell (x:y:_) = "The list is long. The first two elements are " ++ show x ++ " and " ++ show y The tell function is safe because it handles the empty list, singleton list, two element list, and lists with more than two elements. We could rewrite (x:[]) and (x:y:[]) as [x] and [x,y] respectively. We cannot however rewrite (x:y:_) with square brackets because it matches any list of length 2 or more. We can implement a recursive length function using list comprehension length\' :: (Num b) =&gt; [a] -&gt; b length\' [] = 0 length\' (_:xs) = 1 + length` xs We first define the result of a known input, the empty list. This is known as the edge condition. In the second pattern we split the list into a head and a tail, and then state that the length is 1 plus the length of the tail. sum\' :: (Num a) =&gt; [a] -&gt; a sum\' [] = 0 sum\' (x:xs) = x + sum` xs Patterns Patterns are a method of breaking something up according to a pattern and binding it to names whilst still keeping a refernce to the whole thing. xs@(x:y:ys) will match exactly the same thing as x:y:ys but the whole list can be accessed via xs instead of repeatedly typing x:y:ys within the function body. capital :: String -&gt; String capital "" = "Empty string" capital all@(x:xs) = "The first letter of " ++ all ++ " is " + [x] Patterns can be used to avoid needless repetition. Note that ++ cannot be used in pattern matching. Guards While patterns make sure a value conforms to some form and allow destructuring it, guards are a way of testing whether some property or properties of a value are true or false. Guards are much more readable that a statement when there are several conditions. bmi :: (RealFloat a) =&gt; a -&gt; String bmi i | i &lt;= 18.5 = "Underweight" | i &lt;= 25 = "Normal" | i &lt;= 30 "Fat" | i &lt;= "Land whale" Guards are indicated by pipes that follow a function\u2019s name and its parameters. They are usually indented. A guard is basically a boolean expression. If it evaluates to True, the corresponding body is used. Otherwise, the next guard is evaluated. The last guard will often be otherwise. otherwise is simply an alias for True, and catches everything. If all the guards of a function evaluate to False and there is no otherwise guard, evaluation falls through to the next pattern. If no suitable guards or patterns are found, an error is thrown. Guards can also be written inline, although it is less readable. max\' :: (Ord a) =&gt; a -&gt; a -&gt; a max\' a b | a &gt; b = a | otherwise = b compare\' :: (Ord a) =&gt; a -&gt; a -&gt; Ordering a `compare` b | a &gt; b = GT | a == b = EQ | otherwise = LT where Take note of the repetition in the function below bmi :: (RealFloat a) =&gt; a -&gt; a -&gt; String bmi weight height | weight / height ^2 &lt;= 18.5 = "Underweight" | weight / height ^2 &lt;= 25 = "Normal" | weight / height ^2 &lt;= 30 = "Overweight" | otherwise = "Land whale" Rather than repeating the bmi calculation, we can use the where keyword. bmi weight height | i &lt;= 18.5 = "Underweight" | i &lt;= 25 = "Normal" | i &lt;= 30 = "Overweight" | otherwise = "Land whale" where i = weight / height ^2 The value defined in where is visible across the guards. where bindings are not shared across function bodies of different patterns. If you want several patterns of one function to access a shared name, the name must be defined globally. We could also write a pattern match. where bmi = weight / height ^2 (underweight, normal, overweight) = (18.5, 25, 30) Another trivial function might five someone their initials initials :: String -&gt; String -&gt; String initials firstname lastname = [f] ++ ". " ++ [l] ++ "." where (f:_) = firstname (l:_) = lastname In the same way that we have defined constants in where blocks, we can also define functions. calcBmis :: (RealFloat a) =&gt; [(a, a)] -&gt; [a] calcBmis xs = [bmi w h | (w, h) &lt;- xs] where bmi weight height = weight / height ^2 Let it be let bindings are very similar to where bindings. let bindings allow you to bind variables anywhere and are themselves expressions. They do not span across guards. cyclinder :: (RealFloat a) =&gt; a -&gt; a -&gt; a cylinder r h = let sideArea = 2 * pi * r * h topArea = pi * r^2 in sideArea + 2 * topArea A let binding is of the form let &lt;bindings&gt; in &lt;expression&gt;. The names defined in the binding are accessible in the expression. This is similar to splitting up a calculation in another language. fun cylinder(r: Int, h: Int): Float { val sideArea = 2 * Math.PI * r * h val topArea = Math.PI * r * r return sideArea + 2 * topArea } The difference between where and let bindings is that while where bindings are just syntactic constructs, let bindings are actually expressions. let bindings can be used almost anywhere, in the same way as if statements. &gt; 4 * (let a = 9 in a + 1) + 2 &gt; 42 &gt; [let square x = x * x in (square 5, square 3, square 2)] &gt; [(25, 9, 4)] If we want to bind several variables in line, we can separate them with semicolons. &gt; (let a = 100; b = 200; c = 300 in a*b*c, let foo="Hey"; bar = "there!" in foo ++ bar) &gt; (6000000, "Hey there!") let bindings are very useful for quickly dismantling a tuple into components and binding them to names. &gt; (let (a,b,c) = (1,2,3) in a+b+c)*100 &gt; 600 let bindings can also be used inside list comprehensions. calcBmis :: (RealFloat a) =&gt; [(a, a)] -&gt; [a] calcBmis xs = [bmi | (w, h) &lt;- xs, let bmi = w /h^2] We use let in a similar way to a predicate, the difference being that we do not filter the list. The names defined in a let are visible to the output function and all predicates and secitons that come after the binding. listOverweight :: (RealFloat a) =&gt; [(a, a)] -&gt; [a] listOverweight xs :: [bmi | (w, h) &lt;- xs, let bmi = w / h^2, bmi &gt;= 25] We ommited the in part of the binding because the scope of the names is already predefined. If we used let in, the names would only be visible to that predicate. Case expressions The syntax for a case expression is simple case expression of pattern -&gt; result pattern -&gt; result pattern -&gt; result ... expression is matched against the patterns. The first pattern that matches the expression is used. If it falls through the whole case an exception occurs. Whereas pattern matching on function parameters can only be done when defining functions, case expressions can be used pretty much anywhere. They are useful for pattern matching against something in the middle of an expression. Recursion The maximum function takes a list of instances of the Ord typeclass, and returns the largest of them. In an imperative language you might define this function as so fun maximum(items: Array&lt;Int&gt;): Int { var max = Integer.MIN_VALUE items.forEach { if (it &gt; max) { max = it } } return max } In Haskell we might instead write our maximum function as follows maximum\' :: (Ord a) =&gt; [a] -&gt; a maximum\' [] = error "Empty list" maximum\' [x] = x maximum\' (x:xs) | x &gt; maxTail = x | otherwise = maxTail where maxTail = maximum\' xs We split the list into a head and a tail, and then compare the head to the maximum of the tail. Consider [2, 5, 1]. We reach the (x:xs) branch with a head of 2 and a tail of [5, 1]. maximum\' is called on [5, 1], reaching the same branch with a head of 5 and a tail of [1]. maximum\' is called once more on [1] which returns 1. We now cascade back up the call stack, comparing the head 5 to 1, giving 5 and then comparing 5 (maxTail) to 2 and returning 5. The function could be written more elegantly using max. maximum\' :: (Ord a) =&gt; [a] -&gt; a maximum\' [] = error "Empty list" maximum\' [x] = x maximum\' (x:xs) - max x (maximum\' xs) Recursive function Examples Repliate replicate\' :: (Num i, Ord i) =&gt; i -&gt; a -&gt; [a] replicate\' n x | n &lt;= 0 = [] | otherwise x:replicate` (n-1) x As we are testing boolean expressions we used guards. As Num is not a subclass of Ord we have to specify both class constraints. Take take\' :: (Num i, Ord i) =&gt; i -&gt; [a] -&gt; [a] take` n _ | n &lt;= 0 = [] take` _ [] = [] take` n (x:xs) = x:take` (n-1) xs The first pattern deals with negative values, the second with empty lists, and the third with lists containing some number of items. As our guard has no otherwise, the the matching will fall through when n &gt; 0. Reverse reverse\' :: [a] -&gt; [a] reverse\' [] = [] reverse\' (x:xs) = reverse\' xs ++ [x] Repeat repeat takes an element and returns an infinite list of that element. repeat\' :: a -&gt; [a] repeat\' x = x:repeat x Repeat zip takes two lists and zips them together to a list of pairs. zip\' :: [a] -&gt; [b] -&gt; [(a, b)] zip\' _ [] = [] zip\' [] _ = [] zip\' (x:xs) (y:ys) = (x,y):zip xs ys Elem elem\' :: a -&gt; [a] -&gt; Bool elem\' a [] = False elem\' a (x:xs) | a == x = True | otherwise = a `elem` xs Quick sort Implementing QuickSort is much easier in Haskell than in imperative languages. quicksort :: (Ord a) =&gt; [a] -&gt; [a] quicksort [] = [] quicksort (x:xs) = let smallerSorted = quicksort [a | a &lt;- xs, a &lt;= x] biggerSorted = quicksort [a | a &lt;- xs, a &lt;= x] in smallerSorted ++ [x] ++ biggerSorted This Quicksort implementation uses the head as a pivot for the sorting. Higher order functions Functions in Haskell can take functions as parameters and return functions. A function that does either of those is called a higher order function. Curried functions Every function in Haskell only takes one parameter. All the functions which take several parameters are curried functions. The following two calls are equivalent &gt; max 4 5 &gt; (max 4) 5 Calling max 4 5 first creates a function which takes a single parameter and returns either 4 or that parameter, whichever is larger. It then applies that function to 5. Putting a space between two pieces of code is simply function application. The space is like an operator with the highest precedence. Again considering max max :: (Ord a) =&gt; a -&gt; a-&gt; a max :: (Ord a) =&gt; a -&gt; (a -&gt; a) The second line could be read as max takes an a and returns a function that takes another a and returns an a. The return type of each functions are separated with the arrows. Consider the following function multThree :: (Num a) =&gt; a -&gt; a -&gt; a -&gt; a multThree x y z = x * y * z When we call multThree 3 5 9 we are actually calling ((multThree 3) 5) 9. This means that 3 is applied to multThree to create a function that takes one parameter and returns a function. Next, 5 is applied to that function, and returns a function which takes a single parameter and multiplies it by 15. Finally, 9 is applied to that function and the result is 135. By calling functions without some of their parameters, we can create new functions. &gt; let multTwoWithNine = multThree 9 &gt; multTwoWithNine 2 3 &gt; 54 &gt; let multWithEighteen = multTwoWithNine 2 &gt; multWithEighteen 10 &gt; 180 Infix functions can also be partially applied by using sections. To section an infix function, surround it with parentheses and only supply a parameter on one side. divTen :: (Floating a) =&gt; a -&gt; a divTen = (/10) isUpperAlphanum :: Char -&gt; Bool isUpperAlphanum = (\'elem\' [\'A\'..\'Z\']) Note that when using sections, - cannot be used directly. (-4) means -4. To make a function which takes a value and subtracts 4 from it you must replace the - with subtract, (subtract 4). Higher order functions applyTwice :: (a -&gt; a) -&gt; a -&gt; a applyTwice f x = f (f x) Notice that the type declaration contains parentheses. They are mandatory when one of the parameters is a function. &gt; applyTwice (+4) 10 &gt; 18 We can now re-implement another standard library function, zipWith. zipWith takes a function and two lists as parameters and then joins the two lists by applying the function between corresponding elements. zipWith\' (a -&gt; b -&gt; c) -&gt; [a] -&gt; b -&gt; [c] zipWith\' _ [] _ = [] zipWith\' _ _ [] = [] zipWith\' f (x:xs) (y:ys) = f x y : zipWith\' f xs ys In the type decleration the first parameter is a function that takes two things and produces a third. The second and third parameters are lists, and the return value is a list, with each list matching the respective types of the arguments of the first function. &gt; zipWith\' (+) [4,2,5,6] [2,6,2,3] &gt; [6,8,7,9] Another standard library function is flip. It takes a function and returns a function which is like the original function, but with the first two arguments flipped. flip\' :: (a -&gt; b -&gt; c) -&gt; (b -&gt; a -&gt; c) flip\' f = g where g x y = f y x Reading the type declaration we say that flip\' takes a function that takes an a and a b, and returns a function that takes a b and an a. Because functions are curried by default, the second pair of parentheses is really unnecessary, because -&gt; is right associative by default. (a -&gt; b -&gt; c) -&gt; (b -&gt; a -&gt; c) is the same as (a -&gt; b -&gt; c) -&gt; (b -&gt; (a -&gt; c)) which is the same as (a -&gt; b -&gt; c) -&gt; b -&gt; a -&gt; c. We can further simplify the function by writing it as flip\' :: (a -&gt; b -&gt; c) -&gt; b -&gt; a -&gt; c flip\' f y x = f x y Maps and filters map Takes a function and a list and applies that function to every element in the list, producing a new list. The definition of map is map :: (a -&gt; b) -&gt; [a] -&gt; [b] map _ [] = [] map f (x:xs) = f x : map f xs &gt; map (+2) [1,2,3,4] &gt; [3,4,5,6] This is much more readable than the equivalent list comprehension [x+2 | x &lt;- [1,2,3,4]]. filter is a function that takes a predicate and a list and returns the elements of the list that satisfy the predicate filter :: (a -&gt; Bool) -&gt; [a] -&gt; [a] filter _ [] = [] filter p (x:xs) | p x = x : filter p xs | otherwise = filter p xs &gt; filter (&gt;3) [1,2,3,4,5,6,7,8,9] &gt; [4,5,6,7,8,9] &gt; let notNull x = not (null x) in filter notNull [[1,2,3],[],[3,4,5],[2,2],[],[]] &gt; [[1,2,3],[3,4,5],[2,2]] Recalling the earlier implementation of QuickSort, we can replace the list comprehensions with calls to filter. quicksort :: (Ord a) =&gt; [a] -&gt; [a] quicksort [] = [] quicksort (x:xs) = let smallerSorted = quicksort (filter (&lt;=x) xs) biggerSorted = quicksort (filter (&gt;x) xs) in smallerSorted ++ [x] ++ biggerSorted takeWhile is a function that takes a list and a predicate and returns all of the elements from the start of the list while the predicate returns true Suppose we wish to find the sum of all odd square that are less than 10000 &gt; sum (takeWhile (&lt;10000) (filter odd (map (^2) [1..]))) &gt; 166650 In the Collatz sequence, we start with a natural number. If the number is even we divide it by 2. If the number is odd we multiply it by 3 and add 1. We take the resulting value and apply the same process to it, stopping when we reach one. chain :: (Integral a) =&gt; a -&gt; [a] chain 1 = [1] chain n | even n = n:chain (n / 2) | odd n = n:chain (n*3 + 2) &gt; chain 10 &gt; [10, 5, 16, 8, 4, 2, 1] Lambdas Lambdas are anonymous functions that are used because we need some functions only once, and do not want to pollute the namespace. We write a lambda with a \\newline and then write the parameters, followed by a -&gt; and then the function body. Filtering for long chains we might write numLongChains :: Int numLongChains = length (filter (\\xs -&gt; length xs &gt; 15) (map chain [1..100])) Lambdas can take any number of parameters in the same way as normal functions &gt; zipWith (\\a b -&gt; (a * 30 + 3) / b) [5,4,3,2,1] [1,2,3,4,5] &gt; [153.0, 61.5, 31.0, 15.75, 6.6] As with normal functions, we can pattern match in lambdas. &gt; map (\\newline(a,b) -&gt; a + b) [(1,2),(3,5),(6,3),(2,6),(2,5)] &gt; [3,8,9,8,7] Due to the way we curry functions, the following two are equivalent addThree :: (Num a) =&gt; a -&gt; a -&gt; a -&gt; a addThree x y z = x + y + z addThree :: (Num a) =&gt; a -&gt; a -&gt; a -&gt; a addThree = \\x -&gt; \\y -&gt; \\z -&gt; x + y + z While the example above decreases readability, it can aid with the understanding of some functions, such as flip flip\' :: (a -&gt; b -&gt; c) -&gt; b -&gt; a -&gt; c flip\' f = \\x y -&gt; f y x Folding foldl The left fold the folds a list up form the left side sum\' :: (Num a) =&gt; [a] -&gt; a sum\' xs = foldl (\\acc x -&gt; acc + x) 0 xs In the example above \\acc x -&gt; acc + x is the binary function. 0 is the starting value and xs is the list to be folded up. &gt; sum\' [3,5,2,1] &gt; 11 At each step we have | 0 + 3 | [3,5,2,1] | | 3 + 5 | [5,2,1] | | 8 + 2 | [2,1] | | 10 + 1| [1] | | 11 | | We could implement elem using foldl elem\' :: (Eq a) =&gt; a -&gt; [a] -&gt; Bool elem\' y ys = foldl (\\acc x -&gt; if x == y then True else acc) False ys The starting value and accumulator above are both boolean values. foldr Works in a similar way to foldl, except that it consumes values from the right foldr takes the accumulator as the second function. We can implement map with a foldr. map\' :: (a -&gt; b) -&gt; [a] -&gt; [b] map\' f xs = foldr (\\x acc -&gt; f x : acc) [] xs If we map (+3) to [1,2,3], we approach the list from the right side. We take the first element 3 and apply the function to it, giving 6. We prepend 6 to the accumulator. We then apply (+3) to 2, giving 5, and prepend it to the accumulator. Continuing in the same manner we reach [4,5,6]. One notable difference is that folr works on infinite lists, while foldl does not. Folds can be used to implement any function were you traverse a list once. There are also the functions foldl1 and foldr1 which do not require a starting value, instead assuming that the first value in their traversal order is the starting value. This would allow an implementation of sum as sum = foldl1 (+), although it would cause an error on an empty list. Fold implementations of standard library functions maximum\' :: (Ord a) =&gt; [a] -&gt; a maximum\' = foldr1 (\\x acc -&gt; if x &gt; acc then x else acc) reverse\' :: [a] -&gt; [a] reverse\' = foldl (\\acc x -&gt; x : acc) [] product\' :: (Num a) =&gt; [a] -&gt; a product\' = foldr1 (*) filter\' :: (a -&gt; Bool) -&gt; [a] -&gt; [a] filter\' p = foldr (\\x acc -&gt; if p x then x : acc else acc) [] head\' :: [a] -&gt; a head\' = foldr1 (\\x _ -&gt; x) last\' :: [a] -&gt; a last\' = foldl1 (\\_ x -&gt; x) The head function would be better implemented by pattern matching, as the fold traverses the entire list. In reverse we take a starting value of an empty list and append each value from the left to our list. scanl and scanr scanl and scanr are like foldl and foldr, with the difference being that they report all the intermediate accumulator states in the form of a list. There are also scanl1 and scanr1 &gt; scanl (+) 0 [3,5,2,1] &gt; [0,3,8,10,11] &gt; scanr (+) 0 [3,5,2,1] &gt; [11,8,3,1,0] &gt; scanl1 (\\acc x -&gt; if x &gt; acc then x else acc) [3,4,5,3,,7,9,2,1] &gt; [3,4,5,5,7,9,9,9] &gt; scanl (flip (:)) [] [3,2,1] &gt; [[],[3],[2,3],[1,2,3]] Scans are used to monitor the progression of a function that can be implemented as a fold. Function application with $ The $ function is also called function application. ($) :: (a -&gt; b) -&gt; a -&gt; b f $ x = f x Whereas normal function application has the highest precedence, $ has the lowest precedence. Function application with a space is left-associative so f a b c is the same as ((f a) b) c. Function application with $ is right associative. Consider the expression sum (map sqrt [1..130]). We can instead write sum $ map sqrt [1..130]. When a $ is encountered the expression on its right is applied as the parameter to the function on its left. Consider sqrt (3 + 4 + 9). We could instead write this as sqrt $ 3 + 4 + 9. In sum (filter (&gt; 10) (map (*2) [2..10])) we can write sum $ filter (&gt; 10) $ map (*2) [2..10] because f (g (z x)) is equal to f $ g $ z x. Function composition In Haskell, function composition is performed with the . function, which is defined as follows (.) :: (b -&gt; c) -&gt; (a -&gt; b) -&gt; a -&gt; c f . g = \\x -&gt; f (g x) f must take as its parameter a value that has the same type as g\u2019s return value. One of the uses for function composition is making functions on the fly to pass to other functions, which is often cleaner and more concise than lambdas. &gt; map (\\x -&gt; negate (abs x)) [5,-3,-6,7,-3,2,-19,24] &gt; [-5,-3,-6,-7,-3,-2,-19,-24] &gt; map (negate . abs) [5,-3,-6,7,-3,2,-19,24] &gt; [-5,-3,-6,-7,-3,-2,-19,-24] Function composition is right associative, so multiple functions can be composed together. Function composition with multiple parameters If we want to use a function with multiple parameters in a function composition, we usually have to partially apply them so that each function takes just one parameter. sum (replicate 5 (max 6.7 8.9)) can be rewritten as (sum . replicate 5. max 6.7) 8.9 or as sum . replicate 5 . max 6.7 $ 8.9. What is happening is the creation of a function that takes what max 6.7 takes and applies replicate 5 to it. Then a function that takes the result of that and does a sum of it is create. Finally, that unction is called with 8.9. However it is more easily read as taking the value of max 6.7 8.9, replicating it 5 times, and taking the sum of that replication. If you want to rewrite a function with lots of parentheses you can start by putting the last parameter of the innermost function after a $, and replacing each pair of parentheses with a .. replicate 100 (product (map (*3) (zipWith max [1,2,3,4,5] [4,5,6,7,8]))) can be rewritten as replicate 100 . product . map (*3) . zipWith max [1,2,3,4,5] $ [4,5,6,7,8]. The free point style allows functions to be written more cleanly fn x = ceiling (negate (tan (cos (max 50 x)))) can instead be written fn = ceiling . negate . tan . cos . max 50 Modules A Haskell module is a collection of related functions, types, and typeclasses. A program is a collection of modules in which the main module loads up the other modules and then uses their functions to perform some process. Modules provide many advantages. If a module is generic enough, the functions it exports can be used in many different programs. If code is separated into self-contained modules which aren\u2019t too reliant on each other, they can be reused later on and changed more easily without having to rewrite other code. The standard library is split into modules, each of which contains related functions and types. Modules are imported before the definition of any function with the syntax import module_name. The Data.List module has useful functions for working with lists. One of thest functions is numUniques numUniques:: (Eq a) =&gt; [a] -&gt; Int numUniques = length . nub When Data.List is imported, all of its exports become available in the global namespace. nub is another function in Data.List that removes duplicate elements from a list. In the terminal, functions can be added to the global namespace with :m &gt; :m + Data.List Data.Map Data.Set Individual functions can also be imported import Data.List (nub, sort) We can also import all of the functions in a module except some which are explicitly excluded. This is useful if different modules export functions with the same name. import Data.List hiding (nub) Another method for dealing with name clashes is qualified imports. The Data.Map module contains functions with the same names as some of those in Prelude, such as filter or null import qualified Data.Map This means that when we wish to reference the filter function in Data.Map we must write Data.Map.Filter. As this can make code very verbose, there is the option to name the import import qualified Data.Map as M We can now access Data.Map.Filter as M.filter Data.List intersperse takes an element and a list and puts that element in between each pair of elements in the list &gt; intersperse 0 [1,2,3,4,5] &gt; [1,0,2,0,3,0,4,0,5] intercalate takes a list of lists and a list, and inserts the list between each of the lists within the list of lists, before flattening the result &gt; intercalate [0,0,0] [[1,2,3],[4,5,6],[7,8,9]] &gt; [1,2,3,0,0,0,4,5,6,0,0,0,7,8,9] transpose transposes a list of lists. Considering the list of lists as a 2d matrix, rows become columns and vice versa &gt; transpose [[1,2,3],[4,5,6],[7,8,9]] &gt; [[1,4,7],[2,5,8],[3,6,9]] fold\u2019 and foldl1\u2019 are stricter version of their respective lazy incarnations. When using lazy folds on very large lists, stack overflow errors may occur. Due to the lazy nature of folds, the accumulator is not actually updated as the folding happens. The strict fold functions actually compute the intermediate values rather than filling up the stack with thunks. concat flattens a list of lists into a list of elements &gt; concat [[1,2,3],[4,5,6],[7,8,9]] &gt; [1,2,3,4,5,6,7,8,9] concatMap is the same as first mapping a function to a list, and then concatenating the list with concat and takes a list of values and returns True only if all the values in the list are True or takes a list and returns True if any of the values in the list are True &gt; and $ map (&gt;4) [5,6,7,8] &gt; True &gt; or $ map (==4) [1,2,3,4,5,6,7,8] &gt; True any and all take a predicate and then check if any or all of the elements in the list satisfy the predicate, respectively. These functions are usually used rather than mapping over a list and then using or or and iterate takes a function and a starting value. It applies the function to the starting value, then applies that function to the result, and repeats, returning in the form of an infinite list &gt; take 10 $ iterate (*2) 1 &gt; [1,2,4,8,15,32,64,128,256,512] splitAt takes a number and a list. It then splits the list at that many elements, returning the two lists in a tuple &gt; splitAt 3 [1,2,3,4,5,6] &gt; ([1,2,3], [4,5,6]) takeWhile takes elements from a list while the predicate holds &gt; takeWhile (/=\' \') "This is a sentence" &gt; "This" dropWhile takes a list and drops all the elements from the list while the predicate holds &gt; dropWhile (&lt;3) [1,2,2,2,2,2,2,8,6,8] &gt; [8,6,8] span returns a pair of lists, the first list containing the result of takeWhile on the list, and the second list containing the remaining elements break break p is the equivalent of span (not . p) sort sorts a list of the Ord typeclass group takes a list and groups the adjacent elements into sublists if they are equal &gt; group [1,1,1,2,2,2,2,3,3,3,3,3,4,4,4,4,4,4] &gt; [[1,1,1],[2,2,2,2],[3,3,3,3,3],[4,4,4,4,4,4]] inits and tails are like init and tail except that they recursively apply to the list until there is nothing left &gt; inits "text" &gt; ["", "t", "te", "tex", "text"] isInfixOf returns true if a sublist is contained within a list isPrefixOf and isSuffixOf search for a sublist at the beginning and end of a list respectively elem and notElem check if an element is or is not inside a list partition takes a list and a predicate and returns a pair of lists, the first containing all the elements that satisfy the predicate, and the second containing those that do not find takes a list and a predicate and returns the first element that satisfies the predicate The type of find is Maybe a as it can contain Just a or Nothing. elemIndex returns the index of an element in a list, or Nothing if the element is not contained within the list elemIndices returns a list of the indices of an element within a list findIndex maybe returns the index of the first element that satisfies the predicate zip3, zip4, zipWith3, and zipWith4 zip 3 or 4 lists into triples or 4 tuples lines takes a string returns every line of that string in a separate list &gt; lines "line 1\\nline 2\\nline 3" &gt; ["line 1", "line 2", "line 3"] unlines takes a list of strings and joins them together with the \u2018\\n\u2019 character words and unwords split a line of text into words or join a list of words respectively delete takes an element and a list and deletes the first occurrence of that element in the list \\ the list difference function. For every element in the right hand list, it removes a matching element in the left one union returns the union of two lists intersect returns only the elements that are found in both lists insert takes an element and a list of elements that can be sorted and inserts it into the last position where it is less than or equal to the next element length, take, drop splitAt, !!, and replicte all take Int as one of their parameters, or return an Int. They could be more generic if they took any type that\u2019s part of Integral or Num. Data.List contains genericLength, genericTake etc to provide these functions without breaking old code. The nub, delete, union, intersect, and group functions all have their more general counterparts nubBy etc. While the standard functions use == to test for equality, the By functions take an equality function as a parameter. Similarly there are sortBy, insertBy, maximumBy, and minimumBy functions. Data.Char The Data.Char module deals with characters isControl checks whether a character is a control character isSpace checks whether a character is a white space character isLower checks whether a character is lower cased isUpper checks whether a character is upper cased isAlpha checks whether a character is a letter isAlphaNum checks whether a character is a letter or a number isPrint checks whether a character is printable isDigit checks whether a character is a digit isOctDigit checks whether a character is an octal digit isHexDigit checks whether a character is a hexadecimal digit isLetter checks whether a character is a letter isMark checks for Unicode mark characters. These characters combine with preceding letters to form letters with accents isNumber checks whether a character is numeric isPunctuation checks whether a character is punctuation isSymbol checks whether a character is a symbol isSeparator checks for Unicode spaces and separators isAscii checks whether a character falls within the first 128 of the Unicode set isLatin1 checks whether a character falls into the first 256 characters of the Unicode set isAsciiUpper checks whether a character is ASCII and uppercase isAsciiLower checks whether a character is ASCII and lowercase All of the above functions have a type signature of Char -&gt; Bool Data.Char exports a data type which is similar to Ordering. The Ordering type can have a value of LT, EQ, or GT. It describes possible result that can arise from comparing elements. The GeneralCategory type is also an enumeration. It presents possible categories that a character can fall into. generalCategory has a type of Char -&gt; GeneralCategory. There are a total of 31 categories. &gt; generalCategory \' \' &gt; Space &gt; generalCategory \'A\' &gt; UppercaseLetter &gt; generalCategory \'|\' &gt; MathSymbol toUpper converts a character to uppercase, ignoring those which do not have an uppercase toLower converts a character to lowercase toTitle converts a character to title case, which is usually the same as uppercase digitToInt converts a character to an Int. The character must be in the range \u20180..9, a..f, A..F\u2019 intToDigit is the inverse of digitToInt ord and chr convert characters to their numeric values and vice versa Data.Map Association lists are lists that are used to store key-value pairs where ordering does not matter. We could represent this structure with a list of pairs, and find values by their key as follows findKey :: (Eq k) =&gt; k -&gt; [(k, v)] -&gt; v findKey key xs = snd . head . filter (\\(k,v) -&gt; key == k) $ xs The function takes the list of pairs, filters the list so that only matching keys remain, and takes the head value. In order to deal with elements which do not exist, we must return Maybe v findKey :: (Eq k) =&gt; k -&gt; [(k,v)] -&gt; Maybe v findKey key [] = Nothing findKey key ((k,v):xs) = if key == k then Just v else findKey key xs This recursive function on a list can be implemented as a fold findKey :: (Eq k) =&gt; k -&gt; [(k,v)] -&gt; Maybe v findKey key = foldr (\\(k,v) acc -&gt; if key == k then Just v else acc) Nothing The findKey function does the same thing as the lookup function from Data.List. The Data.Map module offers association lists which are much faster, as they are not traversing lists. Data.Map should qualified in order to stop namespace clashes with Prelude and Data.List. fromList takes an association list and returns a map with the same associations If there are duplicate keys in the list, they are discarded. fromList has the signature Map.fromList :: (Ord k) =&gt; [(k, v)] -&gt; Map.Map k v. The keys must be orderable so that they can be placed in a tree. empty represents an empty map insert takes a key, a value, and a map, and returns a new map with the new item &gt; Map.empty &gt; fromList [] &gt; Map.insert 3 100 Map.empty &gt; fromList [(3,100)] null checks if a map is empty size reports the size of a map, which is the number of key value pairs singleton takes a key and a value and creates a map with exactly one mapping lookup returns Just something if a key exists and Nothing if it does not member is a predicate that takes a key and a map and reports whether the key is in the map map and filter work much like their list equivalents, working on the values toList is the inverse of fromList keys and elems return a list of keys and values respectively fromListWith acts like fromList except that it takes a function supplied to decide what to do with duplicate keys The function is used to combine the values of those keys into some other value insertWIth inserts a key-value pair into a map, using the passed function if the key already exists Data.Set Data.Set offers set structures. fromList takes a list and converts it to a set &gt; Set.fromList "The quick brown fox jumped over the lazy dog." &gt; fromList " .Tabcdefghijklmnopqrstuvwxyz" The elements are ordered and each element is unique intersection returns a set of the elements which are present in both sets difference returns a set of the elements which are in the first set but not the second union returns a set of the combined elements of both sets null, size, member, empty, singleton, insert, and delete work as expected isSubsetOf checks if the first set is a subset of the second set isProperSubsetOf checks if the first set is a proper subset of the second set Creating modules Modules are defined as follows module Geometry ( sphereVolume , sphereArea , cubeVolume , cubeArea , cuboidArea , cuboidVolume ) where sphereVolume :: Float -&gt; Float sphereVolume radius = (4.0 / 3.0) * pi * (radius ^ 3) sphereArea :: Float -&gt; Float sphereArea radius = 4 * pi * (radius ^ 2) cubeVolume :: Float -&gt; Float cubeVolume side = cuboidVolume side side side cubeArea :: Float -&gt; Float cubeArea side = cuboidArea side side side cuboidVolume :: Float -&gt; Float -&gt; Float -&gt; Float cuboidVolume a b c = rectangleArea a b * c cuboidArea :: Float -&gt; Float -&gt; Float -&gt; Float cuboidArea a b c = rectangleArea a b * 2 + rectangleArea a c * 2 + rectangleArea c b * 2 rectangleArea :: Float -&gt; Float -&gt; Float rectangleArea a b = a * b The helper function rectangleArea is not exported. Modules can be given hierarchical structures. Each module can have a number of submodules which can have submodules of their own. Creating submodules First we create a folder called Geometry. Within this folder we create three files: Sphere.hs, Cuboid.hs, and Cube.hs module Geometry.Sphere ( volume , area ) where volume :: Float -&gt; Float volume radius = (4.0 / 3.0) * pi * (radius ^ 3) area :: Float -&gt; Float area radius = 4 * pi * (radius ^ 2) module Geometry.Cuboid ( volume , area ) where volume :: Float -&gt; Float -&gt; Float -&gt; Float volume a b c = rectangleArea a b * c area :: Float -&gt; Float -&gt; Float -&gt; Float area a b c = rectangleArea a b * 2 + rectangleArea a c * 2 + rectangleArea c b * 2 rectangleArea :: Float -&gt; Float -&gt; Float rectangleArea a b = a * b module Geometry.Cube ( volume , area ) where import qualified Geometry.Cuboid as Cuboid volume :: Float -&gt; Float volume side = Cuboid.volume side side side area :: Float -&gt; Float area side = Cuboid.area side side side In each module we have defined functions with the same names. This is possible because they are separate modules. Making Types and Typeclassses Algebraic data types data Bool = False | True The data keyword is used to define a new data type. The part before the = denotes the type, and the parts after it are value constructors. They specify the different values that this type can have. We could think of Int as being data Int = -2147483648 | -2147483647 | ... | -1 | 0 | 1 | 2 | ... | 2147483647 Consider the definition of a shape data Shape = Circle Float Float Float | Rectangle Float Float Float Float The Circle value constructor has three fields. When we write a value constructor we optionally add some types after it and those types define the values it will contain. Value constructors are actually functions that ultimately return a value of a data type. &gt; :t Circle &gt; Circle :: Float -&gt; Float -&gt; Float -&gt; Shape &gt; :t Rectangle &gt; Rectangle :: Float -&gt; Float -&gt; Float -&gt; Float -&gt; Shape A function to find the surface of a Shape cane be written as follows surface :: Shape -&gt; Float surface (Circle _ _ r) = pi * r ^ 2 surface (Rectangle x1 y1 x2 y2) = (abs $ x2 - x1) * (abs $ y2 - y1) We could not write a type declaration of Circle -&gt; Float because Circle is not a type, whereas Shape is. We can pattern match against constructors, which we have been doing before when matching against values like [] or False. To make our type printable we modify it as below data Shape = Circle Float Float Float | Rectangle Float Float Float Float deriving (Show) When we add deriving (Show) at the end of a data declaration, Haskell makes that type part of the Show typeclass automatically. Value constructors are functions, so we can map them and partially apply them. &gt; map (Circle 10 20) [4,5,6,7] &gt; [Circle 10.0 20.0 4.0,Circle 10.0 20.0 5.0,Circle 10.0 20.0 6.0,Circle 10.0 20.0 7.0] To improve the Shape type we can define an intermediate data type to represent a point in two dimensional space data Point = Point Float Float deriving (Show) data Shape = Circle Point Float | Rectangle Point Point deriving (Show) When defining a point, we used the name for the data type and its value constructor. This has no special meaning. The surface function must now be adjusted surface :: Shape -&gt; Float surface (Circle r) = pi * r ^ 2 surface (Rectangle (Point x1 y1) (Point x2 y2)) = (abs $ x2 - x1) * (abs $ y2 - y1) When calculating the area of the rectangle we use nested pattern matching to access the fields. We can defined a function to modify the position of a shape nudge :: Shape -&gt; Float -&gt; Float -&gt; Shape nudge (Circle (Point x y) r) a b = Circle (Point (x+a) (y+b)) r nudge (Rectangle (Point x1 y1) (Point x2 y2)) a b = Rectangle (Point (x1+a) (y1+b)) (Point (x2+a) (y2+a)) &gt; nudge (Circle (Point 34 34) 10) 5 10 &gt; Circle (Point 39.0 44.0) 10.0 If we don\u2019t want to deal directly with points, we can make auxiliary functions that create shapes of some size at the zero coordinates and then nudge those. baseCircle :: Float -&gt; Shape baseCircle r = Circle (Point 0 0) r baseRect :: Float -&gt; Float -&gt; Shape baseRect width height = Rectangle (Point 0 0) (Point width height) &gt; nudge (baseRect 40 100) 60 23 &gt; Rectangle (Point 60.0 23.0) (Point 100.0 123.0) These data types can be exported in modules. Write the type along with the functions to be exported, and then add parentheses and specify the value constructors to be exported for it. To export all the value constructors for a type, just write .. module Shapes ( Point(..) , Shape(..) , surface , nudge , baseCircle , baseRect ) where By writing Shape(..) we exported all the value constructors for Shape. This is the same as writing Shape(Rectangle, Circle). We could opt not to export the value constructors for Shape by just writing Shape. This would mean that any user of the module could only make shapes using the auxiliary functions baseCircle and baseRect. Record syntax Suppose we wish to create a data type to contain information about a person. data Person = Person String String Int Float String String deriving (Show) &gt; let guy = Person "Buddy" "Finklestein" 43 184.2 "526-2928" "Chocolate" &gt; guy Person "Buddy" "Finklestein" 43 184.2 "526-2928" "Chocolate" This is somewhat unreadable. Now suppose that we cant to create a function to get individual pieces of information from a Person. firstName :: Person -&gt; String firstName (Person firstname _ _ _ _ _) = firstname lastName :: Person -&gt; String lastName (Person _ lastname _ _ _ _) = lastname age :: Person -&gt; Int age (Person _ _ age _ _ _) = age height :: Person -&gt; Float height (Person _ _ _ height _ _) = height phoneNumber :: Person -&gt; String phoneNumber (Person _ _ _ _ number _) = number flavor :: Person -&gt; String flavor (Person _ _ _ _ _ flavor) = flavor This is tedious to write. Instead we can write out data type as follows data Person = Person { firstName :: String , lastName :: String , age :: Int , height :: Float , phoneNumber :: String , flavor :: String } deriving (Show) We define a name for each field, and then specify its type. Functions are automatically created for looking up fields. The functions have the same name as the fields. &gt; :t flavor &gt; flavor :: Person -&gt; String When we derive Show, the output is also much more useful. data Car = Car String String Int deriving (Show) &gt; Car "Ford" "Mustang" 1967 Car "Ford" "Mustang" 1967 data Car = Car {company :: String, model :: String, year :: Int} deriving (Show) &gt; Car {company="Ford", model="Mustang", year=1967} Car {company = "Ford", model = "Mustang", year = 1967} When making a new Car we don\u2019t have to put the fields in their proper order, as long as we list all of them. If we were not using record syntax, we would have to specify them in order. Record syntax should be used when there are numerous parameters which are not immediately distinguishable. Type parameters A value constructor can take some values as parameters and then produce a new value. In a similar manner, type constructors take types as parameters and produce new types. data Maybe a = Nothing | Just a The a above is the type parameter. Because there is a type parameter involved, we call Maybe a type constructor. Depending on what we want this data type to hold when it is not Nothing, this type constructor can produce a type of Maybe Int, Maybe String or any other Maybe type. No value can have a type of just Maybe, because that is not a type, only a type constructor. If we pass Char as the type parameter to Maybe, we get a type of Maybe Char. The value Just \'a\' has a type of Maybe Char. &gt; Just "String" &gt; Just "String" &gt; Just 84 &gt; Just 84 &gt; :t Just "String" &gt; Just "String" :: Maybe [Char] &gt; :t Just 84 &gt; Just 84 :: (Num t) =&gt; Maybe t &gt; :t Nothing &gt; Nothing :: Maybe a &gt; Just 10 :: Maybe Double &gt; Just 10.0 Type parameters are useful because we can make different types with them depending on what kind of types we want contained in our data type. The type of Nothing is Maybe a. It is polymorphic. If some function requires Maybe Int as a parameter, we can give it Nothing, because Nothing doesn\u2019t contain a value anyway. The Maybe a type can act like a Maybe Int if it has to. Similarly, the type of an empty list is [a], so an empty list can act like anything. Another parametrized type is Map k v. Having maps parametrized enables us to have mappings from any type to any other type, as long as the type of the key is part of the Ord typeclass. If we were defining a mapping type, we could add a typeclass constraint in the data declaration. data (Ord k) =&gt; Map v k = ... It is a very strong convention in Haskell to never add typeclass constraints in data declarations. This is because we don\u2019t benefit a lot, but we end up writing more class constraints, even when we don\u2019t need them. If we put or don\u2019t put the Ord k constraint for Map k v, we will have to put the constraint into functions that assume the keys in a map can be ordered. If we don\u2019t put the constraint in the data declaration, we don\u2019t have to put (Ord k) =&gt; in the type declarations of functions that don\u2019t care whether the keys can be ordered. An example is toList, which has a type signature of toList :: Map k a -&gt; [(k, a)] rather than having to have a type constraint toList :: (Ord k) =&gt; Map k a -&gt; [(k, a)] without actually doing any comparing of keys. We don\u2019t put type constraints in data declarations because they will have to be put in function type declarations anyway. A 3d vector type and some operations are defined as follows data Vector a = Vector a a a deriving (Show) vplus :: (Num t) =&gt; Vector t -&gt; Vector t -&gt; Vector t (Vector i j k) `vplus` (Vector l m n) = Vector (i+l) (j+m) (k+n) vectMult :: (Num t) =&gt; Vector t -&gt; t -&gt; Vector t (Vector i j k) `vectMult` m = Vector (i*m) (j*m) (k*m) scalarMult :: (Num t) =&gt; Vector t -&gt; Vector t -&gt; t (Vector i j k) `scalarMult` (Vector l m n) = i*l + j*m + k*n We use a parametrized type because the vector should support several numeric types. vplus is use to add two vectors together. scalarMult is for the scalar product of two vectors, and vectMult is for multiplying a vector with a scalar. These functions can operate on types of Vector Int, Vector Integer, Vector Float, and any other type from the Num typeclass. It is very important to distinguish between the type constructor and the value constructor. When declaring a data type, the part before the = is the type constructor and the constructors after it are value constructors. Derived instances A type can be an instance of a typeclass if it supports a particular behaviour. Haskell can automatically make a type an instance of any of the following typeclasses: Eq, Ord, Enum, Bounded, Show, Read. When we derive the Eq instance for a type and then try to compare two values, Haskell will see if the value constructors match, and it will then check if all the data contained inside matches by testing each pair of fields, each of which also have to be part of the Eq typeclass. We can derive instances for the Ord typeclass. If we compare two values of the same type that were made using different constructors, the value which was made with a constructor that\u2019s defined first is smaller. data Bool = False | True deriving (Ord) Because the False constructor is specified first, we can consider True to be greater than False. In the Maybe a data type, the Nothing value constructor is specified before the Just value constructor. We can use algebraic data types to make enumerations with the Enum and Bounded typeclasses. data Day = Monday | Tuesday | Wednesday | Thursday | Friday | Saturday | Sunday deriving (Eq, Ord, Show, Read, Bounded, Enum) Day can be made part of the Enum typeclass because all the value constructors are nullary, taking no parameters. &gt; show Wednesday &gt; "Wednesday" &gt; read "Saturday" :: Day &gt; Saturday &gt; Saturday &gt; Friday &gt; True &gt; minBound :: Day &gt; Monday &gt; succ Monday &gt; Tuesday &gt; [Thursday .. Sunday] &gt; [Thursday, Friday, Saturday, Sunday] Type synonyms Type synonyms allow giving different names to complex types. type String = [Char] We are not actually defining a new type, only creating a synonym for an existing one. In the same way that functions can be partially applied, type parameters can also be partially applied type IntMap v = Map Int v or type IntMap = Map Int The Either data type takes two types as its parameters. data Either a b = Left a | Right b deriving (Eq, Ord, Read, Show) Either is useful to return a value and a possinle error. Recursive data structures We can make types whose constructors have fields that are of the same type. data List a = Empty | Cons a (List a) deriving (Show, Read, Eq, Ord) This list definition is either empty or a combination of a head value and a list. Cons is another word for :. We can define functions to be automatically infix by making them comprised of special characters. infixr 5 :-: data List a = Empty | a :-: (List a) deriving (Show, Read, Eq, Ord) When we define functions as operators, we can give them a fixity. The fixity states the associativity and the strength of the binding. &gt; 3 :-: 4 :-: 5 :-: Empty &gt; (:-:) 3 ((:-:) 4 ((:-:) 5 Empty)) When deriving Show for the type, Haskell will display it as if the constructor was a prefix function. Binary search tree data Tree a = EmptyTree | Node a (Tree a) (Tree a) deriving (Show, Read, Eq) Instead of manually building a tree, we can make a function that takes a tree and an element and inserts an element. singleton :: a -&gt; Tree a singleton x = Node x EmptyTree EmptyTree treeInsert :: (Ord a) =&gt; a -&gt; Tree a -&gt; Tree a treeInsert x EmptyTree = singleton x treeInsert x (Node a left right) | x == a = Node x left right | x &lt; a = Node a (treeInsert x left) right | x &gt; a = Node a left (treeInsert x right) treeElem :: (Ord a) =&gt; a -&gt; Tree a -&gt; Bool treeElem :: x EmptyTree = False treeElem :: x (Node a left right) | x == a = True | x &lt; a = treeElem x left | x &gt; a = treeElem x right We can use a fold to build up a tree from a list. &gt; let nums = [8,6,4,1,7,3,5] &gt; let numsTree = foldr treeInsert EmptyTree nums &gt; numsTree &gt; Node 5 (Node 3 (Node 1 EmptyTree EmptyTree) (Node 4 EmptyTree EmptyTree)) (Node 7 (Node 6 EmptyTree EmptyTree) (Node 8 EmptyTree EmptyTree)) Typeclasses The Eq typeclass is defined as follows class Eq a where (==) :: a -&gt; a -&gt; Bool (/=) :: a -&gt; a -&gt; Bool x == y = not (x /= y) x /= y = not (x == y) data TrafficLight = Red | Yellow | Green instance Eq TrafficLight where Red == Red = True Green == Green = True Yellow == Yellow = True _ == _ = False While Eq could have been implemented automatically, the code above demonstrates how it can be implemented by hand. The instance keyword is for making type instancs of typeclasses. Because == was defined in terms of \u2018/=\u2019 and vice versa in the class declaration, we only had to overwrite one of them in the instance. instance Show TrafficLight where show Red = "Red light" show Yellow = "Yellow light" show Green = "Green light" Typeclasses can also be subclasses of other typeclasses. class (Eq a) =&gt; Num a where This states that we have to make a type an instnace of Eq before it can be made an instance of Num. In the declaration of Eq we can see that a is used as a concrete type because all the types in functions have to be concrete types. For Maybe we must write instance Eq (Maybe m) where Just x == Just y = x == y Nothing == Nothing = True _ == _ = False We must also ensure that m is an instance of Eq to allow it to be compared. instance (Eq m) =&gt; Eq (Maybe m) where ... Most of the time, class constraints in class declarations are used for making a typeclass a subclass of another typeclass and class constraints in instance declarations are used to express requirements about the contents of some type. The :info command can be used to display information about a typeclass. Yes-No typeclass In some weakly typed languages, anything can be passed to a conditional expression. In JavaScript, non empty strings, and non 0 numbers are considered to be True. We could implement this in Haskell class YesNo a where yesno :: a -&gt; Bool instance YesNo Int where yesno 0 = False yesno _ = False instance YesNo [a] where yesno [] = False yesno _ = True instance YesNo Bool where yesno = id -- id is a standard library function which takes a parameter and returns the same thing instance YesNo (Maybe a) where yesno (Just _) = True yesno Nothing = False &gt; yesno $ length [] &gt; False &gt; yesno "test" &gt; True &gt; yesno "" &gt; False &gt; :t yesno &gt; Yesno :: (YesNo a) =&gt; a -&gt; Bool We can now create a function that mimics the if statement, but works with YesNo values yesnoIf :: (YesNo y) =&gt; y -&gt; a -&gt; a -&gt; a yesnoIf yesnoVal yesResult noResult = if yesno yesnoVal then yesResult else noResult The Functor typeclass class Functor f where fmap :: (a -&gt; b) f a -&gt; f b The Functor typeclass defines a single function, fmap. f is not a concrete type, but a type constructor that takes one parameter. fmap takes a function from one type to another and a functor applied with one type and returns a functor applied with another type. The list is an instance of the Functor typeclass instance Functor [] where fmap = map We didn\u2019t write instance Functor [a] because from fmap :: (a -&gt; b) -&gt; f a -&gt; f b we see that the f has to be a type constructor that takes one type. [a] is a concrete type, while [] is a type constructor that takes one type. Types that can act like a box can be functors. Maybe can act like a box, holding Just &lt;something&gt; or Nothing. instance Functor Maybe where fmap f (Just x) = Just (f x) fmap f Nothing = Nothing Again we did not specify a type. Functor wants a type constructor that takes one type and not a concrete type. The Tree a can be mapped over and made an instance of Functor. instance Functor Tree where fmap f EmptyTree = EmptyTree fmap f (Node x leftsub rightsub) = Node (f x) (fmap f leftsub) (fmap f righsub) The fmap function for Tree recursively applies f to each of the items in the Tree. &gt; fmap (*4) (foldr treeInsert EmptyTree [5,7,3,2,1,7]) &gt; Node 28 (Node 4 EmptyTree (Node 8 EmptyTree (Node 12 EmptyTree (Node 20 EmptyTree EmptyTree)))) EmptyTree Now consider Either a b. The Functor typeclass wants a type constructor that takes only one type parameter, but Either takes two. We can partially apply Either by feeding it only one parameter, so that it has one free parameter. instance Functor (Either a) where fmap f (Right x) = Right (f x) fmap f (Left x) = Left x Either a is a type constructor that takes one parameter. The type signature for this specific fmap will be (b -&gt; c) -&gt; Either a b -&gt; Either a c In the implementation, we mapped in the case of a Right value constructor but not in the case of a Left. If we wanted to map one function over both of them, a and b would have to be the same type. Maps from Data.Map can also be made a functor because they hold values. fmap will map a function v -&gt; v\' over a map of type Map k v and return a map of type Map k v\'. Functors should obey some laws. fmap id = id fmap (g . f) = fmap g . fmap f Kinds Functions are also values because we can pass them etc. Types are like labels carried by values so that we can reason about them. Types have their own labels called kinds. A kind is something like the type of a type. &gt; :k Int &gt; Int :: * A * means that the type is a concrete type, a type without type parameters. &gt; :k Maybe &gt; Maybe :: * -&gt; * The Maybe constructor takes one concrete type, and then returns a concrete type. &gt; :k Maybe Int &gt; Maybe Int :: * We use :k on a type to get its kind, just like :t on a value to get its type. &gt; :k Either &gt; Either :: * -&gt; * -&gt; * &gt; :k Either Int &gt; Either Int :: * -&gt; * Either takes two concrete types as type parameters to produce a concrete type. A partially applied either takes a single concrete type to produce a concrete type. class Tofu t where tofu :: j a -&gt; t a j Because j a is used as the type of a value that the tofu function takes as its parameter, j a has to have a kind of *. We assume * for a so we can infer that j has to have a kind of * -&gt; *. We see that t has to produce a concrete value to, and that it takes two types. Knowing that a has a kind of * and j has a kind of * -&gt; *, we infer that t has to have a kind of * -&gt; (* -&gt; *) -&gt; *. So, it takes a concrete type (a), a type constructor that takes one concrete type (j) and produces a concrete type. data Frank a b = Frank {frankField :: b a} deriving (Show) This type has a kind of * -&gt; (* -&gt; *) -&gt; *. Fields in algebraic data types are made to hold values, so the must be of kind *. We assume * for a, which means that b takes one type parameter and so its kind is * -&gt; *. We now see that Frank has a kind of * -&gt; (* -&gt; *) -&gt; *. &gt; :t Frank {frankField = Just "String"} &gt; Frank {frankField = Just "String"} :: Frank [Char] Maybe &gt; :t Frank {frankField = "String"} &gt; Frank {frankField = "String"} :: Frank Char [] Because frankField has a type of form a b, its values must have types that are of a similar form as well. They can be Just "String", which has a type of Maybe [Char], or they can have a value of [\'S\', \'t\', \'r\', \'i\', \'n\', \'g\'] which has a type of [Char]. Making Frank an instance of Tofu is quite simple. tofu takes a j a, and returns a type of t a j instance Tofu Frank where tofu x = Frank x &gt; tofu (Just \'a\') :: Frank Char Maybe &gt; Frank {frankField = Just \'a\'} &gt; tofu ["HELLO"] :: Frank [Char] [] &gt; Frank {frankField = ["HELLO"]} This has no real use. A more complicated type is: data Barry t k p = Barry { yabba :: p, dabba :: t k} Now we want to make it an instance of Functor. Functor wants types of kind * -&gt; * It is safe to assume that p is a concrete type, and thus has a kind of *. For k, we assume *, and so t has a kind of * -&gt; *. Barry has a kind of (* -&gt; *) -&gt; * -&gt; * -&gt; *. Now we can make this type a part of Functor. We have to partially apply the first two type parameters, so that we are left with * -&gt; *. This means that the start of the instance declaration will be instance Functor (Barry a b) where. Considering fmap specifically for Barry, it would have type fmap :: (a -&gt; b) -&gt; Barry c d a -&gt; Barry c d b when the Functor\u2019s f is replaced with Barry c d. instance Functor (Barry a b) where fmap f (Barry {yabba = x, dabba = y}) = Barry {yabba = f x, dabba = y} Input and output The function putStrLn prints a string &gt; :t putStrLn &gt; putStrLn :: String -&gt; IO () putStrLn takes a string and returns an IO action, that has a result type of (). An IO action is something that, when performed, will carry out an action with a side-effect, and will also contain some kind of return value. Printing a string doesn\u2019t have a meaningful return value, so an empty tuple is returned. An IO action will be performed when we give it a name of main and then run our program. main = do putStrln "Hello, what is your name?" name &lt;- getLine putStrLn ("Hello" ++ name) main always has a type signature of main :: IO &lt;type&gt; where &lt;type&gt; is some concrete type. By convention, we do not usually specify a type declaration for main. getLine reads a line from the input, it has a type getLine :: IO String. The line name &lt;- getLine can be read as perform the IO action and then bind its result to name. As getLine has a type IO String, name will have a type of String. We can only take the data from getLine with &lt;- from within another IO action. getLine is impure because its result value is not guaranteed to be the same when performed twice. In a do block, the last action cannot be bound to a name. IO actions will only be performed when they are given a name of main or when they are inside a bigger IO faction that we composed with a do block. main = do line &lt;- getLine if null line then return () else do putStrLn $ reverseWords line main reverseWords :: String -&gt; String reverseWords = unwords . map reverse . words The program above reads input and reverses it until a blank line is input. In an IO do block, ifs have to have a form of if condition then IO action else IO action. Because we have to do exactly one IO action after the else, we use a do block to glue together two IO actions into one. Haskell return While return in most languages ends execution of a method or subroutine, in Haskell (IO actions specifically), it makes an IO action out of the pure value. Using return does not cause the IO do block to end execution. All these returns do is make IO actions that don\u2019t do anything. We can use return in combination with &lt;- to bind to names. main = do a &lt;- return "String" b &lt;- return "gnirtS" putStrLn $ a ++ " " ++ b When dealing with IO blocks we mostly use return either because we need to create an IO action that does not do anything or because we do not want the IO action that is made up from a do block to have the result value of its last action. IO functions putStr takes a string as a parameter and returns an IO action that will print without a newline putChar takes a character as a parameter and returns an IO action that will print it print takes a value of a type that is an instance of Show, and prints it getChar an IO action that reads a character form input. Reading does not happen until the user presses the enter key when is found in Control.Monad. In a do block it appears like a control flow statement, but it is a function. It takes a boolean value and an IO action. If the boolean value is True, it returns the same IO action passed to it, otherwise it returns the return () action. sequence takes a list of IO actions and returns an IO action which will perform all of the Io actions in the list. sequence :: [IO a] -&gt; IO [a] mapM and mapM_ mapM takes a function and a list, maps the function over the list and then sequences it, mapM_ does the same except that it throws away the result later. mapM_ is used when we do not care what result our sequenced IO actions have forever located in Control.Monad, takes an IO action and returns an IO action that repeats the IO action forever forM located in Control.Monad, is like mapM except that it has its parameters switched around. The first parameter is the list and the second is the function to map over that list, which is then sequenced import Control.Monad main = do colors &lt;- forM [1,2,3,4] (\\a -&gt; do putStrLn $ "Which color do you associate with the number " ++ show a ++ "?" color &lt;- getLine return color) putStrLn "The collors that you associate with 1, 2, 3, and 4 are: " mapM putStrLn colors The (\\a -&gt; do ...) is a function that takes a number and returns an IO action. We have to surround it with parentheses, otherwise the lambda thinks the last two IO actions below to it. We do return color in the inside do block. We do that so that the IO action which the do block defines has the result of our color contained within it. We could have left the last line as getLine. The forM called with its two parameters, produces an IO action, whose result we bind to colors. colors is just a list of strings. At the end we print out those strings with mapM putStrLn colors. forM can be thought of as meaning \u2018make an IO action for every element in this list, perform those actions and bind their results to something\u2019. Files and streams getContents is an IO action that reads everything from the standard input until it encounters an end-of-file character. Its type is getContents :: IO String. getContents does lazy IO. The pattern of getting some string from the input, transforming it with a function, and then outputting the result is so common that there exists a function for it. interact takes a function of type String -&gt; String as a parameter and returns an IO action that will take some input run that function on it and then print out the function\u2019s result. main = interact shortLinesOnly shortLinesOnly :: String -&gt; String shortLinesOnly input = let allLines = lines input shortLines = filter (\\line -&gt; length line &lt; 10) allLines result = unlines shortLines in result We could write thie in a less readable manner main = interact $ unlines . filter ((&lt;10) . length) . lines interact can be used to make programs that are piped some contents into them and then dump some result out, or it can be used to make programs that appear to take a line of input from the user, give back some result and then take another line and so on. respondPalindromes contents = unlines (map (\\xs -&gt; if isPalindrome xs then "palindrome" else "not a palindrome") (lines contents)) where isPalindrome xs = xs == reverse xs',
tags:"Notes Haskell Functional",url:"/Haskell-Notes"},{title:"Statistics Notes",text:"SS02 Time series analysis Seasonal variation When asked for the type of variation Seasonal variation If the variations from the fit line appear to follow a pattern Random variation If they don\u2019t Moving averages and seasonal effects Moving averages For Centered moving average The average of the current moving average and the surrounding moving averages The seasonal effect is the average of the values of the difference between the actual values and the centered moving average. Take the centered moving average and subtract it from the actual value for each item in a group. Then calculate the average of these values. Estimation from seasonal effects Once the seasonal effects has been calculated the fit line can be used to find a value for a given time, and the seasonal effect can then be applied to this value to produce an estimate Sampling Simple random samples Assign a range of values to the data Choose random values from the number table, starting from a random position Each item has the same probability of being chosen. If the data is in sections, each section may not be represented. May not give correct representations of strata. Stratified random sampling There may often be factors which divide up the population into groups (strata), and we may expect the measurement of interest to vary among the different groups. This can be accounted for when we select a sample from the population in order that we obtain a sample that is representative of the population. We generally require that the proportion of each stratum in the sample should be the same as in the population. Stratified sampling techniques are generally used when the population is heterogeneous, or dissimilar, where certain homogeneous sub populations can be isolated. Some reasons for using stratified sampling over simple random sampling are: The cost per observation may be reduced Estimates of the population parameters may be wanted for each sub-population Increased accuracy at a given cost Cluster, quota, and systematic sampling Cluster sampling The data is is divided into separate groups. Then a simple random sample of clusters is selected from the population. The population is divided into groups, called clusters The researcher randomly selects clusters to include in the sample The number of observations within each cluster is known, and . One-stage sampling All of the elements within selected clusters are included in the sample Two-stage sampling A subset of elements within selected clusters are randomly selected for inclusion in the sample Sometimes, the cost per sample point is less for cluster sampling than for other sampling methods. Given a fixed budget, the researcher may be able to use a bigger sample with cluster sampling than with the other methods. When the increased sample size is sufficient to offset the loss in precision, cluster sampling may be the best choice. Application: Select a cluster grouping as a sampling frame Mark each cluster with a unique number Choose a sample of clusters applying probability sampling Quota sampling Quota sampling requires, that representative individuals are chosen from a specific subgroup Advantages: Primary collection can be done in a short time The application of quota sampling can save costs and time Quota sampling is not dependent on the presence of the sampling frames. Disadvantages: It is not possible to calculate the sampling error Other important characteristics may be disproportionately represented in the final sample group There is a potential for researcher bis and the quality of work may suffer due to researcher incompetency Systematic sampling A sampling method in which the first position in the data set is randomly chosen, and every position after this is also chosen Advantages: Allows the researcher to add a degree of system or process into the random selection Known and equal probability of selection The assurance that the population will be evenly sampled. Simple random sampling allows a clustered selection of subjects Disadvantages: The process of selection can interact with a hidden periodic trait within the population The process can also hide a periodic trait Discrete probability distributions Expectations and variance Poisson (Same as MS02) Interpretation of data Pie charts Line diagrams Box and whisker plots Frequency diagrams Scatter diagrams Histograms not required Hypothesis testing Tests for means Errors Type I error: Rejecting a true null hypothesis Type II error: Accepting a false null hypothesis If it says test. State the fucking hypotheses! Tests Test Details Case to reject \xa0 SS02 \xa0 \xa0 \xa0 Z/T test Determines whether two population means are different TV &gt; CV \xa0 SS03 \xa0 \xa0 \xa0 Contingency tables A test for independence CV &gt; TV \xa0 Sign test Test for difference in medians TV &lt; CV \xa0 Wilcoxon Test for difference in mean or median TV &lt; CV \xa0 Mann-Whitney Test for equality of population TV &lt; CV \xa0 Kruskal-Wallis Test for equality of population of two or more samples TV &gt; CV \xa0 Correlation coefficient Test for existence of correlation between two random variables TV &gt; SL \xa0 SS04 \xa0 \xa0 \xa0 Poisson Test for change in a Poisson variable TV &lt; SL \xa0 Proportion Test whether sample proportion represents the population TV &lt; SL \xa0 SS05 \xa0 \xa0 \xa0 Variance Tests a sample for a given population variance TV &gt; CV(Upper) or TV &lt; CV(Lower) \xa0 Variance equality of samples (F) Test for equality of the variances of the populations of two samples of two normally distributed random variables TV &gt; CV \xa0 Difference in mean (Two sample Z) Test for the difference in the means of two independent populations |TV| &gt; |CV| \xa0 Difference in mean (Two sample T) Test for the difference in the means of two independent populations with unknown variances |TV| &gt; |CV| \xa0 Goodness of fit Test for the fit of a sample to a particular distributio n TV &gt; CV \xa0 SS06 \xa0 \xa0 \xa0 Paired comparisons Analysis of the difference between pairs of values sampled from two normal populations TV &gt; CV \xa0 Analysis of variance An extension of F tests with more than 2 populations TV &gt; CV \xa0 Two way analysis of variance An analysis of variance which accounts for a second factor TV &gt; CV \xa0 Latin squares \xa0 \xa0 \xa0 SS03 Contingency tables State hypotheses (In context) i. : No assocation ii : Assocation Calculate the expected values. If any value is less than 5, merge the rows or columns Calculate the text statistic Find the critical value for degrees of freedom. This can either be done from the table or with If text , reject in context Yates\u2019 correction For a 2 by 2 table, Yates\u2019 correction is used. Rather than the corrected formula is Distribution free methods Test For Use case Sign test Median When Wilcoxon cannot be used as data is not symmetrical or is non-numeric Wilcoxon signed-rank test Median or Mean When a z or t test cannot be used Mann-Whitney U test Equality of populations of two samples There are two samples Kruskal-Wallis test Equality of populations of two or more samples There are more than two samples Sign test The sign test checks for a difference in the median value by comparing each pair. It does not require a symmetric distribution and could be used on non-numeric data so long as the data can be assigned to two groups (e.g. boolean values of opinions) State hypotheses i. that population medians are equal ii. : that population medians are not equal or Find the differences between each pair, ignoring any equal values Count the number of positive differences and the number of negative differences Find the value of Compare the value above with the significance level. If it is less, reject Wilcoxon Signed-rank test The Wilcoxon test is similar to the sign test except that it ranks the differences ignoring their signs. State the hypotheses i. Population average difference (in mean or median) of 0 ii. Population average difference not 0 Rank the absolutes of the differences, giving each rank the sign of its respective difference Calculate and , the sums of the positive and negative ranks respectively. Let Find the critical value, from the table Compare to , rejecting if is smaller Mann-Whitney U-test The Mann-Whitney U test tests whether two samples were taken from the same population. It is used when a t test cannot be applied as the data is not normal State the hypotheses i. The samples are from the same population, ii. The samples are from different populations, Rank the entire dataset and calculate the sum of the ranks for each set Calculate the test statistic for each set where is the sum of the ranks of the set and is the size of the set. Let Find the critical value for the significance level and the size of each data set If is less than the critical value, reject Kruskal-Wallis test The Kruskal-Wallis test is a non-parametric version of the ANOVA test. It determines a difference between samples State the hypotheses i. All samples are from the same population ii. Samples are from different populations Rank the entire dataset and calculate the sum of the ranks of each set Calculate the test statistic where is the sum of all samples sizes, and and are the rank sums and sizes of each sample Find the degrees of freedom, the number of samples minus one Calculate the critical value for the given significance level either from the tables or with If the test statistic is larger than the critical value, reject Correlation Spearman\u2019s Rank Correlation Coefficient Spearman\u2019s rank correlation coefficient is used when the data is ranked. The value is given by where is the difference between the rank of a pair of values, and is the (equal) size of each dataset Testing with the correlation coefficient A test can be carried out in order to determine whether there is or is not a correlation between two random variables. Assuming that the correlation coefficient, , is already known. State the hypotheses i. (independent) ii. (not-independent) Find the critical value from the table If the correlation coefficient is greater than the critical value, reject SS04 Linear combinations of independent normal variables If the letters and are variables and the letters and are constants then A linear combination of independent, normal variables will itself be normally distributed Given a normal distribution , if an event is given which is times then this new event has a distribution . The standard deviation of the new event is then . Given two normal distributions , and the normally distributed random variable has the distribution . Approximating distributions The purpose of making an approximation is: To reduce the amount of calculation To allow tables to be used where they otherwise could not To calculate confidence intervals The binomial distribution may be approximated by the Poisson distribution if and The conditions for the approximations are rules of theu,b. They are not shar dividing lines between good approximations and bad approximations The binomial distribution may be approximated by the normal distribution if and The Poisson distribution may be approximated by the normal distribution if Confidence intervals An estimate of a population standard deviation calculated from a random sample of size has degrees of freedom If is the mean of a random sample of size from a normal distribution with mean a confidence interval for is given by Further confidence intervals If is an observation from a Poisson distribution with mean then an approximate confidence interval for is given by , provided that is reasonably large, say If is an observation from a binomial distribution with parameters then an approximate confidence interval for is given by , provided is reasonably large, say Further hypothesis testing for means To carry out a hypothesis test for a mean based on a sample from a normal distribution with an unknown standard deviation: The test statistic is where Hypothesis tests for proportions and for the mean of a Poisson distribution To test hypotheses about a binomial population proportion, , either: a. Determine the cumulative binomial probability of State that the mean remains the same, and that it exhibits the expected change. Then find the probability that this value occurs, and reject if the probability is higher than the level of the test. b. use The hypotheses are then dealt with like a regular normal hypothesis test. To test hypotheses about a Poisson population mean , either a. Determine the cumulative Poisson probability of , or b. use SS05 Continuous probability distributions The random variables having probability density function where and are constants, it is said to follow a rectangular distribution The mean of is and the variance of is The exponential distribution has probability density function The exponential distribution with parameter has mean and standard deviation is known as the cumulative distribution function and is usually denoted For the exponential distribution with parameter , If and are two constants and , the probability that takes a value between and is The intervals between successive events from a Poisson distribution with mean are distributed according to the exponential distribution with parameter Estimation If denotes the variance estimate from a random sample of size from a normal population with variance of , then The distribution is not symmetric so both lower and upper percentage points need to be read from tables A confidence interval for a normal population variance, , is given by and Confidence limits for a normal population standard deviation, are found by taking the square root of those calculated for the population variance Hypothesis testing: one sample tests To test hypotheses about a normal population variance, or standard deviation , use To test hypotheses about a normal population with mean, , use Hypothesis testing: two-sample tests To test hypotheses about the equality of two normal population variances, or standard deviations, use To test hypotheses about the equality of (or given differece in) two normal population means, based upon independent random samples and known population variances use Note that for and the requirement for normal populations canbe relaxed and/or sample variances can be used as estimates of the population variances To test hypotheses about the equality of (or given difference in) two normal population means, based upon independent random samples and unknown but equal population variances use where Testing for goodness of fit may be approximated by a distribution provided that The s are frequenceies, The s are at least five, The classes form a sample space that is, every possible observation fits into one and only one class The number of degrees of freedom is the number of classes, minus the number of independent pieces of information derived from the s in order to calculate the s If there are classes and any necessary parameters are estimated from the data the number of degrees of is for a Poisson, binomial, or exponential distribution, and for a normal distribution SS06 Experimental design Experimental error is the effect of factors other than those controlled by the experimenter In a paired comparison, experimental error is reduced by applying both treatments to the same subjects or in the same conditions The purpose of randomisation is to eliminate bias Blocking is used to reduce experimental error by applying treatments (usually more than two) to the same subjects or in the same conditions If a new treatement is applied to an experimental group, a control group, which receives no treatment or the standard treatment, is needed to act as a measure of the effect of not applying the new treatment A placebo is a pill or treatment which contains no active ingredient In a blind trial subjects do not know whether they are receiving the treatment or a placebo In a double blind trial neither the subject nor the person administering the treatment knows whether a placebo or an active drug is being given Analysis of paired comparisons If and denote the mean and standard deviation, respectively, of a random sample of differences that can be assumed to be normally distributed with mean then Analysis of variance (ANOVA) The assumptions for the three models considered, one and two factor ANOVAs, and Latin square designs, are that: a. The observations are obtained independently and randomly from populations at each factor level (combination) b. These populations are (approximately) normally distributed with common variance $\\sigma^2$ c. When two or more factors are involved, there is no interaction between them One way ANOVA table Source of variation Sum of squares Degrees of freedom Mean square F ratio Between samples Within samples \xa0 Total \xa0 \xa0 Two way ANOVA table Source of variation Sum of squares Degrees of freedom Mean square F ratio Between rows Between columns \xa0 Error \xa0 Total \xa0 \xa0 Provided in the formulae booklet Statistical process control Statistical process control may be used when a large number of similar items are being produced. Its purpose is to give a signal when the process mean has moved away from the target value or when item-to-item variability has increased For control charts for means: Sample mean between warning limits- No action Sample mean between arning and action limits- Take another sample immediately. If new sample mean outside warning limits take action Sample mean outside action limits- Take action The warning limits are set at , and the action limits at , where is the target value, is the short-term standard deviation, and is the sample size Variability may be controlled by plotting the sample ranges or standard deviations on control charts. The limits for these charts are found by multiplying the process short-term standard deviation found by factors in the control charts for variability (Table 12) When the standard deviation must be estimated from a number of small samples the average sample range can be calculated and a factor from table 12 applied. Alternatively can be calculated for each sample and the formula evaluated If the tolerance width exceeds six standard deviations the process should be able to meet the tolerances consistently, provided the mean is kept on target For charts for proportion non-conforming providing is reasonably large: The warning limits are The action limits are Acceptance sampling Acceptance sampling may be applied to large batches of similar items. It is the process of deciding whether or not the batch is acceptable by testing a small sample of the items The operating characteristic for an acceptance sampling by attributes plan is a graph of probability of acceptance against proportion non-conforming in the batch The probabilities may be found from the binomial distribution provided the sample is random and the sample size is small compared to the batch In double sampling, the number of non-conforming items in the first sample will determine whether a decision is made immediately or whether it is delayed until a second sample has been inspected For acceptance sampling by variables the operating characteristic is a graph of probability of acceptance against batch mean MS03 Bayes\u2019 theorem Example Event P(A) P(B) C 0.3 0.8 D 0.5 0.1 E 0.2 0.4 After event A, event B occured. Find the probability that event E occured. Let F be the probability that event B occured. Linear combinations of random variables Covariance is a measure of the joint variability of two random variables. The covariance can be used to find the product moment correlation coefficient of two random variables: The variance can also be computed as Distributional approximations Mean and variance of binomial and Poisson distributions Proof of for binomial Proof of for binomial",tags:"Notes Statistics",url:"/Statistics-Notes"}]},tipuesearch_stop_words=["a","about","above","after","again","against","all","am","an","and","any","are","aren't","as","at","be","because","been","before","being","below","between","both","but","by","can't","cannot","could","couldn't","did","didn't","do","does","doesn't","doing","don't","down","during","each","few","for","from","further","had","hadn't","has","hasn't","have","haven't","having","he","he'd","he'll","he's","her","here","here's","hers","herself","him","himself","his","how","how's","i","i'd","i'll","i'm","i've","if","in","into","is","isn't","it","it's","its","itself","let's","me","more","most","mustn't","my","myself","no","nor","not","of","off","on","once","only","or","other","ought","our","ours","ourselves","out","over","own","same","shan't","she","she'd","she'll","she's","should","shouldn't","so","some","such","than","that","that's","the","their","theirs","them","themselves","then","there","there's","these","they","they'd","they'll","they're","they've","this","those","through","to","too","under","until","up","very","was","wasn't","we","we'd","we'll","we're","we've","were","weren't","what","what's","when","when's","where","where's","which","while","who","who's","whom","why","why's","with","won't","would","wouldn't","you","you'd","you'll","you're","you've","your","yours","yourself","yourselves"],tipuesearch_replace={words:[{word:"tip",replace_with:"tipue"},{word:"javscript",replace_with:"javascript"},{word:"jqeury",replace_with:"jquery"}]},tipuesearch_weight={weight:[{url:"http://www.tipue.com",score:20},{url:"http://www.tipue.com/search",score:30},{url:"http://www.tipue.com/is",score:10}]},tipuesearch_stem={words:[{word:"e-mail",stem:"email"},{word:"javascript",stem:"jquery"},{word:"javascript",stem:"js"}]},tipuesearch_related={searches:[{search:"tipue",related:"Tipue Search"},{search:"tipue",before:"Tipue Search",related:"Getting Started"},{search:"tipue",before:"Tipue",related:"jQuery"},{search:"tipue",before:"Tipue",related:"Blog"}]},tipuesearch_string_1="No title",tipuesearch_string_2="Showing results for",tipuesearch_string_3="Search instead for",tipuesearch_string_4="1 result",tipuesearch_string_5="results",tipuesearch_string_6="Back",tipuesearch_string_7="More",tipuesearch_string_8="Nothing found.",tipuesearch_string_9="Common words are largely ignored.",tipuesearch_string_10="Search too short",tipuesearch_string_11="Should be one character or more.",tipuesearch_string_12="Should be",tipuesearch_string_13="characters or more.",tipuesearch_string_14="seconds",tipuesearch_string_15="Searches related to",startTimer=(new Date).getTime();defer(function(){!function(e){e.fn.tipuesearch=function(t){var a=e.extend({contentLocation:"tipuesearch/tipuesearch_content.json",contextBuffer:60,contextLength:60,contextStart:90,debug:!1,descriptiveWords:25,highlightTerms:!0,liveContent:"*",liveDescription:"*",minimumLength:3,mode:"static",newWindow:!1,show:9,showContext:!0,showRelated:!0,showTime:!0,showTitleCount:!0,showURL:!0,wholeWords:!0},t);return this.each(function(){function t(e){var t=location.search,a=RegExp("[?|&]"+e+"=([^&;]+?)(&|#|;|$)").exec(t)||[,""],n=a[1].replace(/\+/g,"%20");try{n=decodeURIComponent(n)}catch(e){n=unescape(n)}return n||null}function n(t,o){var l="",h=!1,c=!1,u=!0,d=0;found=[];var p=e("#tipue_search_input").val(),m=p.toLowerCase();m=e.trim(m),(m.match('^"')&&m.match('"$')||m.match("^'")&&m.match("'$"))&&(u=!1);var g=m.split(" ");if(u){m="";for(var f=0;f<g.length;f++){for(var y=!0,w=0;w<tipuesearch_stop_words.length;w++)g[f]==tipuesearch_stop_words[w]&&(y=!1,c=!0);y&&(m=m+" "+g[f])}m=e.trim(m),g=m.split(" ")}else m=m.substring(1,m.length-1);if(m.length>=a.minimumLength){if(u){if(o){for(var b=m,f=0;f<g.length;f++)for(var w=0;w<tipuesearch_replace.words.length;w++)g[f]==tipuesearch_replace.words[w].word&&(m=m.replace(g[f],tipuesearch_replace.words[w].replace_with),h=!0);g=m.split(" ")}for(var v=m,f=0;f<g.length;f++)for(var w=0;w<tipuesearch_stem.words.length;w++)g[f]==tipuesearch_stem.words[w].word&&(v=v+" "+tipuesearch_stem.words[w].stem);g=v.split(" ");for(var f=0;f<i.pages.length;f++){for(var x=0,k=i.pages[f].text,w=0;w<g.length&&"/"!=i.pages[f].url&&"/tags"!=i.pages[f].url;w++){if(a.wholeWords)var T=RegExp("\\b"+g[w]+"\\b","gi");else var T=RegExp(g[w],"gi");if(-1!=i.pages[f].title.search(T)){var _=i.pages[f].title.match(T).length;x+=20*_}if(-1!=i.pages[f].text.search(T)){var _=i.pages[f].text.match(T).length;x+=20*_}if(-1!=i.pages[f].tags.search(T)){var _=i.pages[f].tags.match(T).length;x+=10*_}if(-1!=i.pages[f].url.search(T)&&(x+=20),0!=x)for(var I=0;I<tipuesearch_weight.weight.length;I++)i.pages[f].url==tipuesearch_weight.weight[I].url&&(x+=tipuesearch_weight.weight[I].score);g[w].match("^-")&&(T=RegExp(g[w].substring(1),"i"),(-1!=i.pages[f].title.search(T)||-1!=i.pages[f].text.search(T)||-1!=i.pages[f].tags.search(T))&&(x=0))}0!=x&&(found.push({score:x,title:i.pages[f].title,desc:k,url:i.pages[f].url}),d++)}}else for(var f=0;f<i.pages.length;f++){var x=0,k=i.pages[f].text,T=RegExp(m,"gi");if(-1!=i.pages[f].title.search(T)){var _=i.pages[f].title.match(T).length;x+=20*_}if(-1!=i.pages[f].text.search(T)){var _=i.pages[f].text.match(T).length;x+=20*_}if(-1!=i.pages[f].tags.search(T)){var _=i.pages[f].tags.match(T).length;x+=10*_}if(-1!=i.pages[f].url.search(T)&&(x+=20),0!=x)for(var I=0;I<tipuesearch_weight.weight.length;I++)i.pages[f].url==tipuesearch_weight.weight[I].url&&(x+=tipuesearch_weight.weight[I].score);0!=x&&(found.push({score:x,title:i.pages[f].title,desc:k,url:i.pages[f].url}),d++)}if(0!=d){if(a.showTitleCount&&0==s){var S=document.title;document.title="("+d+") "+S,s++}if(h&&(l+='<div id="tipue_search_warning">'+tipuesearch_string_2+" "+m+". "+tipuesearch_string_3+' <a id="tipue_search_replaced">'+b+"</a></div>"),1==d?l+='<div id="tipue_search_results_count">'+tipuesearch_string_4:(c_c=(""+d).replace(/\B(?=(\d{3})+(?!\d))/g,","),l+='<div id="tipue_search_results_count">'+c_c+" "+tipuesearch_string_5),a.showTime){l+=" ("+(((new Date).getTime()-startTimer)/1e3).toFixed(2)+" "+tipuesearch_string_14+")",a.showTime=!1}l+="</div>",found.sort(function(e,t){return t.score-e.score});for(var F=0,f=0;f<found.length;f++){if(F>=t&&F<a.show+t){if(l+='<a class="tipue_search_content_title" href="'+found[f].url+'"'+r+">"+found[f].title+"</a>",a.debug&&(l+='<div class="tipue_search_content_debug">Score: '+found[f].score+"</div>"),a.showURL){var C=found[f].url.toLowerCase();0==C.indexOf("http://")&&(C=C.slice(7)),l+='<div class="tipue_search_content_url"><a href="'+found[f].url+'"'+r+">"+C+"</a></div>"}if(found[f].desc){var W=found[f].desc;if(a.showContext){g=m.split(" ");var A=found[f].desc.toLowerCase().indexOf(g[0]);if(A>a.contextStart){var N=W.substr(A-a.contextBuffer),q=N.indexOf(" ");N=W.substr(A-a.contextBuffer+q),N=e.trim(N),N.length>a.contextLength&&(W="... "+N)}}if(u){g=m.split(" ");for(var w=0;w<g.length;w++)if(a.highlightTerms){var E=RegExp("("+g[w]+")","gi");W=W.replace(E,"<h0011>$1<h0012>")}}else if(a.highlightTerms){var E=RegExp("("+m+")","gi");W=W.replace(E,'<span class="tipue_search_content_bold">$1</span>')}var M="",O=W.split(" ");if(O.length<a.descriptiveWords)M=W;else for(var w=0;w<a.descriptiveWords;w++)M+=O[w]+" ";M=e.trim(M),"."!=M.charAt(M.length-1)&&(M+=" ..."),M=M.replace(/h0011/g,'span class="tipue_search_content_bold"'),M=M.replace(/h0012/g,"/span"),l+='<div class="tipue_search_content_text">'+M+"</div>"}}F++}if(a.showRelated&&u){w=0;for(var f=0;f<tipuesearch_related.searches.length;f++)m==tipuesearch_related.searches[f].search&&(h&&(p=m),w||(l+='<div class="tipue_search_related_title">'+tipuesearch_string_15+' <span class="tipue_search_related_bold">'+p+'</span></div><div class="tipue_search_related_cols">'),l+='<div class="tipue_search_related_text"><a class="tipue_search_related" id="'+tipuesearch_related.searches[f].related+'">',tipuesearch_related.searches[f].before&&(l+='<span class="tipue_search_related_before">'+tipuesearch_related.searches[f].before+"</span> "),l+=tipuesearch_related.searches[f].related,tipuesearch_related.searches[f].after&&(l+=' <span class="tipue_search_related_after">'+tipuesearch_related.searches[f].after+"</span>"),l+="</a></div>",w++);w&&(l+="</div>")}if(d>a.show){var L=Math.ceil(d/a.show),B=t/a.show;if(l+='<nav><div id="tipue_search_foot"><ul id="tipue_search_foot_boxes">',t>0&&(l+='<li role="navigation"><a class="tipue_search_foot_box" accesskey="b" id="'+(t-a.show)+"_"+o+'">'+tipuesearch_string_6+"</a></li>"),2>=B){var P=L;L>3&&(P=3);for(var w=0;P>w;w++)l+=w==B?'<li class="current" role="navigation">'+(w+1)+"</li>":'<li role="navigation"><a class="tipue_search_foot_box" id="'+w*a.show+"_"+o+'">'+(w+1)+"</a></li>"}else{var P=B+2;P>L&&(P=L);for(var w=B-1;P>w;w++)l+=w==B?'<li class="current" role="navigation">'+(w+1)+"</li>":'<li role="navigation"><a class="tipue_search_foot_box" id="'+w*a.show+"_"+o+'">'+(w+1)+"</a></li>"}B+1!=L&&(l+='<li role="navigation"><a class="tipue_search_foot_box" accesskey="m" id="'+(t+a.show)+"_"+o+'">'+tipuesearch_string_7+"</a></li>"),l+="</ul></div></nav>"}}else l+='<div id="tipue_search_warning">'+tipuesearch_string_8+"</div>"}else c?l+='<div id="tipue_search_warning">'+tipuesearch_string_8+". "+tipuesearch_string_9+"</div>":(l+='<div id="tipue_search_warning">'+tipuesearch_string_10+"</div>",l+=1==a.minimumLength?'<div id="tipue_search_warning">'+tipuesearch_string_11+"</div>":'<div id="tipue_search_warning">'+tipuesearch_string_12+" "+a.minimumLength+" "+tipuesearch_string_13+"</div>");e("#tipue_search_content").hide().html(l).slideDown(200),e("#tipue_search_replaced").click(function(){n(0,!1)}),e(".tipue_search_related").click(function(){e("#tipue_search_input").val(e(this).attr("id")),n(0,!0)}),e(".tipue_search_foot_box").click(function(){var t=e(this).attr("id"),a=t.split("_");n(parseInt(a[0]),a[1])})}var i={pages:[]};e.ajaxSetup({async:!1});var s=0;if("live"==a.mode)for(var o=0;o<tipuesearch_pages.length;o++)e.get(tipuesearch_pages[o]).done(function(t){var n=e(a.liveContent,t).text();n=n.replace(/\s+/g," ");var s=e(a.liveDescription,t).text();s=s.replace(/\s+/g," ");var r=t.toLowerCase().indexOf("<title>"),l=t.toLowerCase().indexOf("</title>",r+7);if(-1!=r&&-1!=l)var h=t.slice(r+7,l);else var h=tipuesearch_string_1;i.pages.push({title:h,text:s,tags:n,url:tipuesearch_pages[o]})});"json"==a.mode&&e.getJSON(a.contentLocation).done(function(t){i=e.extend({},t)}),"static"==a.mode&&(i=e.extend({},tipuesearch));var r="";a.newWindow&&(r=' target="_blank"'),t("q")&&(e("#tipue_search_input").val(t("q")),n(0,!0)),e("#search_form").submit(function(e){e.preventDefault()}),e(this).keyup(function(e){"13"==e.keyCode&&n(0,!0)})})}}(jQuery)}),$(document).ready(function(){$("#tipue_search_input").tipuesearch({wholeWords:!1,showURL:!1}),$("#post-page").anchorific(),$("#dropdown-button").click(function(e){console.log("TOC click"),e.stopPropagation(),$("#dropdown-button").hide(),$("#toc-content").show()}),$(document).click(function(){$("#toc-content").hide(),$("#dropdown-button").show()});for(var e=$("#container :header"),t="toc-ul",a=e.length,n="",i=[],s=0;s<a;s++){var o=s+1,r=e[s],l=r.tagName,h=r.getAttribute("id");if(h?h="#"+h:(r.setAttribute("id","tip"+s),h="#tip"+s),n+="\n<li>"+r.innerHTML,o!==a)if(elNextTitleElementName=e[o].tagName,l!==elNextTitleElementName){for(var c=!1,u=1,d=i.length-1;d>=0;d--){if(i[d].tagName===elNextTitleElementName){c=!0;break}u++}c?(n+=new Array(u+1).join("</li>\n</ul>"),i.length=i.length-u):(i.push(r),n+=t?'<ul class="'+t+'">':"<ul>")}else n+="</li>\n";else i.length?n+=new Array(i.length+1).join("</li></ul>"):n+="</li>\n"}n=t?'<ul class="'+t+'">'+n+"</ul>":"<ul>"+n+"</ul>",$("#toc-content").html(n)});</script> </div> </body> </html>